{
  "docs": [
    {
      "id": "b658d5ed-817b-44f3-9443-839161b38ad3",
      "doc_id": "b658d5ed-817b-44f3-9443-839161b38ad3",
      "title": "b658d5ed-817b-44f3-9443-839161b38ad3",
      "updated": 1693159860000,
      "body_original": "\n# 峨眉禅道\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7912828d-2996-49e8-a0d1-d9d8110bc7bc/5dc29d8.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=db3a8ff4f5298280bbe71bf94afef1ced4d179e68aab47df3b8648f713e3ba20&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n周末和亲戚朋友们去了峨眉的七里坪禅道，也许正是成都最热的时候，普通的周末也有很多人，不过和亲近的人一起游玩下还是很愉悦的。这里离峨眉索道不远，不过知道的人应该还不多，想避开攀登峨眉的大部队在附近登山打卡一下的话可以在这里试试。\n\n\n# 技术见闻\n\n\n## Protobuf 编码&避坑指南\n\n\n> [https://www.luozhiyun.com/archives/800](https://www.luozhiyun.com/archives/800)\n\n\nProtobuf 是 Google 开源的一种数据序列化协议，相比于 Json、xml 这些协议，采用了二进制的格式存储数据，可以获得更好的性能。在需要高性能的服务间通信等场景大量应用，我的工作中也有使用到的场景，这篇文章详细介绍了 Protobuf 的特性和开发中的注意事项，值得一读。\n\n\n## MetaGPT：使用 GPTs 组成软件公司\n\n\n> [https://github.com/geekan/MetaGPT](https://github.com/geekan/MetaGPT)\n\n\n给 AI 输入一句话的老板需求，自动输出用户故事 / 竞品分析 / 需求 / 数据结构 / APIs / 文件等信息。MetaGPT 内部包括产品经理 / 架构师 / 项目经理 / 工程师，帮你组建了一个软件公司来完成你的需求。不知道以后会不会有帮这样的 AI 打工成功商业化的例子，到时是生产力的大爆发还是离 AI 取代人类更近了一步呢。 \n\n\n## **一人公司方法论**\n\n\n> [https://github.com/easychen/one-person-businesses-methodology](https://github.com/easychen/one-person-businesses-methodology)\n\n\nServerChan 作者 easychen 编写的一人公司方法论，easychen 应该算是国内小有成就的个人开发者了，他的 Sever 酱，pushdeer 推送方案用户应该不少，这里的思路可以学习下，配合上面的 MetaGPT 效果更佳。\n\n\n## languagetool：语法校对\n\n\n> [https://github.com/languagetool-org/languagetool](https://github.com/languagetool-org/languagetool)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2e44d5af-b5cb-463f-8e8d-43150b1399de/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=7c24ec0ad1586010ec306a902cabc44841f17875c7d3476e53f1a41bf0340a94&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一个开源的词法校对器，它会自动校对你输入文字的语法以及拼写，能有效地检测出拼写错误，以及语法问题。有点像之前 [grammarly](https://www.grammarly.com/) 这款语法检查工具的开源替代，说起 grammarly 这款软件，前几年它几乎是我电脑上的必备软件，但是 AI 功能火了之后，一下有了很多的替代，我也没有再用过这款软件了。\n\n\n来源：[数据处理的那些事「GitHub 热点速览」](https://www.cnblogs.com/xueweihan/p/17592529.html)\n\n\n## **DocHub：分享优质文档**\n\n\n> [https://www.ftium4.com/ux-weekly-153.html](https://www.ftium4.com/ux-weekly-153.html)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/5fe29929-f93f-4241-a696-ccdd0af6336a/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=b6611ba0f3fb754b8505cc6f641b47ce18b11cb6b74a2b5355227d84943b03df&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一个搜罗了腾讯文档、飞书文档、Notion等众多平台的公开分享的优质资料的文档网站。涵盖了技术、商业、艺术、学术等各个领域，构建了一座广博而深厚的知识库。\n\n\n来源：[体验碎周报第 153 期（2023.7.31）](https://www.ftium4.com/ux-weekly-153.html)\n\n\n## 同步微信读书笔记\n\n\n> [https://notepal.randynamic.org/](https://notepal.randynamic.org/)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/6c95eb81-ba52-4ed6-8359-66acd87bdda0/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=288c1871a62bad8c677967d95a01e0094f94f891a7e2fcb86e6bb17d89393b0a&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一款 chrome 浏览器插件，可以将微信读书的读书笔记一键同步笔记到各个笔记软件。对我这个微信读书的用户还是挺有用的。作者也介绍了这款插件的开发过程，并且表示三天就获得 1000 元的收益。[https://lutaonan.com/blog/my-extension-sold-1k-yuan/](https://lutaonan.com/blog/my-extension-sold-1k-yuan/)\n\n\n来源：[体验碎周报第 154 期（2023.8.7）](https://www.ftium4.com/ux-weekly-154.html)\n\n\n## 很酷的网络检查工具\n\n\n> [https://web-check.xyz/](https://web-check.xyz/)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/411c7fa6-fcdf-42ae-b0e8-d5250d9e6d03/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=a9db9a03994dd48233ead6a1b939c6d62f0b425270979d6cca8e77f44e2acb1b&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一个超级酷的网络检查工具「Web-Check」，可以用很 Hacker 的方式查看到一个网站几乎所有信息，如 IP 信息、SSL、DNS记录、Cookies、域名信息、搜索爬行规则、服务器位置、重定向记录、开放端口、路由跟踪、DNS安全扩展、网站性能、关联主机名等。\n\n\n## 吵架对线培练员\n\n\n> [https://aibang.run/chat/sb](https://aibang.run/chat/sb)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7d7875ef-9550-4223-9ce7-9b0cf49ec050/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=bb2e6663e8e26095a0497dcf380c3d946210aad521d31823a58b97f269cb3d6e&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n如果你是一个性格温的人，遇到不快的事情了想学习学习如何成为一个祖安选手，这个 AI 可以帮帮你，火力强劲，慎用…\n\n\n# 生活杂谈\n\n\n## 如何用英语思维思考\n\n\n> [https://www.youtube.com/watch?v=SJOnhWiJArM](https://www.youtube.com/watch?v=SJOnhWiJArM)\n\n\n学习英语的过程中一般会有一层翻译思维，也即先将自己想到的中文在脑袋里先翻译成英文再去思考，而非直接用英语去思考。Youtube 这个视频「如何用英语思考|不再需要翻译」讲述了6 个转变思维，使用英文思考的思路。B 站链接：[https://www.bilibili.com/video/BV1mu411V7y8](https://www.bilibili.com/video/BV1mu411V7y8)\n\n- Name objects around. 用英语描述周围，需要注意发音。\n- Thinking in simple sentences. 用简单的句子表达自己，I'm ..\n- Have small conversiontions with yourself in English. 与自己进行英语对话，每天坚持几分钟。30天可以见证进步\n- Change one of your everyday life things to English. 将每天日常的一项事务变成英文。日记、微博、英文新闻，晨思\n- Keep track so you're doing it every day. 保持跟踪，确保每天在做\n- Recap your day in English. 用英语回顾每一天\n",
      "properties": {
        "date": "2023-08-13",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2308-w2",
        "tags": [],
        "summary": "周末和亲戚朋友们去了峨眉的七里坪禅道，也许正是成都最热的时候，普通的周末也有很多人，不过和亲近的人一起游玩下还是很愉悦的。这里离峨眉索道不远，不过知道的人应该还不多，想避开攀登峨眉的大部队在附近登山打卡一下的话可以在这里试试。",
        "title": "数字溪流2308-W2",
        "status": "Published",
        "urlname": "b658d5ed-817b-44f3-9443-839161b38ad3",
        "updated": "2023-08-28 02:11:00"
      },
      "catalog": [
        {
          "title": "2023-08-13",
          "doc_id": "b658d5ed-817b-44f3-9443-839161b38ad3"
        }
      ],
      "body": "",
      "realName": "数字溪流2308-W2",
      "relativePath": "/2023-08-13/数字溪流2308-W2.md"
    },
    {
      "id": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5",
      "doc_id": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5",
      "title": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5",
      "updated": 1690733760000,
      "body_original": "\n# 整点薯条\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/74718d04-0c1e-4e9f-abd0-eba81c5fd246/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230730224558.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=302248c3b894ccbe0858bf463cdbd0caccf8d3db18d75a1c21b31609a8d16b91&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n拍摄于塔子山公园的鸟语林，原来塔子山公园上还隐藏着这么一个小小的鸟类主题动物园，之前逛过几次都没发现，还是在大众点评上看到才无意发现。这只海鸥呆呆的眼神立马让我想起了去码头整点薯条这个梗，真是很适合这呆头呆脑的形象，哈哈。动物园里除了鹦鹉，海鸥，天鹅这些常见的鸟类也有羊驼，梅花鹿，绵羊甚至猪，妥妥的大杂烩。\n\n\n# 技术见闻\n\n\n## MySQL uuid及其相关的一些简单性能测试\n\n\n> [https://www.cnblogs.com/eryuan/p/17448786.html](https://www.cnblogs.com/eryuan/p/17448786.html)\n\n\n很多资料都在说 UUID 不适合作为 MySQL 的主键，容易造成页分裂，那么以 UUID 作为主键时究竟有多大的影响，这篇博文中对此做了进一步的分析，对原因可以有更深入的了解。\n\n\n## **MIFARE Classic Tool (MCT)**\n\n\n> [https://github.com/ikarus23/MifareClassicTool](https://github.com/ikarus23/MifareClassicTool)\n\n\n一个用于对MIFARE Classic RFID标签进行读取、写入、分析等操作的Android NFC应用程序。网上有很多 NFC 读写卡机出售，用于读取或者复制 IC 卡的信息。比如苹果手机没有开放 NFC 门卡功能，可以购买一张几块的 NFC 小卡，复制门卡到小卡里贴到苹果手机后这样曲线让苹果手机获得刷门禁的功能，如果门禁卡没有加密而且手边又正好有台安卓手机的话，的话这款开源软件可以省下读写卡机的钱。\n\n\n## wallpaper-box\n\n\n> [https://github.com/wangrongding/wallpaper-box](https://github.com/wangrongding/wallpaper-box)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/544e12ea-f74d-4853-83a3-9bca7b4c7f5b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=0bda3c15031f9e65e18a1c60b3576db700e41a7632ab8b7794521d41a7aca669&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一款 MacOS 的一个桌面壁纸客户端，可以设置静态 / 动态壁纸，同时集成了集成了 RunCat 的功能。以前主要用 Windows 时一直在用 PyBingWallpaper 来每日切换 Bing 的壁纸，这款 macOS 软件也可以获得类似体验。\n\n\n## 经济数据跟踪\n\n\n> [https://www.macroview.club/](https://www.macroview.club/)\n\n\n可以看到当下一些主要的经济数据，比如中国的 GDP 图表，还有美国及欧洲的一些主要经济指标，适合对经济感兴趣的同学收藏。\n\n\n## 漂亮简洁的浏览器新标签页\n\n\n> [https://tabliss.io/](https://tabliss.io/)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/25c4771d-e819-46c9-a82e-b7dc8488cafc/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=1c4ec835b6b5ed99b9f4c8e581a2b92f63a732dd293d47065083e9cd0dc5eac9&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一款适用于 Chrome 的新标签页插件，主打漂亮简洁而且免费，个人已安装使用了一段时间，浏览器作为主打的日常软件，这样一款软件可以让每天一些些不一样的风景。\n\n\n## AI 二选一\n\n\n> [https://eitherchoice.com/](https://eitherchoice.com/)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/af662d33-139f-4a37-b52d-55393ebcb063/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230730224601.jpg?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=3ecf40f9079e300ff8e20bb207d25e1484f19ccecb11a707f6721d24b4f2e2b0&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n当你对两个选择犹豫不决的时候，可以试试将这道难题抛给这个 AI，看看 AI 是如何选择的。试了一下不能说是毫无道理，只能是强行胡说八道，可以用来娱乐一下，哈哈。\n\n\n## halo\n\n\n> [https://github.com/halo-dev/halo](https://github.com/halo-dev/halo)\n\n\n一款强大易用的开源建站工具，基于 Java + Vue 构建，看起来上手很容易，部署和操作的文档都挺丰富的，主题也挺丰富。适合用来搭建 CMS 系统或者博客，第一次听说这款工具是因为听说有很多二刺螈小伙伴在用，专门来看了下的确有很多相关主题和插件 ( •̀ ω •́ )y。\n\n\n## gitstars\n\n\n> [https://github.com/cfour-hi/gitstars](https://github.com/cfour-hi/gitstars)\n\n\n一个 Github Star 项目管理平台，很多小伙伴应该和我一样在 Github 上通过 star 来收藏自己需要或是喜爱的项目。不过 Github 的 star 功能比较简单，随着 Starred Repositories 增长，在需要使用到某个项目时难免记不清叫什么，这款软件提供了更强大的管理功能。可以直接在线使用，不过初步试了下还有些肉眼可见的 Bug，期待作者进一步完善。\n\n\n# 生活杂谈\n\n\n## 每一本书都会改变你\n\n\n我们读过很多书，也经常听到很多鼓励阅读的言论，Quora 上有人提问：我读了许多书但是几乎全忘了。阅读的意义是什么呢？有人如此回答，很有感触：\n\n\n> 每本书都会留下痕迹。即使它没有留在你有意识的记忆中。就像发生在你身上的每一件事和你遇到的每一个人一样。\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/1744ce6c-d513-4899-a1f6-c251349155aa/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=e3134a07003ad0aaa259305b7885a2d3c5e5f0d98346a09f3b5235a263bf620c&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2d0ebcb4-df6c-44d3-8f22-135a345982d3/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=96ba000ef54df58f79998cbc0bc7c461be2b6889d50be113a82eb5efcd447722&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n## 咒术回战SE02-28\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/377be053-8b13-49b2-add8-192c2c481b98/vlcsnap-2023-07-30-23h25m42s547.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080931Z&X-Amz-Expires=3600&X-Amz-Signature=94f3ab4798f52c7836c8eb119c0835e6e4e2cd703d8ac7afc3415a897254c2d4&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n本周开追咒术回战第二季，以第一季的前传剧情开始呈现。第二季的集数是接着第一季的 24 开始更新，28 相当于是新一季的第 4 集，由于没有在国内上线，热度也小了很多。咒术回战的剧情比起鬼灭之刃要压抑很多，设定上感觉也复杂很多，不过就冲着依然吊炸天的 5t5，依然值得追下去。\n\n",
      "properties": {
        "date": "2023-07-30",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2307-w5",
        "tags": [],
        "summary": "拍摄于塔子山公园的鸟语林，原来塔子山公园上还隐藏着这么一个小小的鸟类主题动物园，之前逛过几次都没发现，还是在大众点评上看到才无意发现。这只海鸥呆呆的眼神立马让我想起了去码头整点薯条这个梗，真是很适合这呆头呆脑的形象，哈哈。动物园里除了鹦鹉，海鸥，天鹅这些常见的鸟类也有羊驼，梅花鹿，绵羊甚至猪，妥妥的大杂烩。",
        "title": "数字溪流2307-W5",
        "status": "Published",
        "urlname": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5",
        "updated": "2023-07-31 00:16:00"
      },
      "catalog": [
        {
          "title": "2023-07-30",
          "doc_id": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5"
        }
      ],
      "body": "",
      "realName": "数字溪流2307-W5",
      "relativePath": "/2023-07-30/数字溪流2307-W5.md"
    },
    {
      "id": "396270c6-a77e-4a97-992e-e273e0a24892",
      "doc_id": "396270c6-a77e-4a97-992e-e273e0a24892",
      "title": "396270c6-a77e-4a97-992e-e273e0a24892",
      "updated": 1691749800000,
      "body_original": "\n曾经在 [一周随笔20230226](https://darkreunion.tech/article/one-week-essay-20230226) 这篇博文中描述了下我心目中理想的 Blog 系统，吐槽了下写博文时的一些很不爽的地方，也一直在寻找更好的 Blog 系统。直到无意间发现了 [NotionNext](https://github.com/tangly1024/NotionNext)，一下就有了哎哟不错喔，这应该就是我想要的博客系统这种感觉。甚至马上就想开始动手迁移我的博客，没有当初从 Hexo 迁移到 Hugo 的时那种纠结。\n\n\n在写下这篇文章时，这个博客站已经完成了从 Hugo 到 [NotionNext](https://github.com/tangly1024/NotionNext) 的迁移，更新好了各种配置，稳定运行了一段时间了，可以开始安心的写这篇文章啦。\n\n\n吸引我的几点：\n\n- 基于 notion，在 notion 中写作体验很好, 有效降低了写作的阻力\n- 主题漂亮，NotionNext 的几个主题风格不错, 颜值也是一种生产力\n- 定制化方便，菜单、网站公共这些直接在 notion 中即可编辑\n- 部署方便，通过 vercel 直接一件部署成本，没啥运维成本\n- 开源免费，而且作者更新的很勤快，之前也看过几款基于 notion 的建站产品不过都要付费\n\n当然，NotionNext 也还不算完美，我觉得还有几个痛点：\n\n\n迁移麻烦，如果之前有使用其他博客系统的话，要迁移到 NotionNext 得看 notion 是否支持。虽然 notion 也有了对应的 API，但是感觉支持的还不多，我是写了一个 Python 脚本来导入，通过 notion 的 token_v2 调用的 web api，但是 web api 经常在变化，Python 的库已经不能直接调用了，还有手动更改下库的代码才能成功导入，而且部分文章在导入后出现了问题，需要手动再调整。\n\n\n不能备份到 Git，虽然 notion 也是一个不小的平台了，数据应该还算有保障，但是毕竟数据没在自己手上，如果能支持自动备份文章到 Git 的话会安心不少，不过搜了下 Github 上已经有了不少备份 notion 的工具，应该有路径，需要后面再研究下。\n\n\n还有就是 NotionNext 还比较新，时不时有些小 bug，很多配置的更新还有靠修改源代码。目前看起来这个项目主要还是作者一个人在维护，贡献者不多，虽然作者很勤快，但是感觉开源软件要有长久的生命力的话还是需要一个活跃的社区。\n\n\n这里简单记录下我的迁移脚本，用于将我的 hugo 迁移到 NotionNext，hugo 中的文件结构可以很自由，主要记录下思路。\n\n\n用到的库：\n\n- pyyaml\n- python-dateutil\n- notion\n- md2notion\n\n```python\nimport glob\nimport io\nimport json\nimport os\n\nimport yaml\nfrom dateutil.parser import parse\nfrom md2notion.upload import upload\nfrom notion.client import NotionClient\nfrom notion.collection import NotionDate\n\n\ndef read_post_file(post_path):\n    pathname = os.path.join(post_path, \"**/*.md\")\n\n    index = 0\n    bloglist = []\n    for fp in glob.iglob(pathname, recursive=True):\n        with open(fp, \"r\", encoding=\"utf-8\") as mdFile:\n            mdStr = mdFile.read()\n            mdStr = mdStr.strip(\"-\").strip()\n            mdChunks = mdStr.split(\"---\", 1)\n            header = yaml.safe_load(mdChunks[0])\n\n            slug = header[\"slug\"].lower()\n            content = mdChunks[1].lstrip(\"\\n\")\n            summary = header.get(\"description\")\n            des_list = content.split(\"<!-- more -->\")\n            if len(des_list) > 1 and summary is None:\n                summary = des_list[0].strip(\"\\n\")\n\n            date = header.get(\"date\")\n            if isinstance(date, str):\n                date = parse(date)\n\n            content = content.replace(\"<!-- more -->\", \"\", 1)\n\n            page = {\n                \"filepath\": fp,\n                \"title\": header[\"title\"],\n                \"slug\": slug,\n                \"category\": header.get(\"categories\"),\n                \"tags\": header.get(\"tags\", []),\n                \"summary\": summary,\n                # \"date\": date.strftime(\"%Y-%m-%d %H:%M:%S\"),\n                \"date\": date.date(),\n                \"content\": content,\n            }\n\n        bloglist.append(page)\n        index += 1\n\n    bloglist.sort(key=lambda x: x[\"date\"], reverse=True)\n    return bloglist\n\n\ndef upload_notion(bloglist: list):\n    token_v2 = \"\"\n    collection_view_id = \"https://www.notion.so/xxxxx\"\n\n    client = NotionClient(\n        token_v2\n    )\n    cv = client.get_collection_view(\n        collection_view_id\n    )\n\n    with open('record.json', 'r') as f:\n        record = json.load(f)\n\n    index = 1\n    for page in bloglist:\n        if page[\"slug\"] in record[\"imported\"]:\n            print(\"skip article\", page.get(\"title\"))\n            index += 1\n            continue\n\n        print(f\"{index}/{len(bloglist)}:Uploading {page.get('filepath')}\")\n\n        row = cv.collection.add_row()\n        row.type = \"Post\"\n        row.date = NotionDate(page[\"date\"])\n        row.title = page[\"title\"]\n        row.slug = page[\"slug\"]\n        row.category = page[\"category\"][0]\n        if page[\"tags\"]:\n            row.tags = page[\"tags\"]\n        row.status = \"Draft\"\n        if page.get(\"summary\"):\n            row.summary = page[\"summary\"]\n\n        mdFile = io.StringIO(page.get(\"content\"))\n        mdFile.__dict__[\"name\"] = page[\"filepath\"]\n\n        try:\n            upload(mdFile, row)\n        except Exception as e:\n            print(e)\n            with open('record.json', 'w') as f:\n                json.dump(record, f, ensure_ascii=False, indent=4)\n            exit(1)\n\n        index += 1\n        record[\"imported\"].append(page[\"slug\"])\n\n\nif __name__ == \"__main__\":\n    bloglist = read_post_file(\"content/posts\")\n    upload_notion(bloglist)\n```\n\n\nnotion 库中代码存在问题需要手动改下：\n\n\nnotion/client.py 313 行和 notion/store.py 280 行的 limit 改为 100。\n\n\n相关 Issue：\n\n\n[https://github.com/NarekA/git-notion/issues/1](https://github.com/NarekA/git-notion/issues/1)\n\n\n[https://github.com/knightjoel/notion-py/commit/521013095e96a05b80edd3e007c931c78a55ce6b](https://github.com/knightjoel/notion-py/commit/521013095e96a05b80edd3e007c931c78a55ce6b)\n\n\n最后再碎碎念几下：\n\n\n有搜索到这篇日本一位作者的文章 [https://dev.classmethod.jp/articles/output-github-repos-release-note-to-notion-db/](https://dev.classmethod.jp/articles/output-github-repos-release-note-to-notion-db/)，有尝试通过 notion 的开放 API 来导入，不过一直没成功，放弃..\n\n\n也有考虑过使用 [思源笔记](https://github.com/siyuan-note/siyuan) 配合这个发布 [插件](https://github.com/terwer/sy-post-publisher) 来作为博客解决方案，感觉也是不错的选择，而且可以更方便，不过是思源笔记开源版本没有移动客户端，作为博客记录还没有付费的动力，看到了 NotionNext 后也放弃了，可以作为一个备选方案。\n\n",
      "properties": {
        "date": "2023-08-11",
        "type": "Post",
        "category": "博客记录",
        "slug": " migrate-blog-to-notionnext-from-hugo",
        "tags": [
          "NotionNext",
          "hugo",
          "notion",
          "blog"
        ],
        "summary": "曾经在 一周随笔20230226 这篇博文中描述了下我心目中理想的 Blog 系统，吐槽了下写博文时的一些很不爽的地方，也一直在寻找更好的 Blog 系统。直到无意间发现了 NotionNext，一下就有了哎哟不错喔，这应该就是我想要的博客系统这种感觉。甚至马上就想开始动手迁移我的博客，没有当初从 Hexo 迁移到 Hugo 的时那种纠结。",
        "title": "从 Hugo 迁移到 NotionNext",
        "status": "Published",
        "urlname": "396270c6-a77e-4a97-992e-e273e0a24892",
        "updated": "2023-08-11 18:30:00"
      },
      "catalog": [
        {
          "title": "2023-08-11",
          "doc_id": "396270c6-a77e-4a97-992e-e273e0a24892"
        }
      ],
      "body": "",
      "realName": "从 Hugo 迁移到 NotionNext",
      "relativePath": "/2023-08-11/从 Hugo 迁移到 NotionNext.md"
    },
    {
      "id": "0178db9b-0fd8-41ed-b27d-0015ae286e79",
      "doc_id": "0178db9b-0fd8-41ed-b27d-0015ae286e79",
      "title": "0178db9b-0fd8-41ed-b27d-0015ae286e79",
      "updated": 1690298040000,
      "body_original": "\n当我们在自己的服务器上使用 Docker 部署了一些有用的容器镜像时，一般可以使用 [watchtower](https://github.com/containrrr/watchtower) 来自动更新我们的镜像版本。但是如果使用的是 K8S，有没有工具可以像 watchtower 一样来自动更新 K8S 中的容器镜像版本呢，最近发现了 [Keel](https://github.com/keel-hq/keel) 这款工具可以做同样的事。\n\n\n# 部署\n\n\nKeel 的部署可以参考官方文档：[https://keel.sh/](https://keel.sh/)\n\n\n不过官方文档中，Deploying with kubectl 的方式使用的 `sunstone.dev` 似乎已经停止维护，通过文档介绍的方式已无法获取到 YAML 文件，使用此方式需要自行在 Github 仓库中获取部署需要的 YAML 并替换相关变量。\n\n\n我使用的是 Helm 的方式来部署，主要步骤：\n\n\n**添加 chart repo**\n\n\n```bash\nhelm repo add keel https://charts.keel.sh \nhelm repo update\n```\n\n\n**部署 Keel**\n\n\n```bash\nhelm upgrade --install keel --namespace=keel --create-namespace keel/keel -f values.yaml\n```\n\n\n**values.yaml 示例**\n\n\n```yaml\n# 关闭 Helm Provider \nhelmProvider:\n  enabled: false\n\n# 开启 Dashboard\nbasicauth:\n  enabled: true\n  user: \"admin\"\n  password: \"admin321\"\n\n# 开启 EMail 通知\nmail:\n  enabled: true\n  from: \"email@mail.com\"\n  to: \"email@mail.com\"\n  smtp:\n    server: \"smtp.mail.com\"\n    user: \"email@mail.com\"\n\t\tpass: \"password\"\n```\n\n\n这里由于不需要使用 Keel 更新 Helm 的能力，所以关闭了默认的 `HelmProvider` 。通过配置 `basicauth` 可以打开 Keel 的 Dashboard。`mail` 配置项可以在容器更新时通过邮件发送通知。\n\n\n# 使用\n\n\n在上一步部署的时候配置了 `basicauth`，通过建立对应的 nodeport service 或其他对应的方式暴露 Keel 的 9300 端口，即可访问到 Keel 的 Dashboard，首页显示了 K8S 中部署的各类资源，可以在这里配置需要自动更新的资源：\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7f9ea798-4461-4c4e-b60d-074eb80bd99a/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080934Z&X-Amz-Expires=3600&X-Amz-Signature=1f1c0461051430d945c43516b340da4587c4c8dd424a4fc15541fdf8b1a740c3&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n点击每行最后的开关，Keel 即可开始监控这个资源的容器镜像，开启自动更新。\n\n\n## 更新策略\n\n\nKeel 支持配置的不同的更新策略：\n\n- **all**: update whenever there is a version bump or a new prerelease created (ie: `1.0.0` -> `1.0.1-rc1`)\n- **major**: update major & minor & patch versions\n- **minor**: update only minor & patch versions (ignores major)\n- **patch**: update only patch versions (ignores minor and major versions)\n- **force**: force update even if tag is not semver, ie: `latest`, optional label: **keel.sh/match-tag=true** which will enforce that only the same tag will trigger force update.\n- **glob**: use wildcards to match versions, example:\n\n当容器镜像版本遵循 semver 版本编号进行发布时，可以配置 all 到 patch 这一类策略来灵活的更新版本，其他如使用 `latest` 的镜像可以使用 force 或者 glob 这一类策略来强制更新或匹配特定的版本。\n\n\n## 触发器\n\n\nKeel 通过各类 webhook 和 poll 的方式来检查镜像的版本，webhook 的方式可以在容器镜像仓库或者对应的代码仓库更新时主动通知 Keel 来更新镜像，不过我需要使用 Keel 来更新的镜像一般都是第三方的，没有配置 webhook 的权限，需要使用 poll 轮询的方式来检查容器更新。\n\n\n在 Keel 的 Dashboard 页面打开资源的自动更新时，poll 也是此资源的更新检查默认方式。\n\n\n当使用 poll 触发器时，还可以通过配置资源的 `annotations` 中的 `keel.sh/pollSchedule` 配置项来指定版本的检查时间，支持 cron 格式以及如下的表达式\n\n\n| Entry                  | Description                                | Equivalent To |\n| ---------------------- | ------------------------------------------ | ------------- |\n| @yearly (or @annually) | Run once a year, midnight, Jan. 1st        | `0 0 0 1 1 *` |\n| @monthly               | Run once a month, midnight, first of month | `0 0 0 1 * *` |\n| @weekly                | Run once a week, midnight on Sunday        | `0 0 0 * * 0` |\n| @daily (or @midnight)  | Run once a day, midnight                   | `0 0 0 * * *` |\n| @hourly                | Run once an hour, beginning of hour        | `0 0 * * * *` |\n\n\n# 更新示例\n\n\n下面演示下如何使用 Keel 来更新我部署在 K8S 中的自动追番工具 AutoBangumi。\n\n\n部署完 Keel 后，访问服务器的 9300 端口，输入部署中设置的用户名和密码，打开 Keel 的设置界面，在首页中可以看到我部署的 autobangumi 服务，打开行尾的更新开关，autobangumi 会出现 `keel.sh/policy: all` `keel.sh/trigger: poll` `keel.sh/pollSchedule: @every 1m` 表示 Keel 每隔 1 分钟会通过轮询一次 autobangumi 镜像的版本是否有更新，当有新版本更新时，全部都会触发更新。\n\n\nautobangumi 并不会经常发布更新，我期望只在每周检查一次更新即可，可以通过 ：`kubectl -n namespace edit deploy autobangumi` 的方式来更改 autobangumi 的 annotations 部分，将 `keel.sh/pollSchedule` 的值改为 @weekly 即可。这样 Keel 只会在每周天检查镜像是否有更新。\n\n\n配置完成后如下图所示：\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/c4da9536-0113-44a4-90a8-0a7aa2f7a04f/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080934Z&X-Amz-Expires=3600&X-Amz-Signature=684ea5720b86fdcd0f9c10ed9067e2492f888ffd3a820a86e9f4b8c0ae675a31&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n当 autobangumi 的作者发布了新的镜像版本后，Keel 便会自动更新此镜像，我们配置的邮箱也可以收 到通知提醒了，下图是最近一次 autobangumi 从 3.0.10 升级到 3.0.11 的邮件记录：\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/8b9b5672-84b4-47cd-a4ee-7c4cef6e971b/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T080934Z&X-Amz-Expires=3600&X-Amz-Signature=08a8ee857742b865319229ba146eebe8284610c9c99e02b81d751a54a087413b&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n# 后记\n\n\n目前 Keel 的更新不太活跃，文档中存在很多已过时的内容或错误，像邮件通知这一类的说明甚至都没有在文档中说明，不看看代码的话都不知道有这个功能。在 [Is this project still active?](https://github.com/keel-hq/keel/issues/677) 这个 Issue 中作者也提及了目前没有太多时间投入到这个项目中，同时有人提到了 [ArgoCD](https://devopstales.github.io/kubernetes/argocd-image-updater/) 中类似的功能，不过看了下功能还是比较受限。相比于 [watchtower](https://github.com/containrrr/watchtower) 来说，可能 K8S 中这种需求还是比较小吧，毕竟 K8S 更多是是企业在用，更新镜像时都有对应 CI 来处理。但是总的来说，对于在 K8S 中部署了各种第三方镜像，存在需要更新这些软件版本的用户来说，目前 Keel 的功能已足够完善，可以很方便的解决问题，值得一试，有能力也可以提交 pull request 帮助这个项目更好。\n\n",
      "properties": {
        "date": "2023-07-23",
        "type": "Post",
        "category": "软件工具",
        "slug": "use-keel-auto-update-image-version-in-k8s",
        "tags": [
          "kubernetes",
          "Keel"
        ],
        "summary": "当我们在自己的服务器上使用 Docker 部署了一些有用的容器镜像时，一般可以使用 watchtower 来自动更新我们的镜像版本。但是如果使用的是 K8S，有没有工具可以像 watchtower 一样来自动更新 K8S 中的容器镜像版本呢，最近发现了 Keel 这款工具可以做同样的事。",
        "title": "使用 Keel 自动更新 K8S 中容器镜像",
        "status": "Published",
        "urlname": "0178db9b-0fd8-41ed-b27d-0015ae286e79",
        "updated": "2023-07-25 23:14:00"
      },
      "catalog": [
        {
          "title": "2023-07-23",
          "doc_id": "0178db9b-0fd8-41ed-b27d-0015ae286e79"
        }
      ],
      "body": "",
      "realName": "使用 Keel 自动更新 K8S 中容器镜像",
      "relativePath": "/2023-07-23/使用 Keel 自动更新 K8S 中容器镜像.md"
    },
    {
      "id": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868",
      "doc_id": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868",
      "title": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868",
      "updated": 1689935760000,
      "body_original": "\nGo 1.5 以后（截止Golang v1.12）采用了**非分代**、**非紧缩**、**写屏障**、**三色标记**的原理进行垃圾回收。\n\n\n## Golang GC 原理\n\n- 非分代：不像Java那样分为年轻代和年老代。\n- 非紧缩：在垃圾回收之后不会进行内存整理以清除内存碎片。\n- 写屏障：在并发标记的过程中，如果应用程序（mutator）修改了对象图，就可能出现标记遗漏的可能，写屏障就是为了处理标记遗漏的问题。\n- 三色：将GC中的对象按照搜索的情况分成三种：\n1. 黑色: 对象在这次GC中已标记,且这个对象包含的子对象也已标记\n2. 灰色: 对象在这次GC中已标记, 但这个对象包含的子对象未标记\n3. 白色: 对象在这次GC中未标记\n\n### GC 过程\n\n\n### Marking setup\n\n\n为了打开写屏障，必须停止每个goroutine，让垃圾收集器观察并等待每个goroutine进行函数调用， 等待函数调用是为了保证goroutine停止时处于安全点。\n\n\n```go\n// 如果 goroutine4 处于如下循环中，运行时间取决于 slice numbers 的大小\nfunc add(numbers []int) int {\n    var v int\n    for _, n := range numbers {\n             v += n\n     }\n     return v\n}\n```\n\n\n下面的代码中，由于`for{}`循环所在的goroutine 永远不会中断，导致始终无法进入STW阶段，资源浪费；Go 1.14 之后，此类goroutine 能被异步抢占，使得进入STW的时间不会超过抢占信号触发的周期，程序也不会因为仅仅等待一个goroutine的停止而停顿在进入STW之前的操作上。\n\n\n```go\nfunc main() {\n    go func() {\n        for {\n        }\n    }()\n    time.Sleep(time.Milliecond)\n    runtime.GC()\n    println(\"done\")\n}\n```\n\n\n### Marking\n\n\n一旦写屏障打开，垃圾收集器就开始标记阶段，垃圾收集器所做的第一件事是占用25%CPU。\n\n\n标记阶段需要标记在堆内存中仍然在使用中的值。首先检查所有现goroutine的堆栈，以找到堆内存的根指针。然后收集器必须从那些根指针遍历堆内存图，标记可以回收的内存。\n\n\n当存在新的内存分配时，会暂停分配内存过快的那些 goroutine，并将其转去执行一些辅助标记（Mark Assist）的工作，从而达到放缓继续分配、辅助 GC 的标记工作的目的。\n\n\n### Mark终止\n\n\n关闭写屏障，执行各种清理任务（STW - optional）\n\n\n### Sweep (清理)\n\n\n清理阶段用于回收标记阶段中标记出来的可回收内存。当应用程序goroutine尝试在堆内存中分配新内存时，会触发该操作，清理导致的延迟和吞吐量降低被分散到每次内存分配时。\n\n\n| 阶段               | 说明                           | 赋值器状态 |\n| ---------------- | ---------------------------- | ----- |\n| SweepTermination | 清扫终止阶段，为下一阶段的并发标记做准备工作，启动写屏障 | STW   |\n| Mark             | 扫描标记阶段，与赋值器并发执行，写屏障开启        | 并发    |\n| MarkTermination  | 标记终止阶段，保证一个周期内标记任务完成，停止写屏障   | STW   |\n| GCoff            | 内存清扫阶段，将需要回收的内存归还到堆中，写屏障关闭   | 并发    |\n| GCoff            | 内存归还阶段，将需要回收的内存归还给操作系统，写屏障关闭 | 并发    |\n\n\n**清除阶段出现新对象：**\n\n\n清除阶段是扫描整个堆内存，可以知道当前清除到什么位置，创建的新对象判定下，如果新对象的指针位置已经被扫描过了，那么就不用作任何操作，不会被误清除，如果在当前扫描的位置的后面，把该对象的颜色标记为黑色，这样就不会被误清除了\n\n\n### 触发时机\n\n- gcTriggerHeap: 当前分配的内存达到一定值（动态计算）就触发GC\n- gcTriggerTime: 当一定时间（2分钟）没有执行过GC就触发GC\n- gcTriggerCycle: 要求启动新一轮的GC, 已启动则跳过, 手动触发GC的runtime.GC()会使用这个条件\n\n### 三色标记原理\n\n1. 初始状态下所有对象都是白色的。\n2. 接着开始扫描根对象; 将根对象引用的对象设为为灰色对象，接下来就开始分析灰色对象，没有引用其他对象的转入黑色，引用了其他对象的则转入黑色的同时还需要将引用的对象转为灰色，进行接下来的分析。\n3. 扫描灰色对象，直至没有引用其他对象，将灰色对象转入黑色。标记过程结束\n4. 最终，黑色的对象会被保留下来，白色对象会被回收掉。\n\n## 为什么Golang没有实现分代和非紧缩\n\n\n译自 Google 论坛([golang-nuts](https://groups.google.com/forum/#!msg/golang-nuts/KJiyv2mV2pU/wdBUH1mHCAAJ)) Ian Lance Taylor 的回复:\n\n\n忽略细节, 紧凑(compacting) GC 的基本优点是:\n\n- 避免碎片, 以及\n- 允许使用简单而有效的 bump allocator 内存分配器\n\n但是，现代的内存分配算法， 像 Go 运行时使用的基于 tcmalloc 的方案基本上没有碎片问题。bump allocator 对于一个单线程程序是简单有效的，对于 Go 这样的多线程程序则需要锁。一般来说，可以使用一组线程预分配缓存的线程来分配内存提升效率，而在这一点上已经失去了 bump allocator 的优势。因此我断言，在一般情况下，对于多线程程序使用压缩内存分配器并没有什么真正的优势。我并不是说使用压缩分配器有什么问题，我只是说它不会比非压缩分配器带来任何大的优势。\n\n\n现在我们来考虑一下分代 GC。分代 GC 的关键依赖于世代的假设：分配在一个程序中的大部分值很快变得不会用到，所以分代 GC 有一个优势就是可以花更多的时间查看最近分配的对象。这里 Go 不同于许多垃圾收集语言，因为许多对象是直接在程序栈(stack)上分配的。Go 编译器使用逃逸分析(escape analysis)来查找那些在编译时生命周期就已知的对象，将它们分配到栈(stack)而不是垃圾收集的内存中。 所以一般来说，在 Go 中，与其他语言相比，有很大比例的分代 GC 要找的很快不会用到的(quickly-unused)值不会分配在 GC 内存的首要位置。所以分代 GC 能给 Go 带来的优势相对于其他语言要小。\n\n\n更微妙的是，大多数世代 GC 实现的隐含意义是减少垃圾收集带来的程序暂停的时间。暂停期间只看最年轻的一代，会让暂停时间很短。然而，Go 使用了一个并发垃圾收集器，并且在 Go 中程序暂停时间与年轻代或者任意代的大小无关。Go 基本上假设，在多线程程序中，通过在不同的核上并行运行 GC，不是为了最小化 GC 时间去暂停导致程序运行更长的时间, 而是总体上花更多的总 CPU 时间在 GC 上。\n\n\n尽管如此，分代 GC 可能仍然可以为 Go 带来显著的价值，即减少并行 GC 时的工作量. 这是一个需要测试的假设. Go 当前的 GC 工作实际上正在密切关注一个相关但不同的假设：Go 程序可能倾向于按请求分配内存。这里有一个[描述](https://docs.google.com/document/d/1gCsFxXamW8RRvOe5hECz98Ftk-tcRRJcDFANj2VwCB0/view)。这项工作正在进行中，现实情况是否有利还有待观察。\n\n\n**总结**\n\n- 对象整理的优势是解决内存碎片问题以及“允许”使用顺序内存分配器。但 Go 运行时的分配算法基于tcmalloc，基本上没有碎片问题。 并且顺序内存分配器在多线程的场景下并不适用。Go 使用的是基于tcmalloc的现代内存分配算法，对对象进行整理不会带来实质性的性能提升。\n- 分代GC依赖分代假设，即GC将主要的回收目标放在新创建的对象上（存活时间短，更倾向于被回收），而非频繁检查所有对象。\n- Go 的编译器会通过逃逸分析将大部分新生对象存储在栈上（栈直接被回收），只有那些需要长期存在的对象才会被分配到需要进行垃圾回收的堆中。也就是说，分代GC回收的那些存活时间短的对象在 Go 中是直接被分配到栈上，当goroutine死亡后栈也会被直接回收，不需要GC的参与，进而分代假设并没有带来直接优势。\n\n## 参考\n\n- [https://liangyaopei.github.io/2021/01/02/golang-gc-intro/](https://liangyaopei.github.io/2021/01/02/golang-gc-intro/)\n",
      "properties": {
        "date": "2021-12-08",
        "type": "Post",
        "category": "Golang",
        "slug": "golang-gc-theory",
        "tags": [
          "Golang GC"
        ],
        "summary": "Go 1.5 以后（截止Golang v1.12）采用了非分代、非紧缩、写屏障、三色标记的原理进行垃圾回收。",
        "title": "Golang GC 原理",
        "status": "Published",
        "urlname": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868",
        "updated": "2023-07-21 18:36:00"
      },
      "catalog": [
        {
          "title": "2021-12-08",
          "doc_id": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868"
        }
      ],
      "body": "",
      "realName": "Golang GC 原理",
      "relativePath": "/2021-12-08/Golang GC 原理.md"
    },
    {
      "id": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46",
      "doc_id": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46",
      "title": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46",
      "updated": 1689577920000,
      "body_original": "\n### 复制剪切\n\n- v：选择\n- y：复制\n- d：剪切\n- p：粘贴\n\n### 查找\n\n- /pattern<Enter>：向下查找pattern匹配字符串\n- ?pattern<Enter>：向上查找pattern匹配字符串\n- 使用了查找命令之后，使用如下两个键快速查找：\n- n：按照同一方向继续查找\n- N：按照反方向查找\n\n### 撤销/重做\n\n- u: 撤销上一个编辑操作\n- ctrl + r: 回退前一个命令\n- U: 行撤销，撤销所有在前一个编辑行上的操作\n\n### 多窗口编辑\n\n- sp <File>: 打开一个新窗口\n- Ctrl + w + 方向键: 窗口跳转, 使用方法为先按ctrl + w, 松开后再按下对应的方向键.\n",
      "properties": {
        "date": "2016-10-20",
        "type": "Post",
        "category": "Linux管理",
        "slug": "vi-skills",
        "tags": [],
        "title": "Vi使用技巧",
        "status": "Published",
        "urlname": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46",
        "updated": "2023-07-17 15:12:00"
      },
      "catalog": [
        {
          "title": "2016-10-20",
          "doc_id": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46"
        }
      ],
      "body": "",
      "realName": "Vi使用技巧",
      "relativePath": "/2016-10-20/Vi使用技巧.md"
    },
    {
      "id": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee",
      "doc_id": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee",
      "title": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee",
      "updated": 1689577980000,
      "body_original": "\n### 常用命令\n\n- lsmod: list module,将模块列表显示)，功能是打印出当前内核中已经安装的模块列表\n- insmod: install module，安装模块，功能是向当前内核中去安装一个模块，用法是insmod xxx.ko\n- modinfo: module information，模块信息，功能是打印出一个内核模块的自带信息。，用法是modinfo xxx.ko\n- rmmod: remove module，卸载模块，功能是从当前内核中卸载一个已经安装了的模块，用法是rmmod xxx(注意卸载模块时只需要输入模块名即可，不需加.ko后缀)\n- mknod: 创建一个节点\n- modprobe、depmod等\n\n### 常用宏\n\n- MODULE_LICENSE: 模块的许可证. 一般声明为GPL许可证, 而且最好不要少, 否则可能会出现莫名其妙的错误(譬如一些明显存在的函数提升找不到).\n- MODULE_AUTHOR: 声明模块作者, 可通过modinfo中查看\n- MODULE_DESCRIPTION: 模块描述, 可通过modinfo中查看\n- MODULE_ALIAS: 模块别名\n\n### 驱动函数修饰符\n\n- __init: 本质上是个宏定义，在内核源代码中就有#define __init xxxx. 这个__init的作用就是将被他修饰的函数放入.init.text段中去(本来默认情况下函数是被放入.text段中), 整个内核中的所有的这类函数都会被链接器链接放入.init.text段中，所以所有的内核模块的__init修饰的函数其实是被统一放在一起的。内核启动时统一会加载.init.text段中的这些模块安装函数，加载完后就会把这个段给释放掉以节省内存\n- __exit: 类似于__init, 将函数链接进指定的段\n\n### 调试信息\n\n- printk(): 内核编程中使用printk()来打印信息. printk是linux内核源代码中自己封装出来的一个打印函数, 只能在内核源码范围内使用, 不能在应用编程中使用. 可设定0-7个打印级别, 一般默认为4, 通过dmesg命令来查看.\n- /proc/devices: 可查看到系统当前挂载的模块\n",
      "properties": {
        "date": "2016-11-02",
        "type": "Post",
        "category": "Linux编程",
        "slug": "linux-driven-development-basic-knowledge",
        "tags": [],
        "title": "Linux驱动开发基础知识",
        "status": "Published",
        "urlname": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee",
        "updated": "2023-07-17 15:13:00"
      },
      "catalog": [
        {
          "title": "2016-11-02",
          "doc_id": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee"
        }
      ],
      "body": "",
      "realName": "Linux驱动开发基础知识",
      "relativePath": "/2016-11-02/Linux驱动开发基础知识.md"
    },
    {
      "id": "11f072de-5ee2-401b-946c-59daf3f6a1ad",
      "doc_id": "11f072de-5ee2-401b-946c-59daf3f6a1ad",
      "title": "11f072de-5ee2-401b-946c-59daf3f6a1ad",
      "updated": 1689577920000,
      "body_original": "\n在公司用python写了个统计数据并通过xlsxwriter模块生成excel的小工具, 完成后使用py2exe转换成exe文件过程中遇到了些问题, 记录下.\n\n\n```python\nfrom distutils.core import setup\n\nimport sys\n\nsys.argv.append('py2exe')   # 直接执行python setup.py即可转换\n\nincludes = ['xlsxwriter']\noptions = {\n    'py2exe':\n        {\n            'compressed': 1,\n            'optimized': 2,\n            'includes': includes,\n            'dll_excludes': ['w9xpopen.dll'],   # 排除w9xpopen这个win9x才需要的dll文件\n            'bundle_files': 1                   # 将生成的调用文件打包进exe文件\n        }\n}\n\nsetup(\n    option=options,\n    zipfile=None,           # 将生成的library.zip打包进exe文件\n    console=['_init_.py']\n)\n\n```\n\n\n转换过程中会提示找不到xlsxwriter模块, 查了下是因为py2exe还不支持egg模块的打包, 解决办法是将Python27\\Lib\\site-packages目录下的xlsxwriter模块egg文件解压后复制到工程目录即可\n\n",
      "properties": {
        "date": "2016-11-08",
        "type": "Post",
        "category": "Python",
        "slug": "py2exe-conversion-parameters",
        "tags": [],
        "title": "py2exe转换参数",
        "status": "Published",
        "urlname": "11f072de-5ee2-401b-946c-59daf3f6a1ad",
        "updated": "2023-07-17 15:12:00"
      },
      "catalog": [
        {
          "title": "2016-11-08",
          "doc_id": "11f072de-5ee2-401b-946c-59daf3f6a1ad"
        }
      ],
      "body": "",
      "realName": "py2exe转换参数",
      "relativePath": "/2016-11-08/py2exe转换参数.md"
    },
    {
      "id": "f772582b-f800-4295-b10e-8f87ffa32d63",
      "doc_id": "f772582b-f800-4295-b10e-8f87ffa32d63",
      "title": "f772582b-f800-4295-b10e-8f87ffa32d63",
      "updated": 1689577920000,
      "body_original": "\n### 格式\n\n- 目标：最终要去生成的文件, 定格写，后面是冒号（冒号后面是依赖）\n- 依赖：用来生成目标的源材料\n- 命令：加工的方法，命令前面一定是Tab, make的过程就是使用命令将依赖加工成目标的过程\n\n### 工作原理\n\n1. 当我们执行make xx时，Makefile会自动执行xx这个目标下面的命令语句\n2. 当我们make xx时，是否执行是取决于依赖的，依赖如果成立就会执行命令，否则不执行\n3. 直接执行make与执行make 第一个目标的效果是一样的（第一个目标其实就是默认目标）\n\n### 命令前缀\n\n\n| 符号 | 含义                  |\n| -- | ------------------- |\n| 无  | 回显命令和结果, 出错时中断      |\n| -  | 回显命令和结果, 出错时继续执行    |\n| @  | 不回显命令, 仅显示结果, 出错时中断 |\n\n\n### 通配符%和自动推导\n\n- %代表一个或几个字符，例如%.o就代表所有以.o为结尾的文件。\n- 当Makefile需要一个文件时，他会将这个目标去按规则套用，一旦套用上某个规则说明，则Makefile会试图寻找这个规则中的依赖，如果能找到则会执行这个规则用依赖生成目标。\n\n### 自动变量\n\n- $@ 规则的目标文件名\n- $< 规则的依赖文件名\n- $^ 依赖的文件集合\n\n### 定义和使用变量\n\n\n无变量类型，直接定义使用。$变量名使用\n\n- = 赋值语句中变量在被解析时,取决于变量最后一次赋值的值\n- := 赋值语句中变量在被解析时,取决于变量最近一次赋值的值\n- ?= 前面没有赋值(定义)过时才赋值\n- += 给一个已经赋值的变量继续赋值,续接的内容和原来的内容会以空格隔开\n\n### 环境变量\n\n- 使用export导出的就是环境变量,一般使用大写,普通量使用小写. 环境变量回影响到其它Makefile文件,需谨慎使用. 环境变量在整个工程的Makefile中可以共享,普通变量只是当前本Makefile可用.\n\n### 特殊符号\n\n- @静默执行 不输出命令本身,仅输出命令本身\n",
      "properties": {
        "date": "2016-12-10",
        "type": "Post",
        "category": "Linux编程",
        "slug": "makefile-common-knowledge-points",
        "tags": [],
        "title": "Makefile常用知识点",
        "status": "Published",
        "urlname": "f772582b-f800-4295-b10e-8f87ffa32d63",
        "updated": "2023-07-17 15:12:00"
      },
      "catalog": [
        {
          "title": "2016-12-10",
          "doc_id": "f772582b-f800-4295-b10e-8f87ffa32d63"
        }
      ],
      "body": "",
      "realName": "Makefile常用知识点",
      "relativePath": "/2016-12-10/Makefile常用知识点.md"
    },
    {
      "id": "351382cf-57e4-4fd1-a59b-2e95dc07fd20",
      "doc_id": "351382cf-57e4-4fd1-a59b-2e95dc07fd20",
      "title": "351382cf-57e4-4fd1-a59b-2e95dc07fd20",
      "updated": 1689577860000,
      "body_original": "\n### 问题原因\n\n\n在使用tarfile模块解压一份Linux服务器上的打包文件时, 出现了错误提示: IOError: [Errno 22] invalid mode ('wb') or filename.\n经过检查, 发现是因为打包文件中有文件名存在':'符号, 而window下的文件名是不能有':'符号的因而报错.\n\n\n### 解决办法\n\n\n通过搜索, 找到了种解决办法, 可以将解压时含':'的地方转换成'_'等正常的符号\n\n\n```text\nextract = tarfile.open(file)\nfor f in extract:\n    # add other unsavory characters in the brackets\n    f.name = re.sub(r'[:]', '_', f.name)\nextract.extractall(path=new_path)\nextract.close()\n\n```\n\n\n来源\n\n\n> http://stackoverflow.com/questions/30287036/python-tarfile-extraction-error-ioerror-errno-22-invalid-mode-wb-or-file\n\n",
      "properties": {
        "date": "2016-12-10",
        "type": "Post",
        "category": "Python",
        "slug": "python-tarfile-module-unzip-invalid-mode-('wb')-or-filename",
        "tags": [],
        "title": "Python tarfile模块解压报错 invalid mode ('wb') or filename",
        "status": "Published",
        "urlname": "351382cf-57e4-4fd1-a59b-2e95dc07fd20",
        "updated": "2023-07-17 15:11:00"
      },
      "catalog": [
        {
          "title": "2016-12-10",
          "doc_id": "351382cf-57e4-4fd1-a59b-2e95dc07fd20"
        }
      ],
      "body": "",
      "realName": "Python tarfile模块解压报错 invalid mode ('wb') or filename",
      "relativePath": "/2016-12-10/Python tarfile模块解压报错 invalid mode ('wb') or filename.md"
    },
    {
      "id": "276c3766-5a22-4f6f-8316-f8de676c3a3d",
      "doc_id": "276c3766-5a22-4f6f-8316-f8de676c3a3d",
      "title": "276c3766-5a22-4f6f-8316-f8de676c3a3d",
      "updated": 1689577860000,
      "body_original": "\n### 默认参数陷阱\n\n\n```python\ndef foo(a1, args = []):\n    print \"args before = %s\" % (args)\n    args.insert(0, 10)\n    args.insert(0, 99999)\n    print \"args = %s \" % (args)\n\ndef main():\n    foo('a')\n    foo('b')\n\n```\n\n\n输出:\n\n\n```text\nargs before = []\nargs = [99999, 10] \nargs before = [99999, 10]\nargs = [99999, 10, 99999, 10] \n```\n\n\n函数中的参数默认值是一个可变的list, 函数体内修改了原来的默认值，而python会将修改后的值一直保留，并作为下次函数调用时的参数默认值\n\n\nPython manual中的说法:\n\n\n**Default parameter values are evaluated when the function definition is executed.** This means that the expression is evaluated once, when the function is defined, and that that same “pre-computed” value is used for each call. This is especially important to understand when a default parameter is a mutable object, such as a list or a dictionary: if the function modifies the object (e.g. by appending an item to a list), the default value is in effect modified. This is generally not what was intended. A way around this is to use None as the default, and explicitly test for it in the body of the function, e.g.:\n\n\n```text\ndef whats_on_the_telly(penguin=None):\n    if penguin is None:\n        penguin = []\n    penguin.append(\"property of the zoo\")\n    return penguin\n\n```\n\n\n参考:\n\n\n> http://www.cnblogs.com/ukessi/archive/2010/01/25/python-function-default-parameter-value-problem.html\n\n\n### is 和 ==\n\n\nis 比较的是两个对象是否是同一个对象, == 比较两个对象的值是否一样.\n\n\n### range 和 xrange\n\n\nrange可以返回一个可以用于所有目的的普通列表对象，而xrange将返回一个特殊目的的对象，尤其适用于迭代操作，但是xrange并不返回一个迭代器，如果需要这样一个迭代器，可以调用iter(xrange(x))。xrange返回的特殊目的对象比range返回的列表对象消耗较少的内存（范围比较大的时候）。但是对特殊目的对象执行循环操作的开销略微高于对列表执行循环的开销。\n\n\n```text\n>>> print range(5)\n[0, 1, 2, 3, 4]\n>>> print xrange(5)\nxrange(5)\n\n```\n\n\n### 强制访问私有属性\n\n\n通过 实例化对象名._类名__私有属性名 可以强制访问私有属性\n\n",
      "properties": {
        "date": "2016-12-10",
        "type": "Post",
        "category": "Python",
        "slug": "python-small-knowledge-point",
        "tags": [],
        "title": "python小知识点",
        "status": "Published",
        "urlname": "276c3766-5a22-4f6f-8316-f8de676c3a3d",
        "updated": "2023-07-17 15:11:00"
      },
      "catalog": [
        {
          "title": "2016-12-10",
          "doc_id": "276c3766-5a22-4f6f-8316-f8de676c3a3d"
        }
      ],
      "body": "",
      "realName": "python小知识点",
      "relativePath": "/2016-12-10/python小知识点.md"
    },
    {
      "id": "d6248408-342d-49c8-815f-69ff4076bb79",
      "doc_id": "d6248408-342d-49c8-815f-69ff4076bb79",
      "title": "d6248408-342d-49c8-815f-69ff4076bb79",
      "updated": 1689577800000,
      "body_original": "\n### 任务(Task)\n\n\nAndroid 是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈也被称作返回栈（Back Stack）.在默认情况下，每当我们启动了一个新的活动，它会在返回栈中入栈，并处于栈顶的位置。而每当我们按下 Back 键或调用 finish()方法去销毁一个活动时，处于栈顶的活动会出栈，这时前一个入栈的活动就会重新处于栈顶的位置。系统总是会显示处于栈顶的活动给用户。\n\n\n### 活动状态\n\n\nActivity 类中定义了七个回调方法:\n\n1. 运行状态: 当一个活动位于返回栈的栈顶时，这时活动就处于运行状态\n2. 暂停状态: 当一个活动不再处于栈顶位置，但仍然可见时，这时活动就进入了暂停状态\n3. 停止状态: 当一个活动不再处于栈顶位置，并且完全不可见的时候，就进入了停止状态，当其他地方需要内存时，处于停止状态的活动有可能会被系统回收\n4. 销毁状态当一个活动从返回栈中移除后就变成了销毁状态，系统会最倾向于回收处于这种状态的活动，从而保证手机的内存充足\n\n### 七个回调方法\n\n\nActivity 类中定义了七个回调方法，覆盖了活动生命周期的每一个环节.\n\n\n### onCreate()\n\n\n这个方法你已经看到过很多次了，每个活动中我们都重写了这个方法，它会在活动第一次被创建的时候调用。你应该在这个方法中完成活动的初始化操作，比如说加载布局、绑定事件等。\n\n\n### onStart()\n\n\n这个方法在活动由不可见变为可见的时候调用。\n\n\n### onResume()\n\n\n这个方法在活动准备好和用户进行交互的时候调用。此时的活动一定位于返回栈的\n栈顶，并且处于运行状态。\n\n\n### onPause()\n\n\n这个方法在系统准备去启动或者恢复另一个活动的时候调用。我们通常会在这个方\n法中将一些消耗 CPU 的资源释放掉，以及保存一些关键数据，但这个方法的执行速度\n一定要快，不然会影响到新的栈顶活动的使用。\n\n\n### onStop()\n\n\n这个方法在活动完全不可见的时候调用。它和 onPause()方法的主要区别在于，如\n果启动的新活动是一个对话框式的活动，那么 onPause()方法会得到执行，而 onStop()\n方法并不会执行。\n\n\n### onDestroy()\n\n\n这个方法在活动被销毁之前调用，之后活动的状态将变为销毁状态。\n\n\n### onRestart()\n\n\n这个方法在活动由停止状态变为运行状态之前调用，也就是活动被重新启动了。\n\n\n### 三种生存期\n\n\n以上七个方法中除了onRestart()方法，其他都是两两相对的，从而又可以将活动分为三种生存期。\n\n1. 完整生存期\n活动在 onCreate()方法和 onDestroy()方法之间所经历的，就是完整生存期。一般情况下，一个活动会在onCreate()方法中完成各种初始化操作，而在 onDestroy()方法中完成释放内存的操作。\n2. 可见生存期\n活动在 onStart()方法和 onStop()方法之间所经历的，就是可见生存期。在可见生存期内，活动对于用户总是可见的，即便有可能无法和用户进行交互。我们可以通过这两个方法，合理地管理那些对用户可见的资源。比如在 onStart()方法中对资源进行加载，而在 onStop()方法中对资源进行释放， 从而保证处于停止状态的活动不会占用过多内存。\n3. 前台生存期\n活动在 onResume()方法和 onPause()方法之间所经历的，就是前台生存期。在前台生存期内，活动总是处于运行状态的，此时的活动是可以和用户进行相互的，我们平时看到和接触最多的也这个状态下的活动。\n\nAndroid 官方提供了一张活动生命周期的示意图:\n\n\n![image](https://darkreunion-1256611153.file.myqcloud.com/16-12-16/77772045-file_1481818432274_be76.png)\n\n\n### 活动的启动模式\n\n\n启动模式一共有四种，分别是standard、singleTop、singleTask和singleInstance，可以在AndroidManifest.xml中通过给<activity>标签指定android:launchMode属性来选择启动模式。\n\n\n### standard\n\n\n在standard模式（即默认情况）下，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶的位置。对于使用standard 模式的活动，系统不会在乎这个活动是否已经在返回栈中存在，每次启动都会创建该活动的一个新的实例。\n\n\n### singleTop\n\n\n当活动的启动模式指定为singleTop，在启动活动时如果发现返回栈的栈顶已经是该活动，则认为可以直接使用它，不会再创建新的活动实例。但并未处于栈顶时，仍会创建新的实例。\n\n\n### singleTask\n\n\n当活动的启动模式指定为 singleTask，每次启动该活动时系统首先会在返回栈中检查是否存在该活动的实例，如果发现已经存在则直接使用该实例，并把在这个活动之上的所有活动统统出栈，如果没有发现就会创建一个新的活动实例。\n\n\n### singleInstance\n\n\n指定为 singleInstance 模式的活动会启用一个新的返回栈来管理这个活动。如果我们想实现其他程序和我们的程序可以共享这个活动的实例，在这种模式下会有一个单独的返回栈来管理这个活动，不管是哪个应用程序来访问这个活动，都共用的同一个返回栈，也就解决了共享活动实例的问题。\n\n\n### 利用集合类来管理活动\n\n\n通过定义一个集合类来管理活动, 可方便的实现一键退出所有的活动。\n\n\n```text\npublic class ActivityCollector {\n    public static List<Activity> activities = new ArrayList<Activity>();\n    \n    public static void addActivity(Activity activity) {\n        activities.add(activity);\n    }\n    \n    public static void removeActivity(Activity activity) {\n        activities.remove(activity);\n    }\n    \n    public static void finishAll() {\n        for (Activity activity : activities) {\n            if (!activity.isFinishing()) {\n                activity.finish();\n            }\n        }\n    }\n    \n}\n\n```\n\n",
      "properties": {
        "date": "2016-12-16",
        "type": "Post",
        "category": "Android",
        "slug": "android-activity-lifecycle",
        "tags": [],
        "title": "Android活动生命周期",
        "status": "Published",
        "urlname": "d6248408-342d-49c8-815f-69ff4076bb79",
        "updated": "2023-07-17 15:10:00"
      },
      "catalog": [
        {
          "title": "2016-12-16",
          "doc_id": "d6248408-342d-49c8-815f-69ff4076bb79"
        }
      ],
      "body": "",
      "realName": "Android活动生命周期",
      "relativePath": "/2016-12-16/Android活动生命周期.md"
    },
    {
      "id": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4",
      "doc_id": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4",
      "title": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4",
      "updated": 1689577800000,
      "body_original": "\n## 数据库和表的增删改\n\n\n### 创建数据库\n\n\n```text\nCREATE  DATABASE 数据库名;\n\n# mysql中还可使用如下语句\nCREATE SCHEMA 数据库名;\n\n```\n\n\n### 数据库选择\n\n\n```text\nUSE 数据库名;\n\n```\n\n\n### 创建表\n\n\n```text\ncreate table students\n(\n\tid int unsigned not null auto_increment primary key,\n\tname char(8) not null,\n\tsex char(4) not null,\n\tage tinyint unsigned not null,\n\ttel char(13) null default \"-\"\n);\n\n```\n\n\n### 重命名表名\n\n\n```text\nRENAME TABLE 旧表名 TO 新表名;\n\n```\n\n\n### 删除数据库和表\n\n\n```text\nDROP DATABASE 数据库名;\nDROP TABLE 表名;\n\n```\n\n\n## 插入和更新数据\n\n\n### 使用INSERT插入行\n\n\n```text\nINSERT INTO Customer\nVALUES(NULL,\n'100 Main Street',\n'Los Angles',\n'CA');\n\n```\n\n\n插入一个新客户到customers表。存储到每个表列中的数据在VALUES子句中给出，对每个列必须提供一个值。虽然这种语法很简单，但并不安全，应该尽量避免使用。\n更安全的写法:\n\n\n```text\nINSERT INTO Customer(cust_name,\n    cust_address,\n    cust_city,\n    cust_state)\nVALUES('Pep E',\n    '100 Main Street',\n    'Los Angeles',\n    'CA');\n\n```\n\n\n这种写法即使表的结构改变，此INSERT语句仍然能正确工作。\n\n\n### 使用UPDATA更新数据\n\n\n```text\nUPDATA Customers\nSET cust_email = 'elmer@fudd.com'\nWHERE cust id = 10005;\n\n```\n\n\n### 使用IGNORE忽略错误\n\n\n如果用UPDATE语句更新多行，并且在更新这些行中的一行或多行时出一个现错误，则整个UPDATE操作被取消。为即使是发生错误，也继续进行更新，可使用IGNORE关键字：\n\n\n```text\nUPDATE IGNORE customers...\n\n```\n\n\n### 使用DELETE删除数据\n\n\n```text\nWHERE FROM customers\nWHERE cust_id = 10006;\n\n```\n\n\n如果想从表中删除所有行，不要使用DELETE。可使用TRUNCATE TABLE语句，它完成相同的工作，但速度更快(TRUNCATE实际是删除原来的表并重新创建一个表，而不是逐行删除表中的数据)。\n\n\n## 表的查询\n\n\n### 查询列\n\n\n```text\nSELECT 列名 FROM 表名;\n\n```\n\n\n### 查询列中不重复项DISTINCT\n\n\n```text\nSELECT DISTINCT 列名 FROM 表名;\n\n```\n\n\n### 限制结果数量LIMIT\n\n\n```text\nSELECT 列名 FROM 表名 LIMIT 数量;\n\n```\n\n\n### 排序结果\n\n\n```text\nSELECT 列名 FROM 表名 ORDER BY 一个或多个列的名字;\n\n```\n\n\n默认为升序排列, 若要降序排序, 通过DESC可指定降序排序.\n\n\n```text\nSELECT 列名 FROM 表名 ORDER BY 一个或多个列的名字 DESC;\n\n```\n\n\n### 过滤结果\n\n\n```text\nSELECT 列名 FROM 表名 WHERE 条件;\n\n//使用LIKE来匹配通配符\nSELECT 列名 FROM 表名 WHERE 列名 LIKE 条件;\n\n//使用REGEXP来使用正则表达式\nSELECT 列名 FROM 表名 WHERE 列名 REGEXP 条件;\n\n```\n\n\nSQL的不等于通过'<>'来表示, 判断NULL通过IS NULL来表示, BETWEEN .. AND ..或者IN (.., ..)表示范围.\n多个条件组合时, AND比OR的优先级要高.\nMySQL中正则表达式不区分大小写, 若要区分大小写, 可用REGEXP BINARY.\n\n\n### 组合查询\n\n\n利用UNION，组合数条SQL查询结果作为单个查询结果集返回。这些组合查询通常称为并或复合查询.\n\n\n```text\nSELECT vend_id, prod_id, prod_price\nFROM products\nWHERE prod_price <=5\nUNION\nSELECT vend_id, prod_id, prod_price\nFROM products\nWHERE vend_id IN (1001, 1002);\n\n```\n\n\n## 拼接\n\n\n### Concat函数实现拼接\n\n\n```text\nSELECT Concat (列名1, '(', 列名2, ')') FROM 表名 WHERE 条件;\n\n```\n\n\n多数DBMS通过+或||来实现拼接, MySQL通过Concat()函数来实现.\n\n\n### 命名列的别名\n\n\n```text\nSELECT Concat (列名1, '(', 列名2, ')') AS 新列名 FROM 表名 WHERE 条件;\n\n```\n\n\n通过AS关键字, 讲拼接后的列命名一个别名.\n\n\n### 子查询\n\n\n```text\nSELECT cust_id\nFROM orders\nWHERE order_num IN (SELECT order_num\n                    FROM orderitems\n                    where prod_id = 'TNT2');\n\n```\n\n\n使用IN来进行子查询\n\n\n```text\nSELECT cust_name,\n       cust_state,\n       (SELECT COUNT(*)\n        FROM orders\n        WHERE　orders.cust_id = custom.cust_id) AS orders\nFROM customers\nORDER BY cust name;\n\n```\n\n\n## 函数\n\n\n### 文本函数\n\n- Upper() 文本转换为大写\n- Soundex() 寻找读音相近的数据\n- Trim() 删除多余的空格\n- RTrim() 删除右侧多余的空格\n- LTrim() 删除左侧多余的空格\n\n### 日期及时间处理函数\n\n\n![image](https://darkreunion-1256611153.file.myqcloud.com/public/16-12-10/96449569.jpg)\n\n\n### 数值处理函数\n\n\n![image](https://darkreunion-1256611153.file.myqcloud.com/public/16-12-10/2477595.jpg)\n\n\n### 聚集函数\n\n\n![image](https://darkreunion-1256611153.file.myqcloud.com/16-12-13/59196763-file_1481558765463_6d4d.png)\n\n\n可在函数中以DISTINCT来仅汇总不同的值\n\n\n```text\nSELECT AVG(DISTINCT prod_price) AS avg_price\nFROM products\nWHERE vend_id = 1003;\n\n```\n\n\n## 分组\n\n\n### 在SELECT语句的GROUP BY子句中建立分组\n\n\n```text\nSELECT vend_id, COUNT(*) AS num_prods\nFROM products\nGROUP BY vend_id;\n\n```\n\n\n### 通过HAVING来在分组中过滤数据\n\n\n```text\nSELECT cust_id, COUNT(*) AS orders\nFROM orders\nGROUP BY cust_id\nHAVING COUNT(*) >= 2;\n\n```\n\n\n### 分组使用的注意事项\n\n- GROUP BY子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制\n- 在建立分组时，指定的所有列都一起计算\n- GROUP BY子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）, 如果在SELECT中使用表达式，则必须在GROUP BY子句中指定相同的表达式, 不能使用别名\n- 除聚集计算语句外， SELECT语句中的每个列都必须在GROUP BY子句中给出\n- 如果分组列中具有NULL值，则NULL将作为一个分组返回。如果列中有多行NULL值，它们将分为一组\n- GROUP BY子句必须出现在WHERE子句之后， ORDER BY子句之前\n- 一般在使用GROUP BY子句时，应该也给出ORDER BY子句。这是保证数据正确排序的唯一方法\n\n## 联结\n\n\n### 使用WHERE创建等值联结\n\n\n```text\nSELECT vend_name, prod_name, prod_price\nFROM vendors, products\nWHERE vendors.vend_id = products.vend_id\nORDER BY vend_name, prod_name;\n\n```\n\n\n### 使用INNER JOIN创建等值联结\n\n\n```text\nSELECT vend_name, prod_name, prod_price\nFROM vendors INNER JOIN products\nON vendors.vend_id = products.vend_id;\n\n```\n\n\n### 联结多个表\n\n\n```text\nSELECT vend_name, prod_name, prod_price\nFROM vendors, products\nWHERE vendors.vend_id = products.vend_id\n    AND orderitems.prod_id = products.prod_id;\n\n```\n\n\n### 自联结\n\n\n自联结通常作为外部语句用来替代从相同表中检索数据时使用的子查询语句。虽然最终的结果是相同的，但有时候处理联结远比处理子查询快得多。\n\n\n```text\nSELECT p1.prod_id, p1.prod_name\nFROM products AS p1, producrs AS p2\nWHERE p1.vend_id = p2.vend_id\nAND p2.prod_id = 'DTNTR';\n\n//等价于\nSELECT prod_id, prod_name\nFROM products\nWHERE vend_id = (SELECT vend_id FROM products\n                WHERE prod_id = 'DTNTR');\n\n```\n\n\n### 自然联结\n\n\n无论何时对表进行联结，应该至少有一个列出现在不止一个表中（被联结的列）。标准的联结返回所有数据，甚至相同的列多次出现。 自然联结排除多次出现，使每个列只返回一次。\n\n\n```text\n//通配符只对第一个表使用。所有其他列明确列出，所以没有重复的列被检索出来\nSELECT c.*, o.order_num, o.order_date, oi.prod_id, oi.quantity, OI.price\nFROM customers AS c, orders AS o, orderitem AS oi\nWHERE c.cust_id = o.cust_id\nAND oi.order_num = o.order_num\nAND prod_id = 'FB';\n\n```\n\n\n### 外部联结\n\n\n许多联结将一个表中的行与另一个表中的行相关联。但有时候会需要包含没有关联行的那些行。例如，可能需要使用联结来完成以下工作：\n\n- 对每个客户下了多少订单进行计数，包括那些至今尚未下订单的客户\n- 列出所有产品以及订购数量，包括没有人订购的产品\n\n```text\nSELECT customers.cust_id, orders.order_num\nFROM custormers, INNER JOIN orders\nON customers.cust_id = order.cust_id;\n\n```\n\n\nMySQL不支持简化字符*=和=*的使用，这两种操作符在其他DBMS中是很流行的。\n\n",
      "properties": {
        "date": "2017-01-22",
        "type": "Post",
        "category": "数据库",
        "slug": "mysql-will-surely-know-notes",
        "tags": [],
        "title": "MySQL必知必会笔记",
        "status": "Published",
        "urlname": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4",
        "updated": "2023-07-17 15:10:00"
      },
      "catalog": [
        {
          "title": "2017-01-22",
          "doc_id": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4"
        }
      ],
      "body": "",
      "realName": "MySQL必知必会笔记",
      "relativePath": "/2017-01-22/MySQL必知必会笔记.md"
    },
    {
      "id": "85d0963c-d167-457f-9e97-19e6477c6d4e",
      "doc_id": "85d0963c-d167-457f-9e97-19e6477c6d4e",
      "title": "85d0963c-d167-457f-9e97-19e6477c6d4e",
      "updated": 1689577800000,
      "body_original": "\n### 变量引用\n\n- $(VAR): 会将VAR当做一条命令来执行\n- '$VAR': 单引号中包含的变量, 不会被引用, 仍然输出$VAR\n- \"$VAR\": 双引号中包含的变量, 会被引用成$VAR的值输出\n- ``: 优先执行其中的命令, 用在字符串中时, 仅在\"\"当中有效\n\n有时需要在一个字符串变量中定义一个命令并预先包含一个变量名, 在使用时再转换成变量名, 此时可通过eval命令来达到目的.\n\n\n```text\nCMD='eval echo $VALUE'\nVALUE=\"Hello\"\n\n$CMD\n# 执行echo \"Hello\", 输出\"Hello\"\n\n```\n\n\n### 特殊变量\n\n- $0: 获取当前执行脚本的文件名，包括路径\n- $n: 获取当前执行的shell脚本的第N个参数, n=1..9, 当n为0时表示脚本的文件名, 如果n大于9, 可用大括号括起来如${10}\n- $@: 这个程序的所有参数\"$1\" \"$2\" \"$3\"..., 这是将参数传递给其他程序的最佳方式, 因为会保留所有内嵌在每个参数里的空白\n- $*: 获取当前shell的所有参数，会将所有的命令行参数视为单个字符串\n- $?: 代表上一个命令执行是否成功的标志，如果执行成功则$? 为0, 否则不为0\n- $#: 获取当前shell命令行中参数的总个数\n- $_: 代表上一个命令的最后一个参数\n- $$: 代表所在命令的PID\n- $!: 代表最后执行的后台命令的PID\n\n### 常用语句\n\n- 获取执行脚本绝对路径: `$(cd \"$(dirname \"$0\")\";pwd)`\n\n### 日志输出\n\n\nshell脚本开发中, 输出的语句尽量不出现在标准输出, 除非是少数的步骤提示性语句, 如果是出错信息, 应存入到自己定义的出错日志中, 以便后期维护和调试, 其它不关心的信息直接输出到/dev/null中. 否则输出信息过多, 容易耗尽缓存, 造成脚本运行卡死, 难以调试定位.\n\n- date: 显示日期时间的命令, 可通过此命令来作为日志的前缀, 方便定位. 一般形式为 \"[ date +%Y%m%d-%H%M%S` ]\"\n- &[n]: 代表已经存在的文件描述符, &1代表输出, &2代表错误输出, &-代表关闭与它绑定的描述符, 如2>&1 错误输出绑定到标准输出, 2>&- 等价于2>/dev/null\n\n### 条件判断\n\n\n### 使用[ ]判断\n\n\n### 注意事项\n\n\n`[ $HOME == $MALL ]`\n\n- `[ ]`中每个组件都需要空格键来分格, 其中的变量最好都以双引号括起来, 常量最好都以单或双括起来\n- `[ ]`中==和'='结果都完全一样, 习惯上可尽量使用==\n\n### 常用参数\n\n\n数值比较\n\n- -ne: 比较两个参数是否不相等\n- -lt 参数1是否小于参数2\n- -le 参数1是否小于等于参数2\n- -gt 参数1是否大于参数2\n- -ge 参数1是否大于等于参数2\n- -n：判断变量是否有值\n\n文件比较\n\n- -f 检查某文件是否存在\n- -d 检查目录是否存在\n- -x：判断是否存在并有可执行权限\n- -d: 文件为目录为真\n- -c: 文件为字符特殊文件为真\n- -b: 文件为块特殊文件为真\n- -s: 文件大小非0时为真\n- -t: 当文件描述符(默认为1)指定的设备为终端时为真\n\n权限比较\n\n- -r: 用户可读为真\n- -w: 用户可写为真\n- -x: 用户可执行为真\n",
      "properties": {
        "date": "2017-03-12",
        "type": "Post",
        "category": "Linux管理",
        "slug": "summary-of-shell-writing",
        "tags": [],
        "title": "shell编写总结",
        "status": "Published",
        "urlname": "85d0963c-d167-457f-9e97-19e6477c6d4e",
        "updated": "2023-07-17 15:10:00"
      },
      "catalog": [
        {
          "title": "2017-03-12",
          "doc_id": "85d0963c-d167-457f-9e97-19e6477c6d4e"
        }
      ],
      "body": "",
      "realName": "shell编写总结",
      "relativePath": "/2017-03-12/shell编写总结.md"
    },
    {
      "id": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b",
      "doc_id": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b",
      "title": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b",
      "updated": 1689577800000,
      "body_original": "\n### MVC模式\n\n\nMVC将应用程序分解为三个组成部分：mode（模型）、view（视图）、control（控制器），其中：\n\n- M 管理应用程序的状态（通常存储到数据库中），并榆树改变状态的行为（或者叫“业务规则”）\n- C 接受外部用户的操作，根据操作访问模型获取数据，并调用“视图”显示这些数据，控制器将“模型”和“视图”隔离，并成为二者之间的纽带\n- V 负责把数据格式化后呈现给用户。\n\n### MTV\n\n\nDjango也是一个MVC框架，但在Django中，控制器接受用户输入的部分由框架自行处理，所以Django中更关注的是视图（Views），称为MTV模式：\n\n- M 代表模型（Model），数据存取层，该层处理与数据相关的所有事物：如何存取、包含哪些行为以及数据之间的关系等\n- T 代表模板（Template），即表现层。该层处理与表现相关的决定：如何在页面和其他类型的文档中进行显示\n- V 代表视图（View），即业务逻辑层。该层包含存取模型及调取恰当模型的相关逻辑，可看作模板与模型之间的桥梁\n\n![](https://darkreunion-1256611153.file.myqcloud.com/img/20190131201838.png)\n\n",
      "properties": {
        "date": "2017-04-09",
        "type": "Post",
        "category": "Django",
        "slug": "design-pattern-of-django",
        "tags": [],
        "title": "Django的设计模式",
        "status": "Published",
        "urlname": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b",
        "updated": "2023-07-17 15:10:00"
      },
      "catalog": [
        {
          "title": "2017-04-09",
          "doc_id": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b"
        }
      ],
      "body": "",
      "realName": "Django的设计模式",
      "relativePath": "/2017-04-09/Django的设计模式.md"
    },
    {
      "id": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b",
      "doc_id": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b",
      "title": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b",
      "updated": 1689577740000,
      "body_original": "\nDjango 中利用ModelForm 可以快速地利用数据库对应的Model 子类来自动创建对应表单.\n\n\n例如:\n\n\n```python\nfrom django.db import models\nfrom django.forms import ModelForm\n\n\nclass Book(models.Model):\n    name = models.CharField(max_length=100)\n    authors = models.ManyToManyField(Author)\n\n\nclass BookForm(ModelForm):\n    class Meta:\n        model = Book\n        fields = ['name', 'authors']\n```\n\n\n但这样默认创建的表单是很丑的, 一般需要重写字段的控件属性, 来加入各种效果. 总结下我常用的两种.\n\n\n### 修改Meta的widgets属性\n\n\n在Django手册的ModelForm一章中, 提供了这种方式, Book 的name 属性为CharField 如果希望它表示成一个`<textarea>` 而不是默认的`<input type=\"text\">` 时, 可以按如下方式覆盖字段默认的Widget：\n\n\n```python\nclass BookForm(ModelForm):\n    class Meta:\n        model = Book\n        fields = ['name', 'authors']\n        widgets = {\n            'name': Textarea(attrs={'cols': 80, 'rows': 20}),\n        }\n```\n\n\n这种方式可以指定控件的类型及其对应的属性, 不过大部分时候, 默认的控件类型已经够用了, 只需要修改控件的属性. 可以采取另外一种更方便的方法.\n\n\n### 重写`__init__`方法\n\n\n通过通过重写`__init__` 方法, 遍历base_fields字段, 来快速修改控件的属性.\n\n\n```python\nclass BookForm(ModelForm):\n    class Meta:\n        model = Book\n        fields = ['name', 'authors']\n\n    def __init__(self, *args, **kwargs):\n        super(BookForm, self).__init__(*args, **kwargs)\n        \n        for field_name in self.base_fields:\n            field = self.base_fields[field_name]\n            field.widget.attes.update({'cols': 80, 'rows': 20})\n\n```\n\n",
      "properties": {
        "date": "2017-04-09",
        "type": "Post",
        "category": "Django",
        "slug": "django-modelform-modifies-the-default-control-properties",
        "tags": [],
        "title": "Django ModelForm修改默认的控件属性",
        "status": "Published",
        "urlname": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b",
        "updated": "2023-07-17 15:09:00"
      },
      "catalog": [
        {
          "title": "2017-04-09",
          "doc_id": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b"
        }
      ],
      "body": "",
      "realName": "Django ModelForm修改默认的控件属性",
      "relativePath": "/2017-04-09/Django ModelForm修改默认的控件属性.md"
    },
    {
      "id": "4531936b-6f90-48a8-8d44-c663f3a660cd",
      "doc_id": "4531936b-6f90-48a8-8d44-c663f3a660cd",
      "title": "4531936b-6f90-48a8-8d44-c663f3a660cd",
      "updated": 1689577740000,
      "body_original": "\n最近写了个程序需要随Linux启动时自动运行起来, 查了一些方法后, 通过配置程序成为系统的服务实现了这个需求, 在此记录一下.\n\n\n### 测试程序\n\n\n```text\n#! /bin/sh\n\nwhile [ true ]\ndo\n    echo \"[`date +%Y%m%d-%H%M%S`]\" >> /var/log/test_sh.log\n    sleep 5\ndone\n\n```\n\n\n每5秒, 向/var/log/test_sh.log 输出一个当前时间的字符串, 保存为test_sh\n\n\n### 服务控制脚本\n\n\n通过此服务控制脚本, 可以实现通过系统的service命令设置这个服务的start, stop, 以及运行status查询状态, 保存为tstd. 服务控制脚本后接d是一种惯例性的命名, 代表daemon.\n\n\n```text\n#! /bin/sh\n\n# chkconfig: 35 99 99\n# descroption: service test script\n# processname: test_sh\n\n\n### BEGIN INIT INFO\n# Provides:           tstd\n# Required-Start:\n# Should-Start: \n# Required-Stop: \n# Should-Stop: \n# Default-Start:      2 3 5\n# Default-Stop:       0 1 2 6\n# Description:        service test script \n#\n### END INIT INFO\n\n```\n\n\n通过以上注释, 可通过`chkconfig`或者`insserv`命令来安装服务, 指定服务的在Linux的对应的执行等级中自启动以及停止, 并设定启动顺序.\n\n\nLinux执行等级:\n\n- 等级0表示：表示关机\n- 等级1表示：单用户模式\n- 等级2表示：无网络连接的多用户命令行模式\n- 等级3表示：有网络连接的多用户命令行模式\n- 等级4表示：不可用\n- 等级5表示：带图形界面的多用户模式\n- 等级6表示：重新启动\n\n```text\nTEST_BIN='/usr/sbin/test_sh'\nsource /etc/rc.status\ntest -x $TEST_BIN || exit 5\n\nrc_reset\n\n```\n\n\n这一段在/usr/sbin/中检查服务对应的脚本程序是否存在, 并加载/etc/rc.status这个脚本, rc.status脚本中包含了rc_reset, rc_status, rc_failed, rc_reset, rc_exit等有用的命令, 可以通过接受上一条命令的结果, 在service命令执行时显示出不同的效果.\n\n\n```text\ncase \"$1\" in\n    start)\n        echo \"starting test daemon\"\n        startproc $TEST_BIN\n        rc_status -v\n        ;;\n    \n    stop)\n        echo \"stop test daemon\"\n        killproc $TEST_BIN\n        rc_status -v\n        ;;\n        \n    status)\n        echo \"stop test daemon\"\n        checkproc $TEST_BIN\n        rc_status -v\n        ;;\n        \n    *)\n        echo \"Usage: $0 { start | stop | status }\"\n        exit 1\n        ;;\nesac\n\n```\n\n\nstartproc 默认通过程序的绝对路径和`/var/run/<basename>.pid` 来检索程序是否运行, 没有检索到时便以后台的方式来运行程序.\n\n\nkillproc则会通过通过向程序发送SIGTERM来终止程序的运行, 若程序没有响应, 还会依次发送SIGHUP, 以及SIGKILL来删除程序, 确认程序已关闭后吗会删除程序产生的PID文件.\n\n\ncheckproc会检查程序的状态, 根据程序的状态返回不同的值:\n\n- 0: 服务运行中\n- 1: 服务停止, 但是/var/run 下的pid文件仍然存在\n- 2: 服务停止, 但是/var/lock 下的文件仍然存在\n- 3: 服务没有在运行\n\n### 安装脚本\n\n\n```text\n#! /bin/sh\n\nROOT_DIR=$(echo $(cd \"$(dirname \"$0\")\"; pwd))\n\necho $ROOT_DIR\nservice tstd stop > /dev/null 2>&1\n\ninstall -m 750 ${ROOT_DIR}/test_sh /usr/sbin/\ninstall -m 750 ${ROOT_DIR}/tstd /etc/init.d/\n\nchkconfig -a tstd > /dev/null 2>&1\nservice tstd start > /dev/null 2>&1\necho -e \"#!/bin/sh \\n service tstd start > /dev/null 2>&1\" \\\n    > /etc/cron.hourly/tst_crontab\n\necho 'success'\n\n```\n\n\n安装脚本使用install命令来拷贝脚本到指定目录, 并设置对应的权限. chkconfig命令可以将这个自定义的服务添加到设定的执行等级的自启动中, 即在/etc/rc*.d中创建顺序对应的符号链接.\n最后在/etc/cron.hourly中创建了一个脚本来每小时自动拉起一次服务, 防止服务意外终止掉. 还可以通过crontab来创建更精确的自动拉起间隔.\n\n\n以上脚本在SUSE下运行通过, 其他系统的部分命令不一样, 但整体流程应该是差不多的.\n\n\n参考: [http://www.cnblogs.com/bangerlee/archive/2012/03/30/2412652.html](http://www.cnblogs.com/bangerlee/archive/2012/03/30/2412652.html)\n\n",
      "properties": {
        "date": "2017-04-20",
        "type": "Post",
        "category": "Linux管理",
        "slug": "the-configuration-program-becomes-a-linux-service",
        "tags": [],
        "title": "配置程序成为Linux服务",
        "status": "Published",
        "urlname": "4531936b-6f90-48a8-8d44-c663f3a660cd",
        "updated": "2023-07-17 15:09:00"
      },
      "catalog": [
        {
          "title": "2017-04-20",
          "doc_id": "4531936b-6f90-48a8-8d44-c663f3a660cd"
        }
      ],
      "body": "",
      "realName": "配置程序成为Linux服务",
      "relativePath": "/2017-04-20/配置程序成为Linux服务.md"
    },
    {
      "id": "3703f624-8045-4b58-9dda-216f30a79bcc",
      "doc_id": "3703f624-8045-4b58-9dda-216f30a79bcc",
      "title": "3703f624-8045-4b58-9dda-216f30a79bcc",
      "updated": 1689577680000,
      "body_original": "\n转载至[http://www.cnblogs.com/thinkroom/p/6729480.html](http://www.cnblogs.com/thinkroom/p/6729480.html) 作者：码匠信龙\n\n\n举个简单的例子：\n\n\n有些人喜欢的某个公众号，然后去关注这个公众号，哪天这个公众号发布了篇新的文章，没多久订阅者就会在微信里收到这个公众号推送的新消息，如果感兴趣就打开来阅读。\n\n\n![image](http://cdn.thinkingroom.me/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BE%8B%E5%AD%90.png?_=6729480)\n\n\n事件驱动模型可以理解为上面的例子，是设计模式中观察者模式的一种典型应用。除了订阅公众号外，如你关注某人的微博，关注某人的简书，当被关注者发了个新状态或者新文章，你会收到他们新的消息，这些都可以理解为事件驱动模型。\n\n\n实际上，世间万物各种属性的变化，我们都可以抽象为事件，最直观的是图形界面应用里，如常见的点击、双击、拖动操作，又或者是游戏里的英雄升级了，怪物死亡了等等，都可以视为一个事件发生了。而发送事件的事物称为事件源，对这个事件感兴趣的事物为监听者，事件发生后监听者会收到这个消息，然后做相应的反应。\n\n\n例如上面公众号例子可以翻译为，监听器（订阅者）监听了（关注了）事件源（公众号），当事件源的发送事件时（公众号发布文章），所有监听该事件的监听器（订阅者）都会接收到消息并作出响应（阅读文章）。\n\n1. 公众号为事件源\n2. 订阅者为事件监听器\n3. 订阅者关注公众号，相当于监听器监听了事件源\n4. 公众号发布文章这个动作为发送事件\n5. 订阅者收到事件后，做出阅读文章的响应动作\n\n公众号例子按事件驱动可以理解成下图\n\n\n![image](http://cdn.thinkingroom.me/%E5%85%AC%E4%BC%97%E5%8F%B7%E4%BE%8B%E5%AD%90%E7%BF%BB%E8%AF%91.png?_=6729480!)\n\n\n所以事件驱动模式可以进一步抽象理解为由事件源，事件对象，以及事件监听器三元素构成，能完成监听器监听事件源、事件源发送事件，监听器收到事件后调用响应函数的动作。\n\n\n事件驱动主要包含以下元素和操作函数：\n\n\n**元素**\n\n1. 事件源\n2. 事件监听器\n3. 事件对象\n\n**操作函数**\n4. 监听动作\n5. 发送事件\n6. 调用监听器响应函数\n\n\n了解清楚了事件驱动的工作原理后，读者可以试着用自己熟悉的编程语言实现，编程主要实现下面的内容，笔者后续给python实现：\n\n\n用户根据实际业务逻辑定义\n\n- 事件源 EventSources\n- 监听器 Listeners\n\n事件管理者 EventManager\n\n\n**成员**\n\n1. 响应函数队列 Handlers\n2. 事件对象 Event\n3. 事件对象列表 EventQueue\n\n**操作函数**\n4. 监听动作 AddEventListener\n5. 发送事件 SendEvent\n6. 调用响应函数 EventProcess\n\n\n在实际的软件开发过程中，你会经常看到事件驱动的影子，几乎所有的GUI界面都采用事件驱动编程模型，很多服务器网络模型的消息处理也会采用，甚至复杂点的数据库业务处理也会用这种模型，因为这种模型解耦事件发送者和接收者之间的联系，事件可动态增加减少接收者，业务逻辑越复杂，越能体现它的优势。下面，笔者用python实现EventManager事件管理类，大概就百来行代码左右。\n\n\n```python\n# encoding: UTF-8\n# 系统模块\nfrom Queue import Queue, Empty\nfrom threading import *\n########################################################################\nclass EventManager:\n    #----------------------------------------------------------------------\n    def __init__(self):\n        \"\"\"初始化事件管理器\"\"\"\n        # 事件对象列表\n        self.__eventQueue = Queue()\n        # 事件管理器开关\n        self.__active = False\n        # 事件处理线程\n        self.__thread = Thread(target = self.__Run)\n\n        # 这里的__handlers是一个字典，用来保存对应的事件的响应函数\n        # 其中每个键对应的值是一个列表，列表中保存了对该事件监听的响应函数，一对多\n        self.__handlers = {}\n\n    #----------------------------------------------------------------------\n    def __Run(self):\n        \"\"\"引擎运行\"\"\"\n        while self.__active == True:\n            try:\n                # 获取事件的阻塞时间设为1秒\n                event = self.__eventQueue.get(block = True, timeout = 1)  \n                self.__EventProcess(event)\n            except Empty:\n                pass\n\n    #----------------------------------------------------------------------\n    def __EventProcess(self, event):\n        \"\"\"处理事件\"\"\"\n        # 检查是否存在对该事件进行监听的处理函数\n        if event.type_ in self.__handlers:\n            # 若存在，则按顺序将事件传递给处理函数执行\n            for handler in self.__handlers[event.type_]:\n                handler(event)\n\n    #----------------------------------------------------------------------\n    def Start(self):\n        \"\"\"启动\"\"\"\n        # 将事件管理器设为启动\n        self.__active = True\n        # 启动事件处理线程\n        self.__thread.start()\n\n    #----------------------------------------------------------------------\n    def Stop(self):\n        \"\"\"停止\"\"\"\n        # 将事件管理器设为停止\n        self.__active = False\n        # 等待事件处理线程退出\n        self.__thread.join()\n\n    #----------------------------------------------------------------------\n    def AddEventListener(self, type_, handler):\n        \"\"\"绑定事件和监听器处理函数\"\"\"\n        # 尝试获取该事件类型对应的处理函数列表，若无则创建\n        try:\n            handlerList = self.__handlers[type_]\n        except KeyError:\n            handlerList = []\n            \n        self.__handlers[type_] = handlerList\n        # 若要注册的处理器不在该事件的处理器列表中，则注册该事件\n        if handler not in handlerList:\n            handlerList.append(handler)\n            \n    #----------------------------------------------------------------------\n    def RemoveEventListener(self, type_, handler):\n        \"\"\"移除监听器的处理函数\"\"\"\n        #读者自己试着实现\n        \n    #----------------------------------------------------------------------\n    def SendEvent(self, event):\n        \"\"\"发送事件，向事件队列中存入事件\"\"\"\n        self.__eventQueue.put(event)\n\n########################################################################\n\"\"\"事件对象\"\"\"\nclass Event:\n    def __init__(self, type_=None):\n        self.type_ = type_      # 事件类型\n        self.dict = {}          # 字典用于保存具体的事件数据\n\n```\n\n\n测试代码\n\n\n```python\n#-------------------------------------------------------------------\n# encoding: UTF-8\nimport sys\nfrom datetime import datetime\nfrom threading import *\nfrom EventManager import *\n\n#事件名称  新文章\nEVENT_ARTICAL = \"Event_Artical\"\n\n#事件源 公众号\nclass PublicAccounts:\n    def __init__(self,eventManager):\n        self.__eventManager = eventManager\n\n    def WriteNewArtical(self):\n        #事件对象，写了新文章\n        event = Event(type_=EVENT_ARTICAL)\n        event.dict[\"artical\"] = u'如何写出更优雅的代码\\n'\n        #发送事件\n        self.__eventManager.SendEvent(event)\n        print u'公众号发送新文章\\n'\n\n#监听器 订阅者\nclass Listener:\n    def __init__(self,username):\n        self.__username = username\n\n    #监听器的处理函数 读文章\n    def ReadArtical(self,event):\n        print(u'%s 收到新文章' % self.__username)\n        print(u'正在阅读新文章内容：%s'  % event.dict[\"artical\"])\n\n\"\"\"测试函数\"\"\"\n#--------------------------------------------------------------------\ndef test():\n    listner1 = Listener(\"thinkroom\") #订阅者1\n    listner2 = Listener(\"steve\")#订阅者2\n\n    eventManager = EventManager()\n    \n    #绑定事件和监听器响应函数(新文章)\n    eventManager.AddEventListener(EVENT_ARTICAL, listner1.ReadArtical)\n    eventManager.AddEventListener(EVENT_ARTICAL, listner2.ReadArtical)\n    eventManager.Start()\n\n    publicAcc = PublicAccounts(eventManager)\n    timer = Timer(2, publicAcc.WriteNewArtical)\n    timer.start()\n    \nif __name__ == '__main__':\n    test()\n\n```\n\n",
      "properties": {
        "date": "2017-04-27",
        "type": "Post",
        "category": "设计模式",
        "slug": "brief-explanation-of-event-driven-(python-implementation)",
        "tags": [],
        "title": "事件驱动的简明讲解(python实现)",
        "status": "Published",
        "urlname": "3703f624-8045-4b58-9dda-216f30a79bcc",
        "updated": "2023-07-17 15:08:00"
      },
      "catalog": [
        {
          "title": "2017-04-27",
          "doc_id": "3703f624-8045-4b58-9dda-216f30a79bcc"
        }
      ],
      "body": "",
      "realName": "事件驱动的简明讲解(python实现)",
      "relativePath": "/2017-04-27/事件驱动的简明讲解(python实现).md"
    },
    {
      "id": "acdd1a45-2613-49f0-a576-7b6875fe99f8",
      "doc_id": "acdd1a45-2613-49f0-a576-7b6875fe99f8",
      "title": "acdd1a45-2613-49f0-a576-7b6875fe99f8",
      "updated": 1689577680000,
      "body_original": "\n### 可迭代对象\n\n\nPython中任意的对象，只要它定义了可以返回一个迭代器的`__iter__`方法，或者定义了可以支持下标索引的`__getitem__`方法，那么它就是一个可迭代对象。简单来说，可迭代对象就是能提供迭代器的任意对象，**但可迭代对象本身并不一定是一个迭代器**。\n\n\n### 迭代器\n\n\n任意对象，只要定义了`next`(Python2) 或者`__next__`方法，它就是一个迭代器。迭代完毕后继续调用`__next__`方法会产生一个`StopIteration`异常。for循环即通过自动捕捉这个异常来停止迭代的。\n\n\n### 相关内置函数\n\n- iter()：可以自动根据一个可迭代对象返回一个迭代器对象。\n- next()：可以自动调用迭代器的`__next__()`方法。\n\n```python\na = iter([1,2,3])\na.__next__()\nnext(a)\na.__next__()\n\n# 输出:\n1\n2\n3\n\n```\n\n\n### 生成器\n\n\n生成器也是一种迭代器，但是只能对其迭代一次。通过使用“for”循环，或者传递给任意可以进行迭代的函数和结构来遍历它们。大多数时候生成器是以函数配合`yield`来实现的，可以将`yield`看成一种特殊的`return`，每次会顺序返回一个新值。\n\n\n```python\ndef func():\n    yield 1\n    yield 2\n    yield 3\n\na = func()\na.__next__()\na.__next__()\na.__next__()\n\n# 输出:\n1\n2\n3\n\n```\n\n\n### 生成器使用场景\n\n\n因为它们并没有把所有的值存在内存中，而是在运行时生成值。因此特别适合不想同一时间将所有计算出来的大量结果集分配到内存当中时的场景，特别是当结果集里还包含循环的时候。\n\n\n```python\n# 计算斐波那契数列的生成器\ndef fibon(n):\n    a = b = 1\n    for i in range(n):\n        yield a\n        a, b = b, a + b\n        \nfor x in fibon(1000000):\n    print(x)\n\n```\n\n\n### 总结\n\n\n了解完以上知识后，以一段综合代码进行下总结。\n\n\n```python\n# Fei类中实现了__iter__方法，成为一个可迭代的类\nclass Fei:\n\n    @staticmethod\n    # 计算斐波那契数列的生成器\n    def fibon(n):\n        a = b = 1\n        for i in range(n):\n            yield a\n            a, b = b, a + b\n\n    # 返回一个计算前100斐波那契数列的生成器\n    def __iter__(self):\n        return Fei.fibon(100)\n\na = Fei()\n\n# 使用for循环来遍历Fei类对象a\nfor i in a:\n    print(i)\n\n```\n\n",
      "properties": {
        "date": "2017-05-06",
        "type": "Post",
        "category": "Python",
        "slug": "python-advanced-iterator-and-generator",
        "tags": [],
        "title": "Python进阶之迭代器和生成器",
        "status": "Published",
        "urlname": "acdd1a45-2613-49f0-a576-7b6875fe99f8",
        "updated": "2023-07-17 15:08:00"
      },
      "catalog": [
        {
          "title": "2017-05-06",
          "doc_id": "acdd1a45-2613-49f0-a576-7b6875fe99f8"
        }
      ],
      "body": "",
      "realName": "Python进阶之迭代器和生成器",
      "relativePath": "/2017-05-06/Python进阶之迭代器和生成器.md"
    },
    {
      "id": "c4d4129f-e286-4dbd-a7af-8e824ae2924e",
      "doc_id": "c4d4129f-e286-4dbd-a7af-8e824ae2924e",
      "title": "c4d4129f-e286-4dbd-a7af-8e824ae2924e",
      "updated": 1689577620000,
      "body_original": "\n### 函数也是对象\n\n\n要理解Python装饰器，首先要明白在Python中，函数也是一种对象，因此可以把定义函数时的函数名看作是函数对象的一个引用。既然是引用，因此可以将函数赋值给一个变量，也可以把函数作为一个参数传递或返回。同时，函数体中也可以再定义函数。\n\n\n### 装饰器本质\n\n\n可以通过编写一个纯函数的例子来还原装饰器所要做的事。\n\n\n```python\ndef decorator(func):\n    \n    def wrap():\n        print(\"Doing someting before executing func()\")\n        func()\n        print(\"Doing someting after executing func()\")\n\n    return wrap\n\n\ndef fun_test():\n    print(\"func\")\n\n\nfun_test = decorator(fun_test)\nfun_test()\n\n# Output:\n# Doing someting before executing func()\n# func\n# Doing someting after executing func()\n```\n\n1. `fun_test`所指向的函数的引用传递给`decorator()`函数\n2. `decorator()`函数中定义了`wrap()`子函数，这个子函数会调用通过`func`引用传递进来的`fun_test()`函数，并在调用函数的前后做了一些其他的事情\n3. `decorator()`函数返回内部定义的`wrap()`函数引用\n4. `fun_test`接收`decorator()`返回的函数引用，从而指向了一个新的函数对象\n5. 通过`fun_test()`调用新的函数执行`wrap()`函数的功能，从而完成了对`fun_test()`函数的前后装饰\n\n### Python中使用装饰器\n\n\n在Python中可以通过`@`符号来方便的使用装饰器功能。\n\n\n```python\ndef decorator(func):\n    \n    def wrap():\n        print(\"Doing someting before executing func()\")\n        func()\n        print(\"Doing someting after executing func()\")\n\n    return wrap\n\n@decorator\ndef fun_test():\n    print(\"func\")\n\n\nfun_test()\n\n# Output:\n# Doing someting before executing func()\n# func\n# Doing someting after executing func()\n```\n\n\n装饰的功能已经实现了，但是此时执行:\n\n\n```python\nprint(fun_test.__name__)\n\n# Output:\n# wrap\n```\n\n\n`fun_test.__name__`已经变成了`wrap`，这是应为`wrap()`函数已经重写了我们函数的名字和注释文档。此时可以通过`functools.wraps`来解决这个问题。`wraps`接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。\n\n\n更规范的写法：\n\n\n```python\nfrom functools import wraps\n\ndef decorator(func):\n    @wraps(func)\n    def wrap():\n        print(\"Doing someting before executing func()\")\n        func()\n        print(\"Doing someting after executing func()\")\n\n    return wrap\n\n\n@decorator\ndef fun_test():\n    print(\"func\")\n\n\nfun_test()\nprint(fun_test.__name__)\n\n# Output:\n# Doing someting before executing func()\n# func\n# Doing someting after executing func()\n# fun_test\n```\n\n\n### 带参数的装饰器\n\n\n通过返回一个包裹函数的函数，可以模仿wraps装饰器，构造出一个带参数的装饰器。\n\n\n```python\nfrom functools import wraps\n\ndef loginfo(info='info1'):\n    def loginfo_decorator(func):\n        @wraps(func)\n        def wrap_func(*args, **kwargs):\n            print(func.__name__ + ' was called')\n            print('info: %s' % info)\n            \n            return func(*args, **kwargs)\n        return wrap_func\n    return loginfo_decorator\n    \n@loginfo()\ndef func1():\n    pass\n    \nfunc1()\n\n# Output:\n# func1 was called\n# info: info1\n\n@loginfo(info='info2')\ndef func2():\n    pass\n\nfunc2()\n# Output:\n# func2 was called\n# info: info2\n```\n\n\n### 装饰器类\n\n\n通过编写类的方法也可以实现装饰器，并让装饰器具备继承等面向对象中更实用的特性\n\n\n首先编写一个装饰器基类：\n\n\n```python\nfrom functools import wraps\n\nclass loginfo:\n    def __init__(self, info='info1'):\n        self.info = info\n        \n    def __call__(self, func):\n        @wrap\n        def wrap_func(*args, **kwargs):\n            print(func.__name__ + ' was called')\n            print('info: %s' % self.info)\n            \n            self.after()    # 调用after方法，可以在子类中实现\n            return func(*args, **kwargs)\n        return wrap_func\n\n    def after(self):\n        pass\n\n\n@loginfo(info='info2')\ndef func1():\n    pass\n    \n# Output:\n# func1 was called\n# info: info1\n```\n\n\n再通过继承`loginfo`类，扩展装饰器的功能：\n\n\n```python\nclass loginfo_after(loginfo):\n    def __init__(self, info2='info2', *args, **kwargs):\n        self.info2 = info2\n        super(loginfo_after, self).__init__(*args, **kwargs)\n\n    def after(self):\n        print('after: %s' % self.info2)\n\n\n@loginfo_after()\ndef func2():\n    pass\n\nfunc2()\n    \n# Output:\n# func2 was called\n# info: info1\n# after: info2\n```\n\n",
      "properties": {
        "date": "2017-05-10",
        "type": "Post",
        "category": "Python",
        "slug": "python-advanced-decorator",
        "tags": [],
        "title": "Python进阶之装饰器",
        "status": "Published",
        "urlname": "c4d4129f-e286-4dbd-a7af-8e824ae2924e",
        "updated": "2023-07-17 15:07:00"
      },
      "catalog": [
        {
          "title": "2017-05-10",
          "doc_id": "c4d4129f-e286-4dbd-a7af-8e824ae2924e"
        }
      ],
      "body": "",
      "realName": "Python进阶之装饰器",
      "relativePath": "/2017-05-10/Python进阶之装饰器.md"
    },
    {
      "id": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882",
      "doc_id": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882",
      "title": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882",
      "updated": 1689577560000,
      "body_original": "\n> 转载至 https://eastlakeside.gitbooks.io/interpy-zh/content/collections/collections.html\n\n\n## 容器(Collections)\n\n\nPython附带一个模块，它包含许多容器数据类型，名字叫作collections。我们将讨论它的作用和用法。\n我们将讨论的是：\n\n- defaultdict\n- counter\n- deque\n- namedtuple\n- enum.Enum (包含在Python 3.4以上)\n\n### defaultdict\n\n\n我个人使用defaultdict较多，与dict类型不同，你不需要检查key是否存在，所以我们能这样做：\n\n\n```python\nfrom collections import defaultdict\n\ncolours = (\n    ('Yasoob', 'Yellow'),\n    ('Ali', 'Blue'),\n    ('Arham', 'Green'),\n    ('Ali', 'Black'),\n    ('Yasoob', 'Red'),\n    ('Ahmed', 'Silver'),\n)\n\nfavourite_colours = defaultdict(list)\n\nfor name, colour in colours:\n    favourite_colours[name].append(colour)\n\nprint(favourite_colours)\n\n# 运行输出:\n\n# defaultdict(<type 'list'>,\n#    {'Arham': ['Green'],\n#     'Yasoob': ['Yellow', 'Red'],\n#     'Ahmed': ['Silver'],\n#     'Ali': ['Blue', 'Black']\n# })\n\n```\n\n\n另一种重要的是例子就是：当你在一个字典中对一个键进行嵌套赋值时，如果这个键不存在，会触发`keyError`异常。 `defaultdict`允许我们用一个聪明的方式绕过这个问题。 首先我分享一个使用`dict`触发`KeyError`的例子，然后提供一个使用`defaultdict`的解决方案。\n\n\n### 问题：\n\n\n```python\nsome_dict = {}\nsome_dict['colours']['favourite'] = \"yellow\"\n\n## 异常输出：KeyError: 'colours'\n\n```\n\n\n### 解决方案：\n\n\n```python\nimport collections\ntree = lambda: collections.defaultdict(tree)\nsome_dict = tree()\nsome_dict['colours']['favourite'] = \"yellow\"\n\n## 运行正常\n\n```\n\n\n你可以用json.dumps打印出some_dict，例如：\n\n\n```python\nimport json\nprint(json.dumps(some_dict))\n\n## 输出: {\"colours\": {\"favourite\": \"yellow\"}}\n\n```\n\n\n### counter\n\n\nCounter是一个计数器，它可以帮助我们针对某项数据进行计数。比如它可以用来计算每个人喜欢多少种颜色：\n\n\n```python\nfrom collections import Counter\n\ncolours = (\n    ('Yasoob', 'Yellow'),\n    ('Ali', 'Blue'),\n    ('Arham', 'Green'),\n    ('Ali', 'Black'),\n    ('Yasoob', 'Red'),\n    ('Ahmed', 'Silver'),\n)\n\nfavs = Counter(name for name, colour in colours)\nprint(favs)\n\n## 输出:\n## Counter({\n##     'Yasoob': 2,\n##     'Ali': 2,\n##     'Arham': 1,\n##     'Ahmed': 1\n##  })\n\n```\n\n\n我们也可以在利用它统计一个文件，例如：\n\n\n```python\nwith open('filename', 'rb') as f:\n    line_count = Counter(f)\nprint(line_count)\n\n```\n\n\n### deque\n\n\ndeque提供了一个双端队列，你可以从头/尾两端添加或删除元素。要想使用它，首先我们要从`collections`中导入`deque`模块，然后可以创建一个deque对象。它的用法就像python的list，并且提供了类似的方法，例如：\n\n\n```python\nfrom collections import deque\n\nd = deque()\nd.append('1')\nd.append('2')\nd.append('3')\n\nprint(len(d))\n\n## 输出: 3\n\nprint(d[0])\n\n## 输出: '1'\n\nprint(d[-1])\n\n## 输出: '3'\n\n```\n\n\n你可以从两端取出(pop)数据：\n\n\n```python\nd = deque(range(5))\nprint(len(d))\n\n## 输出: 5\n\nd.popleft()\n\n## 输出: 0\n\nd.pop()\n\n## 输出: 4\n\nprint(d)\n\n## 输出: deque([1, 2, 3])\n\n```\n\n\n我们也可以限制这个列表的大小，当超出你设定的限制时，数据会从对队列另一端被挤出去(pop)。\n\n\n```python\n# 现在当你插入30条数据时，最左边一端的数据将从队列中删除。\nd = deque(maxlen=30)\n\n# 你还可以从任一端扩展这个队列中的数据\nd = deque([1,2,3,4,5])\nd.extendleft([0])\nd.extend([6,7,8])\nprint(d)\n\n## 输出: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])\n\n```\n\n\n### namedtuple\n\n\n您可能已经熟悉元组。\n一个元组是一个不可变的列表，你可以存储一个数据的序列，它和命名元组(namedtuples)非常像，但有几个关键的不同。\n主要相似点是都不像列表，你不能修改元组中的数据。为了获取元组中的数据，你需要使用整数作为索引：\n\n\n```python\nman = ('Ali', 30)\nprint(man[0])\n\n## 输出: Ali\n\n```\n\n\n嗯，那`namedtuples`是什么呢？它把元组变成一个针对简单任务的容器。你不必使用整数索引来访问一个`namedtuples`的数据。你可以像字典(`dict`)一样访问`namedtuples`，但`namedtuples`是不可变的。\n\n\n```python\nfrom collections import namedtuple\n\nAnimal = namedtuple('Animal', 'name age type')\nperry = Animal(name=\"perry\", age=31, type=\"cat\")\n\nprint(perry)\n\n## 输出: Animal(name='perry', age=31, type='cat')\n\nprint(perry.name)\n\n## 输出: 'perry'\n\n```\n\n\n现在你可以看到，我们可以用名字来访问`namedtuple`中的数据。我们再继续分析它。一个命名元组(`namedtuple`)有两个必需的参数。它们是元组名称和字段名称。\n在上面的例子中，我们的元组名称是`Animal`，字段名称是'name'，'age'和'type'。\n`namedtuple`让你的元组变得**自文档**了。你只要看一眼就很容易理解代码是做什么的。\n你也不必使用整数索引来访问一个命名元组，这让你的代码更易于维护。\n而且，`namedtuple`**的每个实例没有对象字典**，所以它们很轻量，与普通的元组比，并不需要更多的内存。这使得它们比字典更快。\n\n\n然而，要记住它是一个元组，属性值在`namedtuple`中是不可变的，所以下面的代码不能工作：\n\n\n```python\nfrom collections import namedtuple\n\nAnimal = namedtuple('Animal', 'name age type')\nperry = Animal(name=\"perry\", age=31, type=\"cat\")\nperry.age = 42\n\n## 输出:\n## Traceback (most recent call last):\n##     File \"\", line 1, in\n## AttributeError: can't set attribute\n\n```\n\n\n你应该使用命名元组来让代码**自文档，它们向后兼容于普通的元组**，这意味着你可以既使用整数索引，也可以使用名称来访问`namedtuple`：\n\n\n```python\nfrom collections import namedtuple\n\nAnimal = namedtuple('Animal', 'name age type')\nperry = Animal(name=\"perry\", age=31, type=\"cat\")\nprint(perry[0])\n\n## 输出: perry\n```\n\n\n最后，你可以将一个命名元组转换为字典，方法如下：\n\n\n```python\nfrom collections import namedtuple\n\nAnimal = namedtuple('Animal', 'name age type')\nperry = Animal(name=\"Perry\", age=31, type=\"cat\")\nprint(perry._asdict())\n\n## 输出: OrderedDict([('name', 'Perry'), ('age', 31), ...\n```\n\n\n### enum.Enum (Python 3.4+)\n\n\n另一个有用的容器是枚举对象，它属于`enum`模块，存在于Python 3.4以上版本中（同时作为一个独立的PyPI包`enum34`供老版本使用）。Enums(枚举类型)基本上是一种组织各种东西的方式。\n让我们回顾一下上一个'Animal'命名元组的例子。\n它有一个type字段，问题是，type是一个字符串。\n那么问题来了，万一程序员输入了'Cat'，因为他按到了Shift键，或者输入了'CAT'，甚至'kitten'？\n枚举可以帮助我们避免这个问题，通过不使用字符串。考虑以下这个例子：\n\n\n```python\nfrom collections import namedtuple\nfrom enum import Enum\n\nclass Species(Enum):\n    cat = 1\n    dog = 2\n    horse = 3\n    aardvark = 4\n    butterfly = 5\n    owl = 6\n    platypus = 7\n    dragon = 8\n    unicorn = 9\n    # 依次类推\n\n    # 但我们并不想关心同一物种的年龄，所以我们可以使用一个别名\n    kitten = 1  # (译者注：幼小的猫咪)\n    puppy = 2   # (译者注：幼小的狗狗)\n\nAnimal = namedtuple('Animal', 'name age type')\nperry = Animal(name=\"Perry\", age=31, type=Species.cat)\ndrogon = Animal(name=\"Drogon\", age=4, type=Species.dragon)\ntom = Animal(name=\"Tom\", age=75, type=Species.cat)\ncharlie = Animal(name=\"Charlie\", age=2, type=Species.kitten)\n\n```\n\n\n现在，我们进行一些测试：\n\n\n```python\n>>> charlie.type == tom.type\nTrue\n>>> charlie.type\n<Species.cat: 1>\n```\n\n\n这样就没那么容易错误，我们必须更明确，而且我们应该只使用定义后的枚举类型。\n有三种方法访问枚举数据，例如以下方法都可以获取到'cat'的值：\n\n\n```python\nSpecies(1)\nSpecies['cat']\nSpecies.cat\n```\n\n",
      "properties": {
        "date": "2017-05-20",
        "type": "Post",
        "category": "Python",
        "slug": "collections-of-the-python-module",
        "tags": [],
        "title": "Python模块之Collections",
        "status": "Published",
        "urlname": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882",
        "updated": "2023-07-17 15:06:00"
      },
      "catalog": [
        {
          "title": "2017-05-20",
          "doc_id": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882"
        }
      ],
      "body": "",
      "realName": "Python模块之Collections",
      "relativePath": "/2017-05-20/Python模块之Collections.md"
    },
    {
      "id": "adf520da-d2ef-41b2-aa0a-de9c13c87721",
      "doc_id": "adf520da-d2ef-41b2-aa0a-de9c13c87721",
      "title": "adf520da-d2ef-41b2-aa0a-de9c13c87721",
      "updated": 1689577440000,
      "body_original": "\n### JavaScript的类型\n\n\n原始类型：\n\n- number\n- string\n- boolean\n- null\n- undefined\n\n对象类型：\n\n- Object\n\t- function\n\t- Array\n\t- Date\n\t- ...\n\n### 隐式转换\n\n\n### `+/-` 运算\n\n- \"37\" + 7 = \"377\"\n- \"37\" - 7 = 30\n\n### `==` 运算\n\n\n以下为true：\n\n- \"1.23\" == 1.23\n- 0 == false\n- null == undefined\n\n### 比较运算\n\n\n### `===`严格等于\n\n- 类型不同，返回false\n- 类型相同，以下为true：\n\t- null === null\n\t- undefine === null\n\t- NaN != NaN\n\t- new Object != new Obejct\n\n### `==`等于\n\n- 类型相同，同`===`\n- 类型不同，尝试类型转换比较\n\t- null == undefined\n\t- number == string 转number\n\t- boolean == ? 转number\n\t- Object == number | string 尝试对象转换为基本类型\n\t- 其他：false\n\n### 包装类型\n\n\n为了便于操作基本类型值，Js提供了基本类型的自动包装功能，每单读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，并在调用后自动销毁。\n\n\n由于基本包装类型和基本类型的含义并不一样，会导致typeof等操作产生不同的结果，不推荐显示实例化基本数据类型\n\n\n```javascript\nvar a = \"string\";\nalert(a.length);    //6\n\na.t = 3;\nalert(a.t);         //undefined\n```\n\n\n### 类型检测\n\n\n### typeof\n\n\n以下为true：\n\n\n```javascript\ntypeof 100 === “number”\ntypeof true === “boolean”\ntypeof function () {} === “function”\ntypeof(undefined) ) === “undefined”\ntypeof(new Object() ) === “object”\ntypeof( [1， 2] ) === “object”\ntypeof(NaN ) === “number”   //NaN也为number\ntypeof(null) === “object”\n```\n\n\n### instanceof\n\n\n`obj instanceof Object`  利用原型链进行判断，适用于对象间判断。它期望左边是一对象，右边是函数对象或函数构造器。\n\n\n以下为true：\n\n\n```javascript\n[1, 2] instanceof Array === true\nnew Object() instanceof Array === false\n```\n\n\n### Object.prototype.toString.apply()\n\n\n```javascript\nObject.prototype.toString.apply([]); === “[object Array]”;\nObject.prototype.toString.apply(function(){}); === “[object Function]”;\nObject.prototype.toString.apply(null); === “[object Null]”\nObject.prototype.toString.apply(undefined); === “[object Undefined]”\n\n// IE6/7/8 Object.prototype.toString.apply(null) 返回”[object Object]”\n```\n\n\n### 小结\n\n- typeof\n适合基本类型及function检测，遇到null失效。\n- [[Class]]\n通过{}.toString拿到，适合内置对象和基元类型，遇到null和undefined失效(IE678等返回[object Object])。\n- instanceof\n适合自定义对象，也可以用来检测原生对象，在不同iframe和window间检测时失效。\n",
      "properties": {
        "date": "2017-06-02",
        "type": "Post",
        "category": "JavaScript",
        "slug": "javascript-type-comparison",
        "tags": [],
        "title": "JavaScript类型比较",
        "status": "Published",
        "urlname": "adf520da-d2ef-41b2-aa0a-de9c13c87721",
        "updated": "2023-07-17 15:04:00"
      },
      "catalog": [
        {
          "title": "2017-06-02",
          "doc_id": "adf520da-d2ef-41b2-aa0a-de9c13c87721"
        }
      ],
      "body": "",
      "realName": "JavaScript类型比较",
      "relativePath": "/2017-06-02/JavaScript类型比较.md"
    },
    {
      "id": "8810277f-eb6e-41cc-9ff1-022d45838b09",
      "doc_id": "8810277f-eb6e-41cc-9ff1-022d45838b09",
      "title": "8810277f-eb6e-41cc-9ff1-022d45838b09",
      "updated": 1689577380000,
      "body_original": "\n### 闭包的概念\n\n\n维基百科中是这么解释闭包的：\n\n- 计算机科学中，闭包(也称为词法闭包或函数闭包)是指一个函数或函数的引用，与一个引用环境绑定在一起。这个函数环境是一个存储该函数每个非局部变量(也叫自由变量)的表。\n- 闭包，不同意一般函数，它允许一个函数在立即词法作用域外调用时，认可访问非本地变量。\n\n### 闭包的例子\n\n\n### 使用闭包\n\n\n```javascript\nfunction outer() {\n    var localVal = 30;\n    return function() {\n        return localVal;\n    }\n}\n\nvar func = outer();\nfunc();\n```\n\n\nouter函数调用结束后，func函数仍能访问外层的局部变量，即为闭包。\n\n\n应用闭包，在前端编程中添加点击事件:\n\n\n```javascript\n!function() {\n    var localData = \"localData here\";\n    document.addEventListener('click', \n        function(){\n            console.log(localData);\n        });\n}();\n```\n\n\n### 循环闭包错误\n\n\n```javascript\ndocument.body.innerHTML = \"<div id=div1>aaa</div>\"\n    + \"<div id=div2>bbb</div><div id=div3>ccc</div>\";\nfor(var i=1; i<4; i++) {\n    document.getElementById('div' + i).\n        addEventListener('click', function() {\n            alert(i);   // all are 4!\n        }\n}\n```\n\n\n因为i在发生点击事件时才会访问，以上例子中，全部点击事件均会提示4。\n\n\n解决办法：\n\n\n```javascript\ndocument.body.innerHTML = \"<div id=div1>aaa</div>\"\n    + \"<div id=div2>bbb</div><div id=div3>ccc</div>\";\nfor(var i=1; i<4; i++) {\n    !function(i) {\n        document.getElementById('div' + i).\n            addEventListener('click', function() {\n                alert(i);   // all are 4!\n            }\n    }(i)\n}\n```\n\n",
      "properties": {
        "date": "2017-06-24",
        "type": "Post",
        "category": "JavaScript",
        "slug": "the-basic-concept-of-javascript-closure",
        "tags": [],
        "title": "JavaScript闭包基本概念",
        "status": "Published",
        "urlname": "8810277f-eb6e-41cc-9ff1-022d45838b09",
        "updated": "2023-07-17 15:03:00"
      },
      "catalog": [
        {
          "title": "2017-06-24",
          "doc_id": "8810277f-eb6e-41cc-9ff1-022d45838b09"
        }
      ],
      "body": "",
      "realName": "JavaScript闭包基本概念",
      "relativePath": "/2017-06-24/JavaScript闭包基本概念.md"
    },
    {
      "id": "206a23f7-dc7b-42cb-bff8-fe5cae67b860",
      "doc_id": "206a23f7-dc7b-42cb-bff8-fe5cae67b860",
      "title": "206a23f7-dc7b-42cb-bff8-fe5cae67b860",
      "updated": 1689577260000,
      "body_original": "\n| 函数声明 | 函数表达式 | 函数构造器\n---|---|---|---|\n前置 | 是 | |\n允许匿名 | | 是 | 是\n可立即调用 | | 是 | 是\n在定义该函数的作用域通过函数名访问 | 是 | |\n没有函数名 | | | 是\n\n\n### JavaScript 特点\n\n\n### 函数\n\n- js函数的参数并不会验证传递进来多少个参数, 也不会在乎传进来的参数是什么数据类型, 在函数体内可以用arguments对象来访问这个参数数组.\n- arguments对象中的值会与命名参数的值同步修改, 即修改arguments值时会同步修改参数的值, 反之亦然.\n- js中函数没有重载\n- Js中每个函数都是Function类型的实例，因而与其他引用类型一样具有属性和方法。\n- 函数内部有两个特殊对象arguments和this\n\t- arguments.callee 指向拥有这个arguments对象的函数。可用于消除与函数名的紧耦合\n\t- arguments.caller 保存着调用当前函数的函数的引用\n\t- this 对象引用的是函数据以执行的环境对象\n- 函数中包含两个属性length和prototype\n\t- length 表示函数希望接收的命名参数个数\n\t- prototype 保存函数所有实例方法的真正所在，例如toString()和valueOf()等\n- 每个函数包含的方法：`apply()`、`call()`和`bind()`\n\n```javascript\nfunction factorial(num) {\n    if (num <= 1) {\n        return 1;\n    } else {\n        return num * arguments.callee(num - 1); //factorial(num -1)\n    }\n}\n\n```\n\n\n```javascript\nfunction outer() {\n    inner();\n}\nfunction inner() {\n    alert(inner.caller);\n}\n\nouter(); //在警告窗中显示outer()的源代码\n\n```\n\n\n```javascript\nwindow.color = \"red\";\nvar o = {color: \"blue\"};\n\nfunction sayColor() {\n    alert(this.color);\n}\n\nsayColor()； //red\n\no.sayColor = sayColor;\no.sayColor(); //blue\n\n```\n\n\n### JavaScript 的变量和作用域\n\n- 基本类型的复制是完全独立的复制值复制, 引用类型的复制实际上是复制的一份指针.\n- js中所有函数的参数都是按值传递, 基本类型传递如同基本类型变量复制一样, 引用类型传递如同引用变量复制一样.\n- try-catch语句的catch快和with语句会延长作用域链\n- js中没有块级作用域, for/if花括号中定义的变量在花括号外也可访问.\n\n### 引用变量\n\n- Js中面向对象未实现面向对象的类和接口等基本结构，一般称为引用类型或对象定义。\n- 访问对象的属性除了通用的`.`，还可使用`[]`，从而通过变量来访问对象属性。\n- 为了便于操作基本类型值，Js提供了基本类型的自动包装功能，每单读取一个基本类型值的时候，后台就会创建一个对应的基本包装类型的对象，并在调用后自动销毁。\n- 由于基本包装类型和基本类型的含义并不一样，会导致typeof等操作产生不同的结果，不推荐显示实例化基本数据类型\n\n### 函数的调用\n\n- 直接调用 foo();\n- 对象方法 o.method();\n- 构造器 new Function();\n- call/apply/bind func.call(o);\n\n### 函数声明和表达式\n\n\n函数声明会被前置，函数表达式变量声明会被前置，但是值为`undefined`。\n\n\n### 函数声明\n\n\n```javascript\nfunction func(a, b) {\n    //do sth\n}\n```\n\n\n### 函数表达式\n\n- 将函数赋值给一个变量\n\n```javascript\nvar func = function(a, b) {\n    //do sth\n};\n```\n\n- 匿名函数(IEF 立即执行函数表达式)\n\n```javascript\n(function() {\n    //do sth\n})();\n```\n\n- 返回函数对象\n\n```javascript\nreturn function() {\n    //do sth\n};\n```\n\n- 命名函数表达式(NEF)\n\n```javascript\nvar add = function foo(a, b) {\n    //do sth\n};\n```\n\n\n命名函数表达式存在一些经典的bug，例如在执行如下代码时：\n\n\n```javascript\nvar func = function nfe() {};\nalert(func == nfe);\n```\n\n\nIE6会提示为`false`，IE9+中nfe外部并不可见，提示为`nfe is undefined`。\n\n\n命名函数表达式主要可以应用在调试和递归调用时。\n\n\n```javascript\nvar func = funtion nfe(){/* do sth */ nfe();};\n```\n\n\n但也可直接通过`func`变量名来执行递归调用，因此命名函数表达式并不常用。\n\n\n### function构造器\n\n\n```javascript\nvar func = new Function('a', 'b', 'console.log(a + b);');\nfunc(1, 2); //3\n\nvar func = Function('a', 'b', 'console.log(a + b);');\nfunc(1, 2)  //3\n```\n\n\n### function构造器的作用域\n\n\n```javascript\nFunction('var localVal = \"local\"; console.log(localVal);')();\nconsole.log(typeof localVal);\n// result: local, undefined\n// localVal仍未局部变量\n\nvar globalVal = 'global';\n(function() {\n    var localVal = 'local';\n    Function('console.log(typeof localVal, typeof globalVal);')();\n})();\n//result: undefined, string\n//local不可访问，全局变量global可以访问\n```\n\n\n### 各方式对比\n\n\n|                   | 函数声明 | 函数表达式 | 函数构造器 |\n| ----------------- | ---- | ----- | ----- |\n| 前置                | 是    |       |       |\n| 允许匿名              |      | 是     | 是     |\n| 可立即调用             |      | 是     | 是     |\n| 在定义该函数的作用域通过函数名访问 | 是    |       |       |\n| 没有函数名             |      |       | 是     |\n\n\n### this\n\n\n### 全局的this\n\n\n全局的this一般即是浏览器\n\n\n```javascript\nconsole.log(this.document === document); //true\nconsloe.loh(this == window);    //true\n\nthis.a = 37\nconsole.log(window.a);  //37\n```\n\n\n### 一般函数的this\n\n\n一般函数的this仍然指向全局对象，浏览器中即为window\n\n\n```javascript\nfucntion f1(){\n    return this;\n}\n\nf1() === window;    //true, global, object\n```\n\n\n严格模式下，this指向undefined\n\n\n```javascript\nfucntion f2(){\n    \"use strict\";\n    return this;\n}\n\nf2() === undefined; //true\n```\n\n\n### 作为对象方法的函数this\n\n\n对象方法中的函数this会指向具体的对象\n\n\n```javascript\nvar o = {\n    prop: 37;\n    f: function() {\n        return this.prop;\n    }\n};\n\nconsole.log(o.f()); //logs 37\n```\n\n\n也可以通过外部定义函数\n\n\n```javascript\nvar o = {prop: 37};\nfunction independent() {\n    return this.prop;\n}\n\no.f = independent\nconsole.log(o.f()); //logs 37\n```\n\n\n### 通过`call`和`apply`调用指定this\n\n\n```javascript\nfunction add(c, d) {\n    return this.a + this.b + c + d;\n}\n\nvar o = {a:1, b:3};\n\nadd.call(o, 5, 7);  // 1 + 3 + 5 + 7 = 16 \nadd.apply(o, [10, 20]); //1 + 3 + 10 + 20 = 34\n\n\nfunction bar() {\n    console.log(Object.prototype.toString.call(this));\n}\n\nbar.call(7);    //\"[object Number]\"\n```\n\n\n一般模式和严格模式下使用`apply`的区别\n\n\n```javascript\nfunction foo(x, y) {\n    console.log(x, y, this);\n}\n\nfoo.apply(null);    // undefined, undefined, window\nfoo.apply(undefined);    // undefined, undefined, window\n\n// 严格模式下\nfoo.apply(null);    // undefined, undefined, null\nfoo.apply(undefined);    // undefined, undefined, undefined\n```\n\n\n### 'bind'方法与this\n\n\n通过ES5提供的bind方法，可以将函数的this绑定到一个对象上，bind之后this不可变。\n\n\n```javascript\nfunction f(){\n    return this.a\n}\n\nvar g = f.bind({a: \"test\"}):\nconsole.log(g());   //test\n\nvar o = {a: 37, f:f, g:g};\n// g()中的this不会再改变\nconsole.log(o.f(), o.g());  //37, test\n```\n\n\n### 函数属性和对象\n\n\n```javascript\nfunction foo(x, y, z) {\n    \n    arguments.length;   //2\n    arguments[0];   //1\n    arguments[0] = 10;\n    x;  // change to 10; 严格模式下仍然是1\n    \n    arguments[2] = 100;\n    z;  // still undefined !!!\n    arguments.callee === foo;   // true 严格模式下不能使用\n}\n\nfoo(1, 2)\nfoo.length;     // 3\nfoo.name;       // \"foo\"\n```\n\n\n使用`bind()`方法currying函数\n\n\n```javascript\nfunction add(a, b, c) {\n    return a + b + c;\n}\n\nvar func = add.bind(undefined, 100);\nfunc(1, 2); // 100绑定到a上，result：103\n\nvar func2 = func.bind(undefoned, 200);\nfunc2(10);  // 200绑定到b上，result：310\n```\n\n\nbind和new的使用\n\n\n```javascript\nfunction foo() {\n    this.b =100;\n    return this.a;\n}\n\nvar func = foo.bind({a:1});\n\nfunc(); // 1\n// 使用new时，除非指定返回一个对象，否则会返回this，\n// 同时this会被初始化为一个空对象的prototype\nnew func(); //{b: 100}\n```\n\n",
      "properties": {
        "date": "2017-06-24",
        "type": "Post",
        "category": "JavaScript",
        "slug": "javascript-function",
        "tags": [],
        "title": "JavaScript 函数",
        "status": "Published",
        "urlname": "206a23f7-dc7b-42cb-bff8-fe5cae67b860",
        "updated": "2023-07-17 15:01:00"
      },
      "catalog": [
        {
          "title": "2017-06-24",
          "doc_id": "206a23f7-dc7b-42cb-bff8-fe5cae67b860"
        }
      ],
      "body": "",
      "realName": "JavaScript 函数",
      "relativePath": "/2017-06-24/JavaScript 函数.md"
    },
    {
      "id": "a829aa8b-4b63-4436-ad5c-d3d5b121b896",
      "doc_id": "a829aa8b-4b63-4436-ad5c-d3d5b121b896",
      "title": "a829aa8b-4b63-4436-ad5c-d3d5b121b896",
      "updated": 1689576480000,
      "body_original": "\n### Java IO的一些基础知识：\n\n\n![Java IO](https://darkreunion-1256611153.file.myqcloud.com/17-6-24/56653106.jpg)\n\n\n导图源文件保存地址：https://github.com/wanghaoxi3000/xmind\n\n",
      "properties": {
        "date": "2017-06-24",
        "type": "Post",
        "category": "Java",
        "slug": "java-io-learning-point-guide",
        "tags": [],
        "title": "Java IO学习要点导图",
        "status": "Published",
        "urlname": "a829aa8b-4b63-4436-ad5c-d3d5b121b896",
        "updated": "2023-07-17 14:48:00"
      },
      "catalog": [
        {
          "title": "2017-06-24",
          "doc_id": "a829aa8b-4b63-4436-ad5c-d3d5b121b896"
        }
      ],
      "body": "",
      "realName": "Java IO学习要点导图",
      "relativePath": "/2017-06-24/Java IO学习要点导图.md"
    },
    {
      "id": "78e26026-8b45-4f5a-8cbf-9426d45f4224",
      "doc_id": "78e26026-8b45-4f5a-8cbf-9426d45f4224",
      "title": "78e26026-8b45-4f5a-8cbf-9426d45f4224",
      "updated": 1689576420000,
      "body_original": "\n### Class对象相关知识导图：\n\n\n![Java Class对象](https://darkreunion-1256611153.file.myqcloud.com/17-5-16/79733900-file_1494947788433_83c2.png)\n\n\n导图源文件保存地址：https://github.com/wanghaoxi3000/xmind\n\n",
      "properties": {
        "date": "2017-06-24",
        "type": "Post",
        "category": "Java",
        "slug": "the-class-object-of-the-thinking-mapping-java",
        "tags": [],
        "title": "思维导图学Java之Class对象",
        "status": "Published",
        "urlname": "78e26026-8b45-4f5a-8cbf-9426d45f4224",
        "updated": "2023-07-17 14:47:00"
      },
      "catalog": [
        {
          "title": "2017-06-24",
          "doc_id": "78e26026-8b45-4f5a-8cbf-9426d45f4224"
        }
      ],
      "body": "",
      "realName": "思维导图学Java之Class对象",
      "relativePath": "/2017-06-24/思维导图学Java之Class对象.md"
    },
    {
      "id": "f591f5a7-df0d-4077-a51e-615be25c7d01",
      "doc_id": "f591f5a7-df0d-4077-a51e-615be25c7d01",
      "title": "f591f5a7-df0d-4077-a51e-615be25c7d01",
      "updated": 1689576420000,
      "body_original": "\nES6 强制开启严格模式\n\n\n### 作用域\n\n- var 声明局部变量，for/if花括号中定义的变量在花括号外也可访问\n- let 声明的变量为块作用域，变量不可重复定义\n- const 声明常量，块作用域，声明时必须赋值，不可修改\n\n```javascript\n// const声明的k指向一个对象，k本身不可变，但对象可变\n\nfunction test() {\n    const k={\n        a:1\n    }\n    k.b=3;\n    \n    console.log(k);\n}\n\ntest()\n\n```\n\n\n### 解构赋值\n\n\n```javascript\n{\n    let a, b, 3, rest;\n    [a, b, c=3]=[1, 2];\n\n    console.log(a, b);\n}\n//output: 1 2 3\n\n{\n    let a, b, 3, rest;\n    [a, b, c]=[1, 2];\n\n    console.log(a, b);\n}\n//output: 1 2 undefined\n\n{\n    let a, b, rest;\n    [a, b, ...rest] = [1, 2, 3, 4, 5, 6];\n    console.log(a, b, rest);\n}\n//output:1 2 [3, 4, 5, 6]\n\n{\n    let a, b;\n    ({a, b} = {a:1, b:2})\n\n    console.log(a ,b);\n}\n//output: 1 2\n\n```\n\n\n### 使用场景\n\n\n### 变量交换\n\n\n```javascript\n{\n    let a = 1;\n    let b = 2;\n    [a, b] = [b, a];\n    console.log(a, b);\n}\n\n```\n\n\n### 获取多个函数值\n\n\n```javascript\n{\n    function f(){\n        return [1, 2]\n    }\n    let a, b;\n    [a, b] = f();\n    console.log(a, b);\n}\n\n```\n\n\n### 获取多个函数返回值\n\n\n```javascript\n{\n    function f(){\n        return [1, 2, 3, 4, 5]\n    }\n    let a, b, c;\n    [a,,,b] = f();\n    console.log(a, b);\n}\n//output: 1 4\n\n{\n    function f(){\n        return [1, 2, 3, 4, 5]\n    }\n    let a, b, c;\n    [a, ...b] = f();\n    console.log(a, b);\n}\n//output: 1 [2, 3, 4, 5]\n\n```\n\n\n### 对象解构赋值\n\n\n```javascript\n{\n    let o={p:42, q:true};\n    let {p, q, c=5} = o;\n\n    console.log(p ,q);\n}\n//output: 42 true 5\n\n```\n\n\n### 获取json值\n\n\n```javascript\n{\n    let metaData={\n        title: 'abc',\n        test: [{\n            title: 'test',\n            desc: 'description'\n        }]\n    }\n    let {title:esTitle, test:[{title:cnTitle}]} = metaData;\n    console.log(esTitle, cnTitle);\n}\n//Output: abc test\n\n```\n\n",
      "properties": {
        "date": "2017-07-12",
        "type": "Post",
        "category": "JavaScript",
        "slug": "es6-scope-and-deconstruction-assignment",
        "tags": [],
        "title": "ES6作用域和解构赋值",
        "status": "Published",
        "urlname": "f591f5a7-df0d-4077-a51e-615be25c7d01",
        "updated": "2023-07-17 14:47:00"
      },
      "catalog": [
        {
          "title": "2017-07-12",
          "doc_id": "f591f5a7-df0d-4077-a51e-615be25c7d01"
        }
      ],
      "body": "",
      "realName": "ES6作用域和解构赋值",
      "relativePath": "/2017-07-12/ES6作用域和解构赋值.md"
    },
    {
      "id": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356",
      "doc_id": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356",
      "title": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356",
      "updated": 1689576300000,
      "body_original": "\n读完了<大话设计模式>这本书，收获很多，对程序设计有了很多新的理解。将每章模式的大概要点做了些笔记以备查阅，一些设计模式书读完也对其了解得不是很透彻，需要以后在实践中来不断地加深理解吧。读书过程中用Java跟着实践了些部分模式的代码上传到了[https://github.com/wanghaoxi3000/development/tree/master/Java/JavaSE/DesignPatterns](https://github.com/wanghaoxi3000/development/tree/master/Java/JavaSE/DesignPatterns)。\n\n\n## 设计模式\n\n\n### 简单工厂模式\n\n\n简单工厂模式是属于创建型模式，又叫做静态工厂方法(Static Factory Method)模式，但不属于23种GOF设计模式之一。简单工厂模式是由一个工厂对象决定创建出哪一种产品类的实例。简单工厂模式是工厂模式家族中最简单实用的模式，可以理解为是不同工厂模式的一个特殊实现。\n\n\n### UML图\n\n\n![](http://i1.piimg.com/567571/342fa006602e030c.jpg)\n\n\n### 策略模式\n\n\n策略模式定义了算法家族，分别封装起来，让他们之间可以相互替换，此模式让算法的变化，不会影响到使用算法的客户。\n\n\n### UML图\n\n\n![](http://i1.piimg.com/567571/6f9db76e4824ae39.jpg)\n\n\n### 装饰模式\n\n\n动态地给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。\n装饰模式是为已有功能动态地添加更多功能的一种方式。当系统需要新功能的时候，是向旧的类添加新的代码。这些新的代码通常创世了原有类的核心职责或主要行为。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-8/8377678-file_1486565861206_19f8.jpg)\n\n\n### 代理模式\n\n\n为其他对象提供一种代理以控制这个对象的访问。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-9/92171920-file_1486650866717_6364.jpg)\n\n\n### 代理模式的应用\n\n- 远程代理：为一个对象在不同的地址空间提供局部代表。这样可以隐藏一个对象存在于不同地址空间的事实。\n- 虚拟代理：根据需要创建开销很大的对象。通过它来实例化需要很长时间的真实对象。\n- 安全代理：用来控制真实对象访问时的权限。\n- 智能指引：当调用真实对象时，代理处理另外一些事。如在访问一个实际对象前，检查是否已经锁定它，以确保其他对象不能改变它。\n\n### 工厂方法模式\n\n\n定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使一个类的实例化延迟到子类。\n\n\n### 结构图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-13/9740823-file_1486998763751_c368.jpg)\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-13/93238423-file_1486998853694_de36.jpg)\n\n\n### 简单工厂与工厂方法的对比\n\n\n简单工厂模式的最大优点在于工厂类中包含了必要的逻辑判断，根据客户端的选择条件动态实例化相关的类，对客户端来说，去除了与具体产品的依赖。但新增功能时，需要修改原有的类。不但对扩展开放了，对修改也开放了，违背了开放-封闭原则。\n\n\n工厂方法模式实现时，客户端需要决定实例化哪一个工厂来实现运算类，选择判断的问题还是存在的，也就是说，工厂方法把简单工厂内部的判断逻辑移到了客户端代码来进行。\n\n\n### 原型模式\n\n\n用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象\n\n\n### UML图\n\n\n原型模式其实就是从一个对象创建另外一个可定制的对象，而且不需要知道任何创建的细节。\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-15/49197500-file_1487172193983_fda.png)\n\n\n### Java提供的克隆接口\n\n\nJava的所有类都是从java.lang.Object类继承而来的，而Object类提供protected Object clone()方法对对象进行复制，子类当然也可以把这个方法置换掉，提供满足自己需要的复制方法。对象的复制有一个基本问题，就是对象通常都有对其他的对象的引用。当使用Object类的clone()方法来复制一个对象时，此对象对其他对象的引用也同时会被复制一份\n\n\nJava语言提供的Cloneable接口只起一个作用，就是在运行时期通知Java虚拟机可以安全地在这个类上使用clone()方法。通过调用这个clone()方法可以得到一个对象的复制。由于Object类本身并不实现Cloneable接口，因此如果所考虑的类没有实现Cloneable接口时，调用clone()方法会抛出CloneNotSupportedException异常。\n\n\n### 浅克隆和深克隆\n\n\n无论你是自己实现克隆方法，还是采用Java提供的克隆方法，都存在一个浅度克隆和深度克隆的问题。\n\n- 浅度克隆：只负责克隆按值传递的数据（比如基本数据类型、String类型），而不复制它所引用的对象，换言之，所有的对其他对象的引用都仍然指向原来的对象。\n- 深度克隆：除了浅度克隆要克隆的值外，还负责克隆引用类型的数据。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深度克隆把要复制的对象所引用的对象都复制了一遍，而这种对被引用到的对象的复制叫做间接复制。\n\n深度克隆要深入到多少层，是一个不易确定的问题。在决定以深度克隆的方式复制一个对象的时候，必须决定对间接复制的对象时采取浅度克隆还是继续采用深度克隆。因此，在采取深度克隆时，需要决定多深才算深。此外，在深度克隆的过程中，很可能会出现循环引用的问题，必须小心处理。\n\n\n### 模板方法模式\n\n\n定义一个操作中的算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以不改变一个算法结构即可重定义该算法的的某些特定步骤\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-18/43410512-file_1487403841716_10bba.jpg)\n\n\n### 特点\n\n\n模板方法模式是通过把不变的行为搬移到超类，去除子类中的重复代码来体现它的优势。当不变的和可变的行为在方法的子类实现中混合在一起的时候，不变的行为就会在子类中重复出现，我们通过模板模式把这些行为搬到单一的地方，这样就帮助子类摆脱重复的不变行为的纠缠。\n\n\n### 外观模式\n\n\n为子系统的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使这一子系统更加容易使用。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-23/49752568-file_1487781841158_8e75.png)\n\n\n### 何时使用外观模式\n\n1. 在设计初期阶段，应该要有意识的将不同的两个层分离，层与层之间建立Facade\n2. 在开发阶段，子系统往往因为不断重构演化而变得越来越复杂，增加外观Facade可以提供一个简单的接口，减少他们之间的依赖\n3. 维护一个遗留的大型系统时，可能这个系统已经非常难以维护和扩展了，可以为新系统开发一个外观Facade类，让新系统与Facade对象交互，Facade与遗留代码交互完成所有复杂的工作\n\n### 建造者模式\n\n\n建造者模式是在当创建复杂对象的算法应该独立于该对象的组成部分以及它们的装配方式时适用的模式。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-2-26/86119743-file_1488039058164_17394.jpg)\n\n\n### 何时使用建造者模式\n\n\n建造者模式主要用于创建一些复杂的对象，这些对象内部构建间的构造顺序通常是稳定的，但对象内部的构建通常面临着复杂的变化。\n建造者模式使得建造代码与表示代码分离，由于建造者隐藏了该产品是如何组装的，所以需要改变一个产品的内部表示，只需要再定义一个具体的建造者就可以了。\n\n\n### 观察者模式\n\n\n观察者模式又称之为发布-订阅模式，定义了一种一对多的依赖关系，让多个观察者对象同时监听一个主题对象。这个主题对象在状态发生变化时，会通知所有观察者对象，使它们能够自动更新自己。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-7/70140053-file_1488818019349_17715.png)\n\n\n### 观察者模式的特点\n\n\n将一个系统分割成一系列相互协作的类有一个很不好的副作用，需要维护相关对象间的一致性。我们不希望为了维持一致性而使各类紧密耦合，这样会给维护，扩展和重用都带来不便。当一个对象的改变需要同时改变其他对象，而且它不知道具体有多少对象待改变时，应该考虑使用观察者模式。\n一个抽象模型有两个方面，其中一方面依赖于另一方面，这时使用观察者模式可以将这两者封装在独立的对象中使它们各自独立的改变和复用。\n观察者模式所做的工作其实就是在解除耦合。让耦合的双方都依赖于抽象，而不是依赖于具体。从而使各自的变化都不会影响另一边的变化。\n\n\n### 观察者模式的不足与事件委托\n\n\n观察者模式需要观察者具体类们实现一个通用的通知方法时，当各个观察者无法实现这个通用的通知方法或通知方法不同名时，可使用事件委托，让客户端来指定具体的通知方法。\n\n\n### 抽象工厂模式\n\n\n提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。\n\n\n### UML图\n\n\nAbstractProductA和AbstractProductB是两个抽象产品，ProductA1、ProductA2和ProductB1、ProductB2就是对两个抽象产品的具体分类实现。\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-9/91447544-file_1488992208574_d75a.png)\n\n\nIFactory是一个抽象工厂接口，它里面应该包含所有产品创建的抽象方法。ConcreteFactory1和ConcreteFactory2就是具体的工厂了。\n\n\n通常在运行时再创建一个ConcreteFactory类的实例，这个具体的工厂再创建具有特定实现的产品对象，也就是说，为创建不同的产品对象，客户端应使用不同的具体工厂。\n\n\n### 抽象工厂的优缺点\n\n\n**优点：**\n\n- 具体工厂类在一个应用中只需要初始化时出现一次这就使得改变一个应用的具体工厂变得非常容易\n- 它让具体的创建实例过程与客户端分离，客户端是通过它们的抽象接口操作实例，产品的具体类名也被具体工厂实现分离，不会出现在客户代码中\n\n**缺点：**\n\n- 增加功能时需要改动和增加的类较多\n- 客户端程序切换不同工厂时改动较多\n\n### 状态模式\n\n\n当一个对象的内在状态改变时允许改变其行为，这个对象看起来像是改变了其类。\n\n\n状态模式主要解决的是控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的判断逻辑简化。当然，如果这个判断逻辑很简单，那就没必要用‘状态模式’了。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-18/89604437-file_1489802994820_24a8.png)\n\n\n### 状态模式的好处与用处\n\n\n状态模式的好处是将与特定状态的相关行为局部化，并且将不同的行为分割开来。\n通过将特定的状态相关行为都放入一个对象中，由于所有与状态相关的代码都存于某个ConcreteState中，所以通过定义新的子类可以很容易的增加新的状态和转换。从而消除庞大的条件分支语句。\n\n\n状态模式同个把各种状态转移逻辑分布到State子类之间，来减少相互之间的依赖，当一个对象的行为取决它的状态，并且它必须在运行时刻根据状态改变它的行为时，就可以考虑使用状态模式了。\n\n\n### 适配器模式\n\n\n将一个类的接口转换成客户希望的另外一个接口。Adapter模式使得由于接口不兼容而不能一起工作的那些类可以一起工作。\n\n\n在软件开发中，系统的数据和行为都正确，但接口不符时，应该考虑用适配器。使控制范围之外的一个原有对象与某个接口匹配。适配器主要应用于希望复用一些现存的类，但是接口又与复用环境要求不一致的情况。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-20/2923805-file_1490022256181_1368.jpg)\n\n\n### 慎用适配器模式\n\n\n当两个类所做的事情相同或相似，但是具有不同的接口时要使用它。但应在双方都不太容易修改的时候再使用适配器模式。尽量使用统一调用同一接口使得更为简单紧凑。\n\n\n### 备忘录模式\n\n\n在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样以后就可将该对象恢复到原先保存的状态。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-22/85458261-file_1490197244794_4953.jpg)\n\n\n### 适用场合\n\n\n备忘录模式比较适用于功能比较复杂的，但需要维护或记录属性历史的类，或者需要保存的属性只是众多属性中的一小部分时。使用备忘录可以把复杂的对象内部信息屏蔽起来。\n\n\n### 组合模式\n\n\n将对象组合成树形结构以表示‘部分-整体’的层次结构。组合模式将使得对象对单个用户对单个对象和组合对象的使用具有一致性。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-23/63542611-file_1490282545343_104a5.jpg)\n\n\n### 适用场合\n\n\n当需求中是体现部分与整体的层次结构时，以及希望用户可以忽略组合对象与单个对象的不同，统一地使用组合结构中的所有对象时，就应该考虑组合模式了。通过组合模式可以一致地使用组合结构和单个对象。\n\n\n### 迭代器模式\n\n\n提供一种方法顺序访问一个聚合对象中的各个元素，而又不暴露该对象的内部表示。\n当需要访问一个聚集对象，而且不管这些对象是什么都需要遍历的时候，此时就应该考虑迭代器模式。\n当需要对聚集对象进行多种方式遍历时，也可以考虑迭代器模式。\n即为遍历不同的聚集结构提供如开始、下一个、是否结束、当前哪一项等统一接口。\n\n\n迭代器模式分离了集合对象的遍历行为，抽象出一个迭代器类来负责，这样既可以做到不暴露集合内部结构，又可以让外部代码透明地访问集合内部数据。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-3-28/23599907-file_1490634458520_80f4.jpg)\n\n\n### 单例模式\n\n\n保证一个类仅有一个实例，并提供一个访问它的全局访问点。\n通常我们可以让一个全局变量通过一个对象被访问，但它不能防止你实例化多个对象。一个最好的办法就是，让类的自身负责保存它唯一的实例。这个类可以保证没有其他实例可以被创建，并且提供一个访问该实例的方法。\n\n\n### UML图\n\n\n![](http://i2.muimg.com/567571/546afb5b1f8d095d.jpg)\n\n\n### 桥接模式\n\n\n将抽象部分与它的实现部分分离,使它们都可以独立地变化。\n抽象与它的实现分离，这并不是说，让抽象类与其派生类分离，因为这没有任何意义。实现指的是抽象类和它的派生类用来实现自己的对象。\n\n\n### UML图\n\n\n![](http://i1.piimg.com/567571/4371f05916125f0a.jpg)\n\n\n### 命令模式\n\n\n将一个请求封装为一个对象，从而使你可以用不同的请求对客户进行参数化，对请求派对或记录请求日志，以及支持可撤销的操作。\n\n\n### UML图\n\n\n![](http://i2.muimg.com/567571/192d3c61039a64fd.jpg)\n\n\n### 命令模式作用\n\n1. 可以比较容易设计一个命令队列\n2. 在需要的情况下，可以较容易地将命令记入日志\n3. 允许接收请求的一方决定是否要否决请求\n4. 可以容易的实现对请求的撤销和重做\n5. 由于加进新的具体命令类不影响其他的类，因此增加新的具体命令类就很容易\n\n### 职责链模式\n\n\n使多个对象都有机会处理请求，从而避免请求的发送者和接受者之间的耦合关系。将这个对象连成一条链，并沿着这条链传递该请求，直到一个对象处理它为止。\n\n\n### UML图\n\n\n![](http://i1.piimg.com/567571/7013d340ec10ee9c.jpg)\n\n\n### 职责链的优点\n\n\n职责链模式使得接收者和发送者都没有对方的明确信息，而且链中的对象自己也并不知道链的结构。结构是职责链可简化对象的相互连接，它们仅需保持一个指向后继者的引用，而不保持它所有的候选接受者的相互连接，它们仅需保持一个指向其后继者的引用，而不需保持它所有的候选者的引用。\n\n\n### 中介者模式\n\n\n用一个中介对象来封装一系列的对象交互。中介者使各对象不需要显式地相互引用，从而使其耦合松散，而且可以独立的改变它们之间的交互。\n\n\n![](http://i2.muimg.com/567571/762bbf433c637f20.jpg)\n\n\n### 享元模式\n\n\n运用共享技术有效的支持大量细粒度的对象。享元模式可以避免大量非常相似的开销。在程序设计中，有时需要生成大量细粒度的类实例来显示数据。如果发现这些实例除了几个参数外基本都是相同的，有时就能够大幅度地减少需要实例化的类数量。如果把那些参数移到类实例的外面，在方法调用时将它们传递进来，就可以通过共享大幅度的减少单个实例的数目。\n\n\n### UML图\n\n\n![](http://i2.muimg.com/567571/924b08198a8476c8.jpg)\n\n\n### 享元模式的应用\n\n\n如果一个应用程序使用了大量的对象，而大量的这些对象造成了很大的存储开销时就应该考虑使用，还有就是对象的大多数状态可以是外部状态，如果删除对象的外部状态，那么就可以用相对较少的共享对象取代很多组对象，此时就可以考虑使用享元模式。\n\n\n### 解释器模式\n\n\n给定一个语言，定义它的文法的一种表示，并定义一个解释器，这个解释器使用该表示来解释语言中的句子。\n解释器所要解决的是一种特定类型的问题发生的频率足够高，那么可能值得将该问题的各个实例表述一个简单语言中的句子。这样就可以构建一个解释器，该解释器通过解释这些句子来解决该问题。\n\n\n### UML图\n\n\n![](http://i2.muimg.com/567571/35ad24c0b5a82059.jpg)\n\n\n### 访问者模式\n\n\n表示一个作用于对象结构中的各元素的操作。它使你可以在不改变各元素的类的前提下定义作用于这些元素的新操作。\n\n\n### UML图\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/17-4-12/53785370-file_1492011029245_9f97.jpg)\n\n\n### 访问者模式优缺点\n\n\n访问者模式的目的是要把数据从数据结构中分离出来。一个系统有比较稳定的数据结构，又有易于变化的算法的话，使用访问者模式就是比较合适的，因为访问者模式使算法操作增加变得容易，将有关的行为集中到一个访问者对象中。但缺点也是使增加新的数据结构变得困难了。\n\n\n## 设计原则\n\n- 单一职责原则（SRP）：就一个类而言，应该仅有一个引起它变化的原因\n- 开放-封闭原则：软件实体（类、模块、函数等等）应该可以扩展，但是不可修改\n- 依赖倒转原则：高层模块不应该依赖低层模块。两个都应该依赖抽象；抽象不应该依赖细节。细节应该依赖抽象\n- 里氏代换原则：子类型必须能够替换掉他们的父类型\n- 迪米特法则：如果两个类不必彼此直接通信，那么这两个类就不应当发生直接的相互作用，可以通过第三者转发这个应用\n- 合成/聚合复用原则：尽量使用合成、聚合，尽量不要使用类继承\n",
      "properties": {
        "date": "2017-09-24",
        "type": "Post",
        "category": "设计模式",
        "slug": "notes-on-the-design-pattern-of-big-talk",
        "tags": [],
        "title": "大话设计模式 笔记",
        "status": "Published",
        "urlname": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356",
        "updated": "2023-07-17 14:45:00"
      },
      "catalog": [
        {
          "title": "2017-09-24",
          "doc_id": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356"
        }
      ],
      "body": "",
      "realName": "大话设计模式 笔记",
      "relativePath": "/2017-09-24/大话设计模式 笔记.md"
    },
    {
      "id": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd",
      "doc_id": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd",
      "title": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd",
      "updated": 1689576300000,
      "body_original": "\n翻了下新版的C++ Primer，新的C++ 11真是变化很大，新增了很多语法特性。虽然已经很久没在写C++了，但一直对这门经典语言很感兴趣的，大致看了看前几章基础部分，总结下新特性备个忘，总结下新特性备个忘吧。估计也很难有机会用上了... ╮(─▽─)╭\n\n\n## 基本语法\n\n\n### 类型别名\n\n\nC++11新规定了一种使用using的别名声明的方法\n\n\n```c++\ntypedef double wages;\nusing wages = double;\n```\n\n\n### decltype类型指示符\n\n\n通过decltype选安置并返回操作数的数据类型\n\n\n```c++\n//sum的类型是f()的返回值\ndecltype(f()) sum = x;\n\n//错误示例, cj是z的一个引用, 必须初始化\nconst int &cj = ci;\ndecltype(cj) z;\n```\n\n\n变量名加上一层或多层括号时, 编译器会把它当成是一个表达式, 此时decltype会得到一个引用类型.\n\n\n```c++\ndecltype((i)) d; //错误示例, d是int&, 必须初始化\n```\n\n\n### 迭代语句\n\n\n### for循环\n\n\n```c++\nfor (declaration : expression)\n    statemet\n```\n\n\n例子:\n\n\n```c++\n//将vector对象中每个元素都翻倍\nvector<int> v = {0, 1, 2, 3, 5}\n\nfor (auto &r : v)\n    r *= 2;\n```\n\n\n## 基本类型\n\n\n### string类型\n\n\n### string:: size_type\n\n\nsize_type是string中一种与机器无关的类型, 一个无符号类型的值而且能够存放下任何string对象的大小,所有用于存放string类的size函数返回值的变量, 都应该是string:: size_type类型的.\n\n\n## 函数\n\n\n### 可变形参函数\n\n\n### initializer_list\n\n\n适用于全部类型都一样的可变形参, 定义在同名头文件中, 同vector一样, 也是种模板类型. 拷贝或赋值一个initializer_list对象不会拷贝列表中的元素, 拷贝后原始列表和副本共享元素\n\n\n例子:\n\n\n```c++\nvoid error_msg(initializer_list<string> il)\n{\n\tfor (auto beg = il.begin(); beg != il.end(); ++beg)\n\t{\n\t\tcout << *beg << \" \";\n\t\tcout << endl;\n\t}\n}\n```\n\n\n### 函数重载\n\n\n### const_cast强转重载函数\n\n\n```c++\n//比较两个string的长度, 返回较短的那一个\nconst string &shorterString(const string &s1, const string &s2)\n{\n    return s1.size() <= s2.size() ? s1 : s2;\n}\n\n//使用const_cast改造成比较非常量时返回普通引用\nstring &shorterString(string &s1, string &s2)\n{\n    auto &r = shorterString(const_cast<const string&>(s1),\n                const_cast<const string&>(s2));\n    return const_cast<string&>(r);\n}\n```\n\n\n### constexpr函数\n\n\n能用于常量表达式的函数, 函数返回类型及所有形参类型都得是字面类型, 且函数体重有且只有一条return语句\n\n\n```c++\nconstexpr int new_sz() { return 42; }\nconstexpr int foo = new_sz();\n```\n\n\n### 函数指针\n\n\n### typedef和decltype定义函数类型及指针\n\n\n```c++\n//Func和Func2是函数类型\ntypedef bool Func(const string&, const string&);\ntyedef decltype(lengthCompare) Func2;   //等价类型\n\n//Func和Func2是指向函数的指针\ntypedef bool (*Func)(const string&, const string&);\ntypedef decltype(lengthCompare) *Func2; //等价类型\n```\n\n\n## 类\n\n\n### 成员函数\n\n- 定义在类内部的函数是隐式的inline函数\n- 参数列表后加const, 用于修改隐式this指针类型, 便于指向常量, 限制this修改所指对象\\\n- C++11中可以通过在参数列表后面写上= default来要求编译器生成默认构造函数\n- 通过mutable关键字来声明一个可变成员函数, 可在const成员函数中改变\n- 通过explicit限制一个实参的构造函数进行隐式转换\n\n### 委托构造函数\n\n\nC++11中可使用委托构造函数来使用它所属类的其它构造函数来执行自己的初始化过程\n\n\n```c++\nclass Sales_data {\n    Sales_data(std::string s, unsigned cnt, double price):\n    bookNo(s), units_sold(cnt), revenu(cnt*price) {}\n    Sales_data(): Sales_data(\"\", 0, 0) {}\n    Sales_data(std::string s): Sales_data(s, 0, 0) {}\n    Sales_data(std::istream &is): Sales_data() {\n        read(is, *this)\n    }\n}\n```\n\n",
      "properties": {
        "date": "2017-09-25",
        "type": "Post",
        "category": "cpp",
        "slug": "cpp11-new-knowledge-point",
        "tags": [],
        "title": "C++11 新知识点",
        "status": "Published",
        "urlname": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd",
        "updated": "2023-07-17 14:45:00"
      },
      "catalog": [
        {
          "title": "2017-09-25",
          "doc_id": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd"
        }
      ],
      "body": "",
      "realName": "C++11 新知识点",
      "relativePath": "/2017-09-25/C++11 新知识点.md"
    },
    {
      "id": "39808486-176b-44d2-9277-48a36682cc92",
      "doc_id": "39808486-176b-44d2-9277-48a36682cc92",
      "title": "39808486-176b-44d2-9277-48a36682cc92",
      "updated": 1689576180000,
      "body_original": "\ncrontab是Linux下执行定时任务的工具，之前偶尔需要用到时都是通过执行`crontab -e`命令或者通过root身份直接编辑`/etc/cron.*/`下的文件来添加定时任务。这段时间遇到了需要通过shell来自动添加或删除crontab的需求。在shell中无法通过`crontab -e`来与crontab编辑器交互，同时执行命令的人不一定有root身份，也无法直接编辑`/etc/cron.*/`下的文件。\n\n\n经过一番实践，通过`crontab -l`配合`sed`命令来完成了这个自动添加及删除crontab的操作，在此记录下。\n\n\n### crontab的语法\n\n\n一张很明晰的crontab语法图，附在这以备用\n\n\n![crontab的语法](https://darkreunion-1256611153.file.myqcloud.com/17-12-28/62834492.jpg)\n\n\n### shell控制脚本\n\n\n```bash\n#!/usr/bin/env bash\n\nCUR_PATH=$(cd \"$(dirname \"$0\")\"; pwd)\n\n# 要定时执行的任务\nTASK_COMMAND=\"echo 'aaa' >> /var/cron_test\"\n# 要添加的crontab任务\nCRONTAB_TASK=\"*/30 * * * * ${TASK_COMMAND}\"\n# 备份原始crontab记录文件\nCRONTAB_BAK_FILE=\"${CUR_PATH}/crontab_bak\"\n\n# 创建crontab任务函数\nfunction create_crontab()\n{\n    echo 'Create crontab task...'\n    crontab -l > ${CRONTAB_BAK_FILE} 2>/dev/null\n    sed -i \"/.*${TASK_COMMAND}/d\" ${CRONTAB_BAK_FILE}  # 已存在任务时会被sed删除，防止重复添加\n    echo \"${CRONTAB_TASK}\" >> ${CRONTAB_BAK_FILE}\n    crontab ${CRONTAB_BAK_FILE}\n    \n    echo 'Complete'\n}\n\n# 清除crontab任务函数\nfunction clear_crontab(){\n    echo 'Delete crontab task...'\n    crontab -l > ${CRONTAB_BAK_FILE} 2>/dev/null\n    sed -i \"/.*${SCRIPT_NAME}/d\" ${CRONTAB_BAK_FILE}\n    crontab ${CRONTAB_BAK_FILE}\n    \n    echo 'Complete'\n}\n\nif [ $# -lt 1 ]; then\n    echo \"Usage: $0 [start | stop]\"\n    exit 1\nfi\n\ncase $1 in\n    'start' )\n        create_crontab\n        ;;\n    'stop' )\n        clear_crontab\n        ;;\nesac\n\n```\n\n",
      "properties": {
        "date": "2017-12-29",
        "type": "Post",
        "category": "Linux管理",
        "slug": "shell-edit-the-crontab-task",
        "tags": [],
        "title": "shell编辑crontab任务",
        "status": "Published",
        "urlname": "39808486-176b-44d2-9277-48a36682cc92",
        "updated": "2023-07-17 14:43:00"
      },
      "catalog": [
        {
          "title": "2017-12-29",
          "doc_id": "39808486-176b-44d2-9277-48a36682cc92"
        }
      ],
      "body": "",
      "realName": "shell编辑crontab任务",
      "relativePath": "/2017-12-29/shell编辑crontab任务.md"
    },
    {
      "id": "9b07d1c7-14d8-4348-a464-07e07e50bb64",
      "doc_id": "9b07d1c7-14d8-4348-a464-07e07e50bb64",
      "title": "9b07d1c7-14d8-4348-a464-07e07e50bb64",
      "updated": 1689577980000,
      "body_original": "\n## 进程管理\n\n\n### ps\n\n\n显示当前的进程的快照信息\n\n- -e：显示所有进程。\n- -f：全格式。\n- -h：不显示标题。\n- -l：长格式。\n- -w：宽输出。\n- a：显示终端上的所有进程，包括其他用户的进程。\n- r：只显示正在运行的进程。\n- u：以用户为主的格式来显示程序状况。\n- x：显示所有程序，不以终端机来区分。\n\n常用的两种使用方式：\n\n\nps -ef：以标准格式显示进程的信息，包含的信息：\n\n\n> UID PID PPID C STIME TTY TIME CMD\n\n\nps aux：以 BSD 的格式来显示 java 这个进程，包含的信息：\n\n\n> USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\n\n\n### nohup\n\n\n不挂断地运行命令，忽略所有挂断（SIGHUP）信号。在终端上执行任务后即使断掉终端后也会继续执行，一般配合&使用。那么在缺省情况下该作业的所有输出都被重定向到一个名为 nohup.out 的文件中，除非另外指定了输出文件。\n\n\n```text\nnohup command > myout.file 2>&1\n# 输出被重定向到myout.file文件中\n\n```\n\n\n### journalctl 查询 systemd 日志\n\n\n> https://documentation.suse.com/zh-cn/sled/15-SP3/html/SLED-all/cha-journalctl.html\n\n\n## 网络管理\n\n\n### Bash代理配置\n\n\n```text\nPROXY_ADDR='http://127.0.0.1:1080'\n# socks5 代理格式\n# PROXY_ADDR='socks5://bj-proxy.easystack.cn:8899'\n\nexport http_proxy=$PROXY_ADDR\nexport https_proxy=$PROXY_ADDR\n\n# 全部协议均通过代理\n# export all_proxy=$PROXY_ADDR\n\n```\n\n\n**取消代理**\n\n\n```text\nunset http_proxy\nunset https_proxy\n\n```\n\n\n### git 代理配置\n\n\n```text\ngit config --global https.proxy $PROXY_ADDR\ngit config --global https.proxy $PROXY_ADDR\n\n```\n\n\n**取消代理**\n\n\n```text\ngit config --global --unset http.proxy\ngit config --global --unset https.proxy\n\n```\n\n\n### netstat\n\n\nnetstat用来查看系统当前系统网络状态信息，包括端口，连接情况等，常用方式如下:\n\n\n```text\nnetstat -atunlp\n\n```\n\n- \\-a 显示所有连接的端口\n- \\-t : 指明显示TCP端口\n- \\-u : 指明显示UDP端口\n- \\-n : 不进行DNS解析\n- \\-l : 仅显示监听套接字(LISTEN状态的套接字)\n- \\-p : 显示进程标识符和程序名称，每一个套接字/端口都属于一个程序\n\n### lsof\n\n\nlsof的作用是列出当前系统打开文件(list open files)，不过通过-i参数也能查看端口的连接情况，-i后跟冒号端口可以查看指定端口信息，直接-i是系统当前所有打开的端口\n\n\n```text\nlsof -i:22 #查看22端口连接情况，默认为sshd端口\n\n```\n\n\n### nc\n\n\nnc是netcat工具的命令，可以用来实现端口扫描，文件传输等网络功能。\n\n- nc {ip} {port} 连接指定 IP 的端口，可以实现检查指定 IP 的端口是否打开\n- -v 输出交互或出错信息，调试时尤为有用\n- -w 超时秒数，后面跟数字\n- -s 指定发送数据的源IP地址，适用于多网卡机\n- -u 指定nc使用UDP协议，默认为TCP\n\n### curl\n\n\n一个利用URL语法在命令行下工作的网络数据传输工具\n\n\n**检查外网 IP**\n\n- curl ip.sb / curl ifconfig.io / curl cip.cc\n\n## 账户管理\n\n\n### visudo\n\n\n编辑/etc/sudoers 文件，管理可以使用 sudo 的用户\n\n\n```text\n允许ubuntu用户在不输入该用户的密码的情况下使用所有命令\nubuntu  ALL=(ALL:ALL) NOPASSWD: ALL\n\n```\n\n\n## 文字处理\n\n\n### wc\n\n\n统计文件里面有多少单词, 多少行, 多少字符\n\n- -l：仅列出行\n- -w：仅列出多少字(英文单字)\n- -m：多少字符\n\n### sort\n\n\n对 File 参数指定的文件中的行排序, 并将结果写到标准输出. 如果 File 参数指定多个文件, 那么 sort 命令将这些文件连接起来, 并当作一个文件进行排序\n\n- -f：忽略大小写的差异，例如 A 与 a 视为编码相同\n- -b：忽略最前面的空格符部分\n- -M：以月份的名字来排序，例如 JAN, DEC 等等的排序方法\n- -n：使用『纯数字』进行排序(默认是以文字型态来排序的)\n- -r：反向排序\n- -u：就是 uniq ，相同的数据中，仅出现一行代表\n- -t：分隔符，默认是用 [tab] 键来分隔\n- -k：以那个区间 (field) 来进行排序的意思\n\n### uniq\n\n\nuniq 命令可以去除排序过的文件中的重复行, 因此 uniq 经常和 sort 合用. 也就是说, 为了使 uniq 起作用, 所有的重复行必须是相邻的\n\n- -i：忽略大小写字符的不同\n- -c：进行计数\n- -u：仅显示不重复的行\n\n### cut\n\n\n从一个文本文件或者文本流中提取文本列\n\n- -d：后面接分隔字符。与 -f 一起使用\n- -f：依据 -d 的分隔字符将一段信息分割成为数段，用 -f 取出第几段的意思\n- -c：以字符 (characters) 的单位取出固定字符区间\n\n### head\n\n\n显示指定文件的前 10 行\n\n- -n: 指定显示的行数\n\n### tail\n\n\n显示指定文件的后 10 行\n\n- -n: 指定显示的行数\n\n### dos2unix\n\n\n将 windows 的换行格式\"\\r\\n\"转化成 Linux 的格式\"\\n\"\n\n\n## 文件系统\n\n\n### df\n\n\n检查文件系统的磁盘空间占用情况, 可以利用该命令来获取硬盘被占用了多少空间, 目前还剩下多少空间等信息\n\n- -a: 全部文件系统列表\n- -h: 方便阅读方式显示\n- -H: 等于“-h”，但是计算式，1K=1000，而不是 1K=1024\n- -i: 显示 inode 信息\n- -k: 区块为 1024 字节\n- -l: 只显示本地文件系统\n- -m: 区块为 1048576 字节\n- --no-sync: 忽略 sync 命令\n- -P: 输出格式为 POSIX\n- --sync: 在取得磁盘信息前，先执行 sync 命令\n- -T: 文件系统类型\n\n选择参数:\n\n- --block-size=<区块大小> 指定区块大小\n- -t<文件系统类型> 只显示选定文件系统的磁盘信息\n- -x<文件系统类型> 不显示选定文件系统的磁盘信息\n- --help 显示帮助信息\n- --version 显示版本信息\n\n### du\n\n\n显示每个文件和目录的磁盘使用空间\n\n- -a 或-all: 显示目录中个别文件的大小\n- -b 或-bytes: 显示目录或文件大小时，以 byte 为单位\n- -c 或--total: 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和\n- -k 或--kilobytes: 以 KB(1024bytes)为单位输出\n- -m 或--megabytes: 以 MB 为单位输出\n- -s 或--summarize: 仅显示总计，只列出最后加总的值\n- -h 或--human-readable: 以 K，M，G 为单位，提高信息的可读性\n- -x 或--one-file-xystem: 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过\n- -L<符号链接>或--dereference<符号链接>: 显示选项中所指定符号链接的源文件大小\n- -S 或--separate-dirs: 显示个别目录的大小时，并不含其子目录的大小\n- -X<文件>或--exclude-from=<文件>: 在<文件>指定目录或文件\n- --exclude=<目录或文件>: 略过指定的目录或文件\n- -D 或--dereference-args: 显示指定符号链接的源文件大小\n- -H 或--si: 与-h 参数相同，但是 K，M，G 是以 1000 为换算单位\n- -l 或--count-links: 重复计算硬件链接的文件\n\n## 软件管理\n\n\n### apt-cache\n\n\napt-cache 是一个 apt 软件包管理工具，它可查询 apt 的二进制软件包缓存文件。\n\n- show 显示软件的信息，包括版本号，安装状态和包依赖关系等\n- madison 显示软件可安装的版本\n- showpkg 搜索软件包，可用正则表达式\n- policy 显示软件包的安装状态和版本信息\n\n## 实用命令\n\n\n### 加速 SCP 传输\n\n\n```text\ntar -c source/ | pv | lz4 -B4 | ssh username@ip \"lz4 -d |tar -xC dist/\"\n# pv 可显示压缩速度\n# lz -B4 使用lz4算法以B4(64KB块大小)压缩\n\n```\n\n\n需进一步提升速度，可采用指定的完整性校验完整性校验和弱加密算法\n\n\n```text\ntar -c source/ | pv | lz4 -B4 | ssh -c arcfour128 -o \"MACs umac-64@openssh.com\" username@ip \"lz4 -d |tar -xC dist/\"\n\n```\n\n\n参考：\n[使用 tar+lz4/pigz+ssh 更快的数据传输](http://www.orczhou.com/index.php/2013/11/tranfer-data-faster-on-the-fly/)\n\n\n### 系统测试\n\n\n```shell\n# 模拟高CPU利用率\ncat /dev/urandom | gzip -9 | gzip -d | gzip -9 | gzip -d > /dev/null\n\n# 使用 fio 测试系统 io 性能\nfio --filename={} -direct=1 --iodepth=64 --rw=randrw --rwmixwrite=70 --ioengine=psync --bs=4k --size=500M --numjobs=30 --runtime=600 --name=mytest\n\n```\n\n",
      "properties": {
        "date": "2017-12-29",
        "type": "Post",
        "category": "Linux管理",
        "slug": "linux-common-commands",
        "tags": [
          "Linux命令"
        ],
        "title": "Linux常用命令",
        "status": "Published",
        "urlname": "9b07d1c7-14d8-4348-a464-07e07e50bb64",
        "updated": "2023-07-17 15:13:00"
      },
      "catalog": [
        {
          "title": "2017-12-29",
          "doc_id": "9b07d1c7-14d8-4348-a464-07e07e50bb64"
        }
      ],
      "body": "",
      "realName": "Linux常用命令",
      "relativePath": "/2017-12-29/Linux常用命令.md"
    },
    {
      "id": "961c038c-8f49-478d-8c61-68f679680da0",
      "doc_id": "961c038c-8f49-478d-8c61-68f679680da0",
      "title": "961c038c-8f49-478d-8c61-68f679680da0",
      "updated": 1689576120000,
      "body_original": "\nPython的`virtualenv`工具可以创建隔离的Python环境， `virtualenvwrapper`是`virtualenv`的进一步封装工具，可以让它更好用。\n\n\n### 安装\n\n\nLinux 系统下：\n\n\n> pip install virtualenvwrapper\n\n\nWindows 系统下：\n\n\n> pip install virtualenvwrapper-win\n\n\n### 配置环境变量\n\n- **WORKON_HOME** 虚拟Python环境的生成路径，不设置会默认生成在家目录的.virtualenvs文件夹下\n- **VIRTUALENVWRAPPER_PYTHON** 当系统存在多个版本的python时，需要设置这个环境变量指定Python版本\n\n### 使用方法\n\n\n### 激活环境\n\n\nLinux下首次安装后需要手动激活环境\n\n\n> source /usr/local/bin/virtualenvwrapper.sh\n\n\n可以加入到~/.bash_profile之类的地方，以后登录系统使用时无需重复初始化了\n\n\n### 创建环境\n\n\n> mkvirtualenv <name>\n\n\n### 列出已有虚拟环境\n\n\n> lsvirtualenv\n\n\n### 切换环境\n\n\n> workon <name>\n\n\n### 退出环境\n\n\n> deactivate\n\n\n### 删除虚拟环境\n\n\n> rmvirtualenv <name>\n\n",
      "properties": {
        "date": "2018-01-04",
        "type": "Post",
        "category": "Python",
        "slug": "virtualenvwrapper-of-the-python-module",
        "tags": [],
        "title": "Python模块之virtualenvwrapper",
        "status": "Published",
        "urlname": "961c038c-8f49-478d-8c61-68f679680da0",
        "updated": "2023-07-17 14:42:00"
      },
      "catalog": [
        {
          "title": "2018-01-04",
          "doc_id": "961c038c-8f49-478d-8c61-68f679680da0"
        }
      ],
      "body": "",
      "realName": "Python模块之virtualenvwrapper",
      "relativePath": "/2018-01-04/Python模块之virtualenvwrapper.md"
    },
    {
      "id": "fe690171-3af8-4967-993b-825f5a1cd525",
      "doc_id": "fe690171-3af8-4967-993b-825f5a1cd525",
      "title": "fe690171-3af8-4967-993b-825f5a1cd525",
      "updated": 1689576120000,
      "body_original": "\n最近看到了一篇讲[Django性能测试和优化](http://blog.csdn.net/dev_csdn/article/details/78782570)的文章, 文中除了提到了很多有用的优化方法, 演示程序的数据库模型写法我觉得也很值得参考, 在这单独记录下.\n\n\n原文的演示代码有些问题, 我改进了下, 这里可以查看: https://github.com/wanghaoxi3000/development/tree/master/Python/Django/optimize_django\n\n\n在实际项目中, 有时需要隐藏数据库中表的主键, 我之前采用的大多是为需要隐藏主键ID的表添加一个字段, 再用散列或者`UUID`等填充来唯一标识一行数据. 而上面提到的文章中则是使用了一个专门生成ID对应散列值的基类, 需要隐藏散列的表可以通过继承这个类来实现隐藏自己的主键ID.\n\n\n比较特别的是此文的散列值是通过主键ID和`ContentType`的ID来一起生成的. [`ContentType`](https://docs.djangoproject.com/en/2.0/ref/contrib/contenttypes/)是Django自带的一套的框架, 在新模型安装时会自动创建新的`ContentType`实例, `ContentType` 实例具有返回它们表示的模型类的方法, 以及从这些模型查询对象的方法. 从而提供一个高层次的, 通用的接口来与模型进行交互.\n\n\n_ContentType使用说明:_\n\n\n> https://docs.djangoproject.com/en/2.0/ref/contrib/contenttypes/\n\n\n通过这样的机制, 解码一个散列值后就可以直接得到对应的Django ORM模型类和实例.  对于一些需要一个集中的地方对模型进行解码并对不同类的不同模型实例进行处理时会很有用.\n\n\n### Hasher 类代码\n\n\n```python\nfrom django.contrib.contenttypes.models import ContentType\nimport basehash\n\n\nclass Hasher:\n    base36 = basehash.base36()\n\n    @classmethod\n    def from_model(cls, obj, klass=None):\n        if obj.pk is None:\n            return None\n        return cls.make_hash(obj.pk, klass if klass is not None else obj)\n\n    @classmethod\n    def make_hash(cls, object_pk, klass):\n        # 使用代理模型时通过 for_concrete_model=False 获取代理模型的ContentType\n        content_type = ContentType.objects.get_for_model(klass, for_concrete_model=False)\n        return cls.base36.hash('%(contenttype_pk)03d%(object_pk)06d' % {\n            'contenttype_pk': content_type.pk,\n            'object_pk': object_pk\n        })\n\n    @classmethod\n    def parse_hash(cls, obj_hash):\n        unhashed = '%09d' % cls.base36.unhash(obj_hash)\n        contenttype_pk = int(unhashed[:-6])\n        object_pk = int(unhashed[-6:])\n        return contenttype_pk, object_pk\n\n    @classmethod\n    def to_object_pk(cls, obj_hash):\n        return cls.parse_hash(obj_hash)[1]\n\n```\n\n\nHasher 类主要用来完成散列值的计算和解码过程, 将`ContentType`和主键组合后进行`base36`计算, 生成一段12位的代码. 主要使用了`basehash`模块, 通过安装`gmpy2`模块可以进一步提升计算速度.\n\n\n### HashableModel 基类\n\n\n```python\nfrom django.db import models\n\nfrom .utils import Hasher\n\n\nclass HashableModel(models.Model):\n    \"\"\"提供每个模型提供 Hash ID 的基类\"\"\"\n    class Meta:\n        abstract = True\n\n    @property\n    def hash(self):\n        return Hasher.from_model(self)\n\n```\n\n\n`HashableModel` 通过在Meta元选项中设定`abstract = True`而成为Django ORM中的一个基类, 其它模型可以通过继承这个基类来具备产生对应散列的能力.\n\n\n### 基本使用\n\n\n现在, 通过一个散列值便可以编写很多通用的接口了. 例如有两张表, 都有一个`path`的字段:\n\n\n```python\nclass TestModelOne(HashableModel):\n    path = models.CharField(max_length=30)\n\nclass TestModelTwo(HashableModel):\n    path = models.CharField(max_length=30)\n\n```\n\n\n通过这样一段代码, 便可以同时用来获取两张表的`path`字段了:\n\n\n```text\nfrom django.contrib.contenttypes.models import ContentType\n\ndef get_path(hash_id):\n    content_id, pk = Hasher.parse_hash()\n    obj = ContentType.objects.get_for_id(content_id).get_object_for_this_type(pk=pk)\n    return obj.path\n\n\n```\n\n\n_参考:_\n\n\n> http://blog.csdn.net/dev_csdn/article/details/78782570\n\n",
      "properties": {
        "date": "2018-01-23",
        "type": "Post",
        "category": "Django",
        "slug": "django-hides-the-primary-key-id-in-the-database-with-hash",
        "tags": [],
        "title": "Django 用散列隐藏数据库中主键ID",
        "status": "Published",
        "urlname": "fe690171-3af8-4967-993b-825f5a1cd525",
        "updated": "2023-07-17 14:42:00"
      },
      "catalog": [
        {
          "title": "2018-01-23",
          "doc_id": "fe690171-3af8-4967-993b-825f5a1cd525"
        }
      ],
      "body": "",
      "realName": "Django 用散列隐藏数据库中主键ID",
      "relativePath": "/2018-01-23/Django 用散列隐藏数据库中主键ID.md"
    },
    {
      "id": "3718ed3c-f70f-43ac-8eb2-51487ab5922c",
      "doc_id": "3718ed3c-f70f-43ac-8eb2-51487ab5922c",
      "title": "3718ed3c-f70f-43ac-8eb2-51487ab5922c",
      "updated": 1689576120000,
      "body_original": "\n在把自己的项目通过Docker进行打包时，由于项目中用到了crontab，不过使用到的基础镜像`python:3.6-slim`并没有安装这项服务，记录下在镜像中安装和配置crontab的过程。\n\n\n### Dockerfile\n\n\n由于基础镜像中没有crontab服务，需要在打包自己镜像的Dockerfile中加入安装cron服务的步骤。\n\n\n```docker\nFROM python:3.6-slim\nMAINTAINER whx3000 <wanghaoxi3000@163.com>\n\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends \\\n    cron && \\\n    rm -rf /var/lib/apt/lists/* && \\\n    apt-get clean\n\nRUN chmod +x ./docker-entrypoint.sh\n\nENV LC_ALL C.UTF-8\nENTRYPOINT [\"./docker-entrypoint.sh\"]\n\n```\n\n\n执行apt安装时注意加入`-y --no-install-recommends`，并且在安装完成后执行`rm -rf /var/lib/apt/lists/* && apt-get clean`命令，可以有效减小镜像的体积。\n\n\n这样安装完cron服务后，crontab服务并不会自启动，还需要一个`docker-entrypoint.sh`启动脚本来添加crontab的启动命令。\n\n\n### 启动脚本\n\n\n```bash\n#!/bin/bash\nset -x\n\n# 保存环境变量，开启crontab服务\nenv >> /etc/default/locale\n/etc/init.d/cron start\n\n```\n\n\n`/etc/init.d/cron start`用于启动crontab服务，但这样启动的crontab服务中配置的定时命令是没有Dockerfile中设置的环境变量的。因此还需要在这之前执行`env >> /etc/default/locale`，这样有Dockerfile中通过`ENV`设置的环境变量在crontab中就可以正常读取了。\n\n",
      "properties": {
        "date": "2018-03-17",
        "type": "Post",
        "category": "Docker",
        "slug": "running-crontab-in-docker",
        "tags": [],
        "title": "在Docker中运行crontab",
        "status": "Published",
        "urlname": "3718ed3c-f70f-43ac-8eb2-51487ab5922c",
        "updated": "2023-07-17 14:42:00"
      },
      "catalog": [
        {
          "title": "2018-03-17",
          "doc_id": "3718ed3c-f70f-43ac-8eb2-51487ab5922c"
        }
      ],
      "body": "",
      "realName": "在Docker中运行crontab",
      "relativePath": "/2018-03-17/在Docker中运行crontab.md"
    },
    {
      "id": "f816711b-a712-4265-ade5-63fe1cc26c9f",
      "doc_id": "f816711b-a712-4265-ade5-63fe1cc26c9f",
      "title": "f816711b-a712-4265-ade5-63fe1cc26c9f",
      "updated": 1689576120000,
      "body_original": "\n## CentOS系统参数优化\n\n\n### 内核相关参数 /etc/sysctl.conf\n\n\n```text\nnet.core.somaxconn=65535  # TCP监听队列，可调为2048以上\nnet.core.netdev_max_backlog=65535   #  每个网络接口接收数据包的速率比内核快时允许发送到队列中的数目\nnet.ipv4.tcp_max_syn_backlog=65535  # 还未获得连接的请求可保存在内存中的数目，超过的数目可能会被抛弃\n\nnet.ipv4.tcp_fin_timeout=10  # TCP连接最大等待时间\nnet.ipv4.tcp_tw_reuse=1      # 缩短以加快TCP资源的回收\nnet.ipv4.tcp_tw_recycle=1\n\nnet.core.wmem_default=87380  # TCP接收和发送缓冲区的默认值和最大值\nnet.core.wmem_max=16777216\nnet.core.rmem_default=87380\nnet.core.rmem_max=16777216\n\nnet.ipv4.tcp_keepalive_time=120  # 缩短以减少失效连接所占用TCP资源的数量\nnet.ipv4.tcp_keepalive_intvl=30\nnet.ipv4.tcp_keepalive_probes=3\n\nkernel.shmmax=4294967295  # Linux内核参数中最重要的参数之一，用于定义单个共享内存段的最大值\n                          # 这个参数应该足够大，以便能在一个共享内存段容纳下整个Innodb缓冲池的大小\n                          # 这个值大小对于64位Linux系统，可取最大值位物理内存值-1byte，\n                          # 建议值为大于物理内存的一半，一般取大于Innodb缓冲池的大小即可\n\nvm.swappiness=0           # 除非虚拟内存完全满了，否则不要使用交换区\n\n```\n\n\n### Linx PAM 插入式认证模块的配置文件/etc/security/limit.conf\n\n\n```text\n# 添加如下两行到此文件末尾，增加资源限制 \n# *     对所有用户有效\n# soft  当前系统生效的设置\n# hard  表明系统中所能设定的最大值\n# 65535 表示所限制的资源是打开文件的最大数目\n\n* soft mofile 65535  \n* hard nofile 65535\n\n```\n\n\n### 磁盘调度策略 /sys/block/devname/queue/scheuler\n\n\n```text\n# 使用如下方式来开启deadline调度策略\n\necho deadline > /sys/block/sda/queue/scheuler\n\n```\n\n\n## 存储引擎选择\n\n\n### MyISAM\n\n\n适用场景:\n\n- 非事务性应用\n- 只读类应用\n- 空间类应用(5.7版本前唯一支持空间函数引擎)\n\n### Innodb引擎\n\n\n特性:\n\n- 事物型引擎\n- 完全支持ACID特性(原子 一致 隔离 持久)\n- Redo Log 和 Undo Log\n- 支持行级索, 可以最大程度的支持并发\n\n使用表空间进行数据存储, `innodb_file_per_table` 参数为 `on` 时使用独立表空间(ibd后缀文件), `off` 时使用系统表空间(ibdataX)\n\n\n功能差异:\n\n- 系统表空间5.5及以前版本无法简单收缩文件大小\n- 独立表空间可通过 `optimize table` 命令收缩系统空间\n- 独立表空间存在IO瓶颈\n- 独立表空间可以同时向多个文件刷新数据\n\n**建议使用 Innodb 独立表空间(5.6及以后版本的默认表空间)**\n\n\n查看状态:\n通过 `show engine innodb status` 可以查看 innodb 引擎的状态信息\n\n\n适用场景:\n\n- 适合大多数OLTP(联机事务处理)应用\n\n### CSV\n\n\n特点:\n\n- 数据以文本方式储存在文件中\n\t- .CSV文件存储表内容\n\t- .CSM文件存储表的元数据如表状态和数据量\n\t- .frm文件存储表结构信息\n- 以CSV格式进行数据存储\n- 所有列必须都是不能为NULL的\n- 不支持索引, 不适合在线处理\n- 可以对数据文件直接编辑\n\n适用场景:\n\n- 适合作为数据交换的中间表\n\n### Archive\n\n\n特点:\n\n- 以zlib对表数据进行压缩, 磁盘I/O更少\n- 数据存储在 ARZ 为后缀的文件中\n- 只支持 insert 和 select 操作\n- 只允许在自增ID列上加索引\n\n适用场景:\n\n- 日志和数据采集类应用\n\n### Memory\n\n\n特点:\n\n- 也称为HEAP存储引擎, 所有数据保存在内存中, 数据易失, 需要数据可再生\n- 支持 HASH(默认, 适合等值查找) 索引和 BTree(适合范围查找) 索引\n- 所有字段都为固定长度 varchar(10)=char(10)\n- 不支持 BLOG 和 TEXT 等大字段\n- Memory 存储引擎使用表级锁\n- 最大大小由 `max_heap_table_size` 参数决定\n\n适用场景:\n\n- 用于查找或者是映射表, 如邮编和地区的对应表\n- 用于保存数据分析中产生的中间表\n- 用于缓存周期性聚合数据的结果表\n\n### Federated\n\n\n特点:\n\n- 提供了访问远程MySQL服务器上表的方法\n- 本地不存储数据, 数据全部放到远程服务器上\n- 本地需要保存表结构和远程服务器的连接信息\n\n使用方法:\n\n- 默认禁止, 启用需要在启动时增加federated参数\n\n使用场景:\n\n- 偶尔的统计分析及手工查询\n",
      "properties": {
        "date": "2018-04-05",
        "type": "Post",
        "category": "数据库",
        "slug": "mysql-config-adjust",
        "tags": [
          "MySQL配置"
        ],
        "title": "MySQL 配置优化",
        "status": "Published",
        "urlname": "f816711b-a712-4265-ade5-63fe1cc26c9f",
        "updated": "2023-07-17 14:42:00"
      },
      "catalog": [
        {
          "title": "2018-04-05",
          "doc_id": "f816711b-a712-4265-ade5-63fe1cc26c9f"
        }
      ],
      "body": "",
      "realName": "MySQL 配置优化",
      "relativePath": "/2018-04-05/MySQL 配置优化.md"
    },
    {
      "id": "84c953d6-d1f7-40c0-b9b0-116ff39f2132",
      "doc_id": "84c953d6-d1f7-40c0-b9b0-116ff39f2132",
      "title": "84c953d6-d1f7-40c0-b9b0-116ff39f2132",
      "updated": 1689576060000,
      "body_original": "\nNumPy 是高性能科学计算和数据分析的基础包. 它是 pandas 等其他各种工具的基础.\n\n\n主要功能:\n\n- ndarray 一个多维数组结构, 高效且节省空间\n- 无需循环对整组数据进行快速运算的数学函数\n- 线性代数, 随机数生成和傅里叶变换功能\n\n### ndarry 多维数组\n\n- 创建ndarry: `np.array(array_like)`\n- 数组与列表的区别:\n\t- 数组对象类元素类型必须相同\n\t- 数组大小不可修改\n\n### ndarry 常用属性\n\n- T: 数组的转置\n- size: 数组元素个数\n- ndim: 数组的维数\n- shape: 数组的维度大小(元组形式)\n- dtype: 数组元素的数据类型\n\n### ndarry 创建方法\n\n- array() 将列表转为数组, 可选择显式指定 dtype\n- arange() range 的 numpy 版支持浮点数\n- linspace() 类似 arange(), 第三个参数为数组长度\n- zero() 根据指定形状和 dtype 创建全0数组\n- ones() 根据指定形状和 dtype 创建全1数组\n- empty() 根据指定形状和 dtype 创建空数组(内存随机值)\n- eye() 根据指定边长和 dtype 创建单位矩阵\n\n### ndarray 索引\n\n- 一维数组索引 `a[5]`\n- 多维数组索引 `a[2][3]`\n- 新式写法 `a[2, 3]` (推荐)\n- 对于一个数组, 选出其第1, 3, 4, 6, 7个元素, 组成新的二维数组: `a[[1,3,4,6,7]]`\n- 布尔型索引, 选出所有大于5的偶数: `a[(a>5) & (a%2=0)]`\n- 布尔型索引, 选出所有大于5的数和偶数: `a[(a>5) | (a%2=0)]`\n- 对于一个二维数组, 选出其第一列和第三列, 组成新的二维数组: `a[:, [1, 3]]`\n\n### ndarry 切片\n\n- 一维数组的切片: 与列表类似\n- 多维数组的切片: a[1:2, 3:4] a[:, 3:5] a[:, 1] (前行后列)\n- 与列表切片的不同: 数组切片时并不会自动复制(而是创建一个视图), 在切片数组上的修改会影响原数组\n- copy() 方法可以创建数组的深拷贝\n\n### NumPy 通用函数\n\n\n### 浮点数特殊值\n\n- nan(Not 啊Number) 不等于任何浮点数(nan != nan)\n- inf(infinty) 比任何浮点数都大\n- NumPy中创建特殊值 np.nan np.inf\n- 在数据分析中, nan常被用做数据缺失值\n\n### 一元函数\n\n\n**abs** **sqrt** exp log **ceil**(向上取整) **floor**(向下取整) **rint** **trunc** **modf** **isnan** **isinf** cos sin tan\n\n\n### 二元函数\n\n\nadd substract multiply divide power mod **maximum** **mininum**\n\n\n### 数学和统计方法\n\n- sum 求和\n- mean 求平均数\n- std 求标准差\n- var 求方差\n- min 求最小值\n- max 求方差\n- argmin 求最小值索引\n- argmax 求最大值索引\n\n### 随机数生成\n\n- rand 给定形状产生随机数组(0到1之间的数)\n- randin 给定形状产生随机整数\n- choice 给定形状产随机选择\n- shuffle 与random.shuffle相同\n- uniform 给定形状产生随机数组\n",
      "properties": {
        "date": "2018-06-13",
        "type": "Post",
        "category": "Python",
        "slug": "numpy-basic-usage",
        "tags": [
          "Python模块包",
          "Numpy",
          "科学计算",
          "数据分析"
        ],
        "title": "NumPy 基础用法",
        "status": "Published",
        "urlname": "84c953d6-d1f7-40c0-b9b0-116ff39f2132",
        "updated": "2023-07-17 14:41:00"
      },
      "catalog": [
        {
          "title": "2018-06-13",
          "doc_id": "84c953d6-d1f7-40c0-b9b0-116ff39f2132"
        }
      ],
      "body": "",
      "realName": "NumPy 基础用法",
      "relativePath": "/2018-06-13/NumPy 基础用法.md"
    },
    {
      "id": "3009bc34-4eb9-4513-a0a9-fba6db5329c9",
      "doc_id": "3009bc34-4eb9-4513-a0a9-fba6db5329c9",
      "title": "3009bc34-4eb9-4513-a0a9-fba6db5329c9",
      "updated": 1689576060000,
      "body_original": "\npandas 是一个基于 Numpy 构建, 强大的数据分析工具包\n\n\n**主要功能**\n\n- 独特的数据结构 DataFrame, Series\n- 集成时间序列功能\n- 提供丰富的数学运算操作\n- 灵活处理缺失数据\n\n### Series 一维数组\n\n\nSeries 是一种类似于一维数组的对象, 由一组数据和一组与之相关的数据标签(索引)组成\n\n\n创建方式\n\n\n```python\npd.Series([4, 7 ,5, -3])\npd.Series([4, 7 ,5, -3], index=['a', 'b', 'c', 'd'])\npd.Series({'a':1, 'b', 2})\npd.Series(0, index=['a', 'b', 'c', 'd'])\n\n# 获取值数组\nsr = pd.Series([4, 7 ,5, -3])\nsr.value\n\n# 获取索引数组\nsr = pd.Series([4, 7 ,5, -3])\nsr.index\n\n```\n\n\n### Series 支持array的特性(下标)\n\n- 从 ndarry 创建 Series\n- 与标量直接运算\n- 两个 Series 运算\n- 索引\n- 切片\n- 通用函数 np.abs(sr)\n- 布尔值过滤 sr[sr>0]\n\n### Series 支持字典的特性(标签)\n\n- 从字典创建 Series Series(dict)\n- in 运算\n- 键索引\n\n**整数索引**\n\n\n如果索引是整数, 则根据下标取值时总是面向标签的.\n此时可通过 **loc**方法(将索引解释为标签)和**iloc**方法(将索引解释为下标)\n\n\n### Series 数据计算\n\n\n```python\nsr1 = pd.Series([12,23,34], index=['c', 'a', 'd'])\nsr2 = pd.Series([11,20,10], index=['d', 'c', 'a'])\nprint(sr1 + sr2)\n# 相关计算方法 add, sub, div, mul\n\n```\n\n\npandas 在进行两个 Series 对象运算时, 会按索引进行对齐然后计算.\n\n\n**数据对齐**\n\n\n若两个 Series 对象的索引不完全相同, 则结果的索引是两个操作数索引的并集. 如果只有一个对象在某索引下有值, 则结果中该索引的值为NaN.\n\n\n**缺失数据处理办法**\n\n\n```python\nsr1.add(sr2, fill_value=0) 填充缺失的值\ndropna() 过滤掉值为NaN的行\nfillna() 填充缺失数据\nisnull() 返回布尔数组, 缺失值对应为True\nnotnull() 返回buer数据, 缺失值对应为False\n\n# 过滤缺失数据\nsr.dropna() \nsr[data.notnull()]\n\n```\n\n\n### DataFrame\n\n\nDataFrame 是一个表格型的数据结构, 含有一组有序的列. 可以看做是 Series 组成的字典, 并且公用一个索引.\n\n\n创建 DataFrame 的方法有很多种\n\n\n```python\n# 手动创建\npd.DataFrame({'one':[1,2,3,4], 'two':[4,3,2,1]})\npd.DataFrame({'one':pd.Series([1,2,3], index=['a','b', 'c']), 'two':pd.Series([1,2,3,4], index=['a','b','c','d'])\n\n# 从csv文件读取与写入\ndf.read_csv('filename.csv')\ndf.to_csv()\n\n```\n\n\n### 常用属性\n\n- index 获取索引\n- T 转置\n- columns 获取列索引\n- values 获取值数组\n- describe() 获取快速统计\n\n### 索引和切片\n\n\nDataFrame 是一个二维数据类型, 所以有`行索引`和`列索引`, 可以通过标签和位置两种方法进行索引和切片\n\n- loc 索引方法和 iloc 下标方法\n\t- 使用方法: 逗号隔开, 前面是行索引, 后面是列索引\n\t- 行/列索引部分可以是常规索引, 切片, 布尔值索引, 花式索引任意搭配\n\n### 数据对齐与缺失数据\n\n\nDataFrame 对象在运算时, 同样会进行数据对齐, 其行索引和列索引分别对齐\n\n\n处理缺失数据的相关方法\n\n- dropna(axis=0, where='any', ...)\n- fillna()\n- isnull()\n- notnull()\n\n### pandas 常用方法\n\n- mean(axis=0, skipna=False)  对列(行)求平均值\n- sum(axis=1)  对列(行)求和\n- sort_index(axis, ..., ascending)  对列(行)索引排序\n- sort_values(by, axis, ascending)  按某一列(行)的值排序\n- apply(func, axis=0)  将自定义函数应用在各行或各列上, func可返回标量或Series\n- NumPy 的通用函数同样适用于pandas\n- applymap(func)  将函数应用在 DataFrame 各个元素上\n- map(func)  将函数应用在 Series 各个元素上\n\n### 时间处理\n\n\npandas基于`dateutil`来处理时间对象\n\n- `dateutil.parser.parse()` dateutil 原生时间处理方法\n- `pd.to_datetime()` pandas 成组处理时间对象\n- `data_range()` 产生时间对象数组\n\t- start 开始时间\n\t- end 结束时间\n\t- periods 时间长度\n\t- freq 时间频率, 默认为'D', 可选为H(our), W(eek), B(usiness), S(emi-)M(onth), (min)T(es), S(econd), A(year)\n\n### 时间序列\n\n\n时间序列是以时间对象为索引的Series或DataFrame, datetime对象作为索引时是存储在DatetimeIndex对象中的.\n\n\n时间序列的特色功能:\n\n- 传入\"年\"或\"年月\"作为切片方式\n- 传入日期范围作为切片方式\n- 丰富的函数支持: resample(), strftime(), ...\n\n### 文件处理\n\n- `read_csv` 和 `read_table` 函数\n\t- sep 制定分隔符, 可用正则表达式如'\\s+'\n\t- header = None 指定文件无列名\n\t- name 指定列名\n\t- index_col 指定某列为索引\n\t- skip_row 指定跳过某些行\n\t- na_values 指定某些字符串表示缺失值\n\t- parse_dates 指定某些列是否被解析为日期, 类型为布尔值或列表\n- `to_csv` 函数\n\t- sep 指定文件函数\n\t- na_rep 指定缺失值转换的字符串, 默认为空字符串\n\t- header=False 不输出列名一行\n\t- index=False 不输出行索引一列\n\t- columns 指定输出的列, 传入列表\n",
      "properties": {
        "date": "2018-07-24",
        "type": "Post",
        "category": "Python",
        "slug": "pandas-basic-usage",
        "tags": [
          "Python模块包",
          "Pandas",
          "科学计算",
          "数据分析"
        ],
        "title": "Pandas 基础用法",
        "status": "Published",
        "urlname": "3009bc34-4eb9-4513-a0a9-fba6db5329c9",
        "updated": "2023-07-17 14:41:00"
      },
      "catalog": [
        {
          "title": "2018-07-24",
          "doc_id": "3009bc34-4eb9-4513-a0a9-fba6db5329c9"
        }
      ],
      "body": "",
      "realName": "Pandas 基础用法",
      "relativePath": "/2018-07-24/Pandas 基础用法.md"
    },
    {
      "id": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5",
      "doc_id": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5",
      "title": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5",
      "updated": 1689576060000,
      "body_original": "\n### 数据库编码\n\n\n查看数据库编码\n\n\n```text\nuse xxx\nshow variables like 'character_set_database';\n\n```\n\n\n切换数据库编码\n\n\n```text\nalter database xxx CHARACTER SET gb2312;\n\n```\n\n\n### 修改自增ID\n\n\n创建表格时设置自增ID从N开始：\n\n\n```sql\nCREATE TABLE TABLE_1 (\n        ID INT UNSIGNED NOT NULL PRIMARY KEY AUTO_INCREMENT,\n        NAME VARCHAR(5) NOT NULL \n    )\nAUTO_INCREMENT = 100;\n\n```\n\n\n让自增ID从默认值开始, **但是注意：这个命令会清空数据包记录！**\n\n\n```text\nTRUNCATE TABLE table1\n\n```\n\n\n设置user表自增ID从123456开始\n\n\n```text\nalter table users AUTO_INCREMENT=123456;\n\n```\n\n\n### 无法远程登录\n\n\n在已经修改配置文件中的地址为 `0.0.0.0` 但仍然无法远程登录的情况下, 一般是需要对数据库中的账户信息进行修改\n\n\n### 授权用户 (推荐)\n\n\n```text\nmysql>GRANT ALL PRIVILEGES ON *.* TO 'root'@'%' IDENTIFIED BY 'password' WITH GRANT OPTION;\n\n```\n\n\n### 直接修改 `user` 表\n\n\n```text\nmysql>use mysql;\nmysql>update user set host = '%' where user = 'root';\n\n```\n\n\n以上方法操作完成后还需执行 `FLUSH PRIVILEGES;` 刷新一遍权限\n\n\n### 远程连接速度慢\n\n\n有时远程连接到 MySQL 用时会很久, 同时本地连接 MySQL 正常. 出现这种问题的主要原因是默认安装的 MySQL 开启了 DNS 的反向解析.\n\n\n### MySQL DNS 反向解析\n\n\nMySQL 接收到连接请求后，获得的是客户端的ip，为了更好的匹配 `mysql.user` 里的权限记录(某些是用 hostname 定义的).\n如果mysql服务器设置了dns服务器, 并且客户端 ip 在 DNS 上并没有相应的hostname, 那么这个过程很慢, 导致连接等待.\n\n\n### 禁用 DNS 反向解析\n\n\n在 MySQL 的配置文件 `/etc/mysql/mysql.conf.d/mysqld.cnf` 中 `[mysqld]` 添加 `skip-name-resolve` 即可禁用 DNS 反向解析, 加快远程连接的速度. 同时这样配置后不能在 MySQL 的授权表中使用主机名了, 只能使用IP.\n\n",
      "properties": {
        "date": "2018-09-11",
        "type": "Post",
        "category": "数据库",
        "slug": "sometimes-useful-mysql-skill",
        "tags": [
          "MySQL技巧"
        ],
        "title": "偶尔用得上的MySQL操作",
        "status": "Published",
        "urlname": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5",
        "updated": "2023-07-17 14:41:00"
      },
      "catalog": [
        {
          "title": "2018-09-11",
          "doc_id": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5"
        }
      ],
      "body": "",
      "realName": "偶尔用得上的MySQL操作",
      "relativePath": "/2018-09-11/偶尔用得上的MySQL操作.md"
    },
    {
      "id": "bbe13887-7af7-4399-ba5e-d1b08398fa9a",
      "doc_id": "bbe13887-7af7-4399-ba5e-d1b08398fa9a",
      "title": "bbe13887-7af7-4399-ba5e-d1b08398fa9a",
      "updated": 1689576060000,
      "body_original": "\n### 迭代相关\n\n- iter(): 将一个序列转换成迭代器\n- next(): 自动调用对象的`__next__()`方法来迭代对象\n- map(): 将一个序列值作为参数，依次调用一个函数，在python2中直接返回列表，但在python3中返回迭代器\n\n```text\n# map经常配合lambdas来使用\nitems = [1, 2, 3, 4, 5]\nsquared = list(map(lambda x: x**2, items))\n\n# 用于循环调用一列表的函数\ndef multiply(x):\n        return (x*x)\ndef add(x):\n        return (x+x)\n\nfuncs = [multiply, add]\nfor i in range(5):\n    value = map(lambda x: x(i), funcs)\n    print(list(value))\n\n# Output:\n# [0, 0]\n# [1, 2]\n# [4, 4]\n# [9, 6]\n# [16, 8]\n\n```\n\n- filter(): 过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，在python2中直接返回列表，但在python3中返回迭代器\n\n```text\nnumber_list = range(-5, 5)\nless_than_zero = filter(lambda x: x < 0, number_list)\nprint(list(less_than_zero))  \n\n# Output: [-5, -4, -3, -2, -1]\n\n```\n\n- enumerate()：遍历数据并自动计数，并且有许多有用的可选参数\n\n```text\n# 配置从哪个数字开始枚举\nmy_list = ['apple', 'banana', 'grapes', 'pear']\nfor c, value in enumerate(my_list, 1):\n    print(c, value)\n\n# 输出:\n(1, 'apple')\n(2, 'banana')\n(3, 'grapes')\n(4, 'pear')\n\n```\n\n- for-else\nPython中for循环还有一个else从句，这个else从句会在循环正常结束时执行，因而可以常常搭配break来使用。\n\n```text\nfor item in container:\n    if search_something(item):\n        # Found it!\n        process(item)\n        break\nelse:\n    # Didn't find anything..\n    not_found_in_container()\n\n```\n\n\n### 对象自省\n\n- dir()：返回一个列出了一个对象所拥有的属性和方法的列表，如果不传入参数，那么它会返回当前作用域的所有名字\n- type()：返回一个对象的类型\n- id()：返回任意不同种类对象的唯一ID\n\n## 扩展\n\n\n### functools\n\n- Reduce()当需要对一个列表进行一些计算并返回结果时，Reduce 是个非常有用的函数。\n\n```text\nfrom functools import reduce\nproduct = reduce( (lambda x, y: x * y), [1, 2, 3, 4] )\n\n# Output: 24\n\n```\n\n",
      "properties": {
        "date": "2018-09-27",
        "type": "Post",
        "category": "Python",
        "slug": "python-build-in-function",
        "tags": [
          "Python基础知识"
        ],
        "title": "Python 内置方法",
        "status": "Published",
        "urlname": "bbe13887-7af7-4399-ba5e-d1b08398fa9a",
        "updated": "2023-07-17 14:41:00"
      },
      "catalog": [
        {
          "title": "2018-09-27",
          "doc_id": "bbe13887-7af7-4399-ba5e-d1b08398fa9a"
        }
      ],
      "body": "",
      "realName": "Python 内置方法",
      "relativePath": "/2018-09-27/Python 内置方法.md"
    },
    {
      "id": "c0c57fa4-044c-4f50-8199-9f12724853ee",
      "doc_id": "c0c57fa4-044c-4f50-8199-9f12724853ee",
      "title": "c0c57fa4-044c-4f50-8199-9f12724853ee",
      "updated": 1689576000000,
      "body_original": "\nleetcode 算法刷题记录和总结, 主要使用Python和Go来作答.\n\n\n## 算法\n\n\n### 从排序数组中删除重复项\n\n\n给定一个有序数组，你需要原地删除其中的重复内容，使每个元素只出现一次,并返回新的长度。不要另外定义一个数组，您必须通过用 O(1) 额外内存原地修改输入的数组来做到这一点。\n\n\n### 示例\n\n\n给定数组: nums = [1,1,2], 你的函数应该返回新长度 2, 并且原数组nums的前两个元素必须是1和2\n不需要理会新的数组长度后面的元素\n\n\n### 思路\n\n\n数组是有序的, 则相同的值必定是紧挨着的, 通过定义两个变量,  一个变量a用于记录数组最后一个不重复值的下标, 使用一个变量b循环数组, 若nums[a] != nums[b] 时, 就将a值增1, 并执行nums[a] = nums[b]. 循环结束后, a+1 的值即为数组中新数组不相等的长度. 考虑到空数组的情况, 可将b初始化为-1, 在循环结束后 b > a 的情况下, 才将a增1.\n\n\n### 代码\n\n\nPython:\n\n\n```python\nclass Solution:\n    def removeDuplicates(self, nums):\n        \"\"\"\n        :type nums: List[int]\n        :rtype: int\n        \"\"\"\n        diff_length = 0\n        index = -1\n        for index, item in enumerate(nums): \n            if nums[diff_length] != item:\n                diff_length += 1\n                nums[diff_length] = item\n\n        if index >= diff_length:\n            return diff_length + 1\n        else:\n            return diff_length\n```\n\n\nGo:\n\n\n```go\nfunc removeDuplicates(nums []int) int {\n    ix := -1\n\tvar val int\n\tdiffLength := 0\n\n\tfor ix, val = range nums {\n\t\tif nums[diffLength] != val {\n\t\t\tdiffLength++\n\t\t\tnums[diffLength] = val\n\t\t}\n\t}\n\n\tif ix >= diffLength {\n\t\tdiffLength++\n\t}\n    \n    return diffLength\n}\n```\n\n\n### 旋转数组\n\n\n将包含 n 个元素的数组向右旋转 k 步。要求空间复杂度为 O(1)。\n\n\n### 示例\n\n\n例如，如果  n = 7 ,  k = 3，给定数组  [1,2,3,4,5,6,7]  ，向右旋转后的结果为 [5,6,7,1,2,3,4]。\n\n\n### 思路\n\n1. 旋转数组操作类似于一个循环队列操作, k 到队尾出队再从对首入队\n2. 利用切片操作将数组切为 [:len(nums)-k] 和 nums[len(nums)-k:] 再重新组合\n3. 将数组 [:len(nums)-k] 和 [len(nums)-k:] 分别逆序, 再将整个数组逆序\n\n### 代码\n\n\nPython:\n思路1\n\n\n```python\nclass Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        step = k % len(nums)\n        for index in range(step):\n            nums.insert(0, nums.pop())\n```\n\n\n思路2:\n\n\n```python\nclass Solution:\n    def rotate(self, nums, k):\n        \"\"\"\n        :type nums: List[int]\n        :type k: int\n        :rtype: void Do not return anything, modify nums in-place instead.\n        \"\"\"\n        k = k % len(nums)\n        nums[:k], nums[k:] = nums[len(nums)-k:], nums[:len(nums)-k]\n```\n\n\nGo:\n\n\n```go\nfunc rotate(nums []int, k int)  {\n    n := len(nums)\n    k %= n\n    k = n - k\n    reverse(nums[:k])\n    reverse(nums[k:])\n    reverse(nums)\n}\n\nfunc reverse(nums []int) {\n    for i, j := 0, len(nums) - 1; i < j; i, j = i + 1, j - 1 {\n        nums[i], nums[j] = nums[j], nums[i]\n    }\n}\n```\n\n\n### 两个数组的交集 II\n\n\n给定两个数组，写一个方法来计算它们的交集。\n\n- 输出结果中每个元素出现的次数，应与元素在两个数组中出现的次数一致。\n- 我们可以不考虑输出结果的顺序。\n\n### 示例\n\n\n例如, 给定 nums1 = [1, 2, 2, 1], nums2 = [2, 2], 返回 [2, 2].\n\n\n### 思路\n\n\n便利其中一个列表(可能的话, 优先选择较短的数组), 检查此列表中的元素是否在另一列表中存在, 存在的话即为一交集值加入返回结果的列表中, 并从了另一列表中删除\n\n\n### 代码\n\n\nPython:\n思路1\n\n\n```python\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        set_list = []\n        for item in nums1:\n            if item in nums2:\n                set_list.append(item)\n                nums2.remove(item)\n\n        return set_list\n```\n\n\n思路2, 利用`collections`模块\n\n\n```python\nimport collections\n\nclass Solution:\n    def intersect(self, nums1, nums2):\n        \"\"\"\n        :type nums1: List[int]\n        :type nums2: List[int]\n        :rtype: List[int]\n        \"\"\"\n        import collections\n        return list((collections.Counter(nums1)&collections.Counter(nums2)).elements())\n```\n\n\nGo:\n\n\n```go\nfunc intersect(nums1 []int, nums2 []int) []int {\n    setList := []int{}\n\n\ttmpMap := make(map[int]int)\n\tfor _, item := range nums1 {\n\t\t_, ok := tmpMap[item]\n\t\tif ok {\n\t\t\ttmpMap[item]++\n\t\t} else {\n\t\t\ttmpMap[item] = 1\n\t\t}\n\t}\n\tfor _, item := range nums2 {\n\t\t_, ok := tmpMap[item]\n\t\tif ok && tmpMap[item] > 0 {\n\t\t\tsetList = append(setList, item)\n\t\t\ttmpMap[item]--\n\t\t}\n\t}\n    \n    return setList\n}\n```\n\n\n### 两数之和\n\n\n给定一个整数数组和一个目标值，找出数组中和为目标值的两个数。你可以假设每个输入只对应一种答案，且同样的元素不能被重复利用。\n\n\n### 示例\n\n\n给定 nums = [2, 7, 11, 15], target = 9 因为 nums[0] + nums[1] = 2 + 7 = 9 所以返回 [0, 1]\n\n\n### 思路\n\n1. 循环遍历, 依次相加验证\n2. 利用 map 来验证差是否在数组中\n\n### 代码\n\n\nPython:\n思路1\n\n\n```python\nclass Solution:\n    def twoSum(self, nums, target):\n        \"\"\"\n        :type nums: List[int]\n        :type target: int\n        :rtype: List[int]\n        \"\"\"\n        for index1 in range(len(nums)-1):\n            num1 = nums[index1]\n            for index2, num2 in enumerate(nums[index1+1:]):\n                if num1 + num2 == target:\n                    return [index1, index2+index1+1]\n\n        return []\n```\n\n\nGo:\n思路2\n\n\n```go\nfunc twoSum(nums []int, target int) []int {\n\tnumMap := make(map[int]int)\n    \n\tfor index1, item := range nums {\n\t\tnum := target - item\n\t\tindex2, ok := numMap[num]\n\t\tif ok {\n\t\t\treturn []int{index2, index1}\n\t\t}\n\t\tnumMap[item] = index1\n\t}\n\n\treturn []int{}\n}\n```\n\n\n### 有效的数独\n\n\n判断一个 9x9 的数独是否有效。只需要根据以下规则，验证已经填入的数字是否有效即可。\n\n1. 数字 1-9 在每一行只能出现一次。\n2. 数字 1-9 在每一列只能出现一次。\n3. 数字 1-9 在每一个以粗实线分隔的 3x3 宫内只能出现一次。\n\n### 思路\n\n\n利用 `set` 和 `dict` 数据结构进行比对\n\n\n### 代码\n\n\nPython:\n\n\n```python\ndef isValidSudoku(nums):\n    \"\"\"\n    :type board: List[List[str]]\n    :rtype: bool\n    \"\"\"\n    for index in range(9):\n        data_set = set(nums[index])\n        data_set.discard('.')\n        if len(data_set) + nums[index].count('.') != 9:\n            return False\n\n        if index % 3 == 0:\n            check_list = [{} for _ in range(3)]\n\n        data_set = set()\n        col_num = 0\n        for row_line, row in enumerate(nums):\n            if row[index] != '.':\n                col_num += 1\n                data_set.add(row[index])\n                if row[index] in check_list[int(row_line / 3)]:\n                    return False\n                else:\n                    check_list[int(row_line / 3)][row[index]] = True\n\n        if col_num != len(data_set):\n            return False\n\n    return True\n\n```\n\n\n### 旋转数组\n\n\n给定一个 n × n 的二维矩阵表示一个图像。将图像顺时针旋转 90 度。你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。\n\n\n### 示例\n\n\n```text\n给定 matrix = \n[\n  [1,2,3],\n  [4,5,6],\n  [7,8,9]\n],\n\n原地旋转输入矩阵，使其变为:\n[\n  [7,4,1],\n  [8,5,2],\n  [9,6,3]\n]\n```\n\n\n### 思路\n\n\n将数据结构看做矩阵，先转置矩阵再颠倒每排数组。\n\n\n### 代码\n\n\nGo:\n\n\n```go\nfunc rotate(matrix [][]int) {\n\tfor row := range matrix {\n\t\tfor col := row + 1; col < len(matrix[row]); col++ {\n\t\t\tmatrix[row][col], matrix[col][row] = matrix[col][row], matrix[row][col]\n\t\t}\n\t\tfor left, right := 0, len(matrix[row])-1; left < right; left, right = left+1, right-1 {\n\t\t\tmatrix[row][left], matrix[row][right] = matrix[row][right], matrix[row][left]\n\t\t}\n\t}\n}\n```\n\n",
      "properties": {
        "date": "2018-11-30",
        "type": "Post",
        "category": "算法",
        "slug": "algorithm-with-leetcode",
        "tags": [
          "Python",
          "Go",
          "leetcode"
        ],
        "summary": "leetcode 算法刷题记录和总结, 主要使用Python和Go来作答.",
        "title": "leetcode 算法刷题记录",
        "status": "Published",
        "urlname": "c0c57fa4-044c-4f50-8199-9f12724853ee",
        "updated": "2023-07-17 14:40:00"
      },
      "catalog": [
        {
          "title": "2018-11-30",
          "doc_id": "c0c57fa4-044c-4f50-8199-9f12724853ee"
        }
      ],
      "body": "",
      "realName": "leetcode 算法刷题记录",
      "relativePath": "/2018-11-30/leetcode 算法刷题记录.md"
    },
    {
      "id": "8a90fccd-b953-4c11-b81f-ef8fc113aa17",
      "doc_id": "8a90fccd-b953-4c11-b81f-ef8fc113aa17",
      "title": "8a90fccd-b953-4c11-b81f-ef8fc113aa17",
      "updated": 1689575880000,
      "body_original": "\n已经专职做了很久的 Python 开发，不过心中对当初带我入行 C 也一直有些留恋。Go 语言的设计和定位和 C 语言有很多共同之处，也融入了很多现代的设计理念，写起来很有当初写 C 的亲切感。准备好好学习下这门语言，这里记录下一些个人觉得重要的基础知识点，随着不断深入再补充。\n\n\n## 基础语法\n\n\n### 数组常量\n\n\n如果数组值已经提前知道了，那么可以通过 **数组常量** 的方法来初始化数组。\n\n\n```go\nvar arrInt0 [5]int   // 正常声明\nvar arrInt1 = [5]int{18, 20, 15, 22}     // 在声明时定义数组, 若元素数量不匹配, 可以忽略后面的元素\nvar arrInt2 = [...]int{5, 6, 7, 8, 22}   // 使用切片的方式来定义数组, ... 可省略\nvar arrKeyValue = [5]string{3: \"Chris\", 4: \"Ron\"}   // key: value 方式, 只有索引 3 和 4 被赋予实际的值, 其他元素都被设置为空的字符串\n\n```\n\n\n### `new()` 和 `make()` 的区别\n\n\n看起来二者没有什么区别，都在**堆**上分配内存，但是它们的行为不同，适用于不同的类型。\n\n- `new(T)` 为每个新的类型 `T` 分配一片内存，初始化为 0 并且返回类型为 `*T` 的内存地址：这种方法返回一个指向类型为 `T`，值为 0 的地址的指针，它适用于值类型如**数组**和**结构体**；它相当于 `&T{}`。\n- `make(T)` 返回一个类型为 `T` 的初始值，它只适用于3种内建的引用类型：**切片**、**map** 和 **channel**。\n\n换言之，`new` 函数分配内存，`make` 函数初始化；下图给出了区别：\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/18-8-22/75616542.jpg)\n\n\n在的第一幅图中，代码为 `var p *[]int = new([]int)` 或者 `p := new([]int)` 。在第二幅图中，代码为 `p := make([]int, 0)`，切片已经被初始化，但是指向一个空的数组。\n\n\n以上两种方式实用性都不高。在实际开发中应采用下面的方法：\n\n\n```text\nvar v []int = make([]int, 10, 50)\n\n```\n\n\n或者\n\n\n```text\nv := make([]int, 10, 50)\n\n```\n\n\n这样分配一个有 50 个 int 值的数组，并且创建了一个长度为 10，容量为 50 的 切片 v，该 切片 指向数组的前 10 个元素。\n\n\n## 开发规范\n\n\n### package 命名\n\n1. go不要求package的名称和所在目录名相同，但是你最好保持相同，否则容易引起歧义。因为引入包的时候，go会使用子目录名作为包的路径，而你在代码中真正使用时，却要使用你package的名称。\n2. 每个子目录中只能存在一个package，否则编译时会报错。\n\n### 指针和值的使用\n\n- 推荐在实例方法上使用指针（前提是这个类型不是一个自定义的 map 、slice 等引用类型）\n- 当结构体较大的时候使用指针会更高效\n- 如果要修改结构内部的数据或状态必须使用指针\n- 当结构类型包含 sync.Mutex 或者同步这种字段时，必须使用指针以避免成员拷贝\n- 如果你不知道该不该使用指针，使用指针！\n\n“结构较大” 到底多大才算大可能需要自己或团队衡量，如超过 5 个字段或者根据结构体内占用来计算。\n\n\n## 参考资料\n\n- [Go 入门指南](https://go.fdos.me/)\n",
      "properties": {
        "date": "2019-01-31",
        "type": "Post",
        "category": "Golang",
        "slug": "go-base-knowledge",
        "tags": [
          "Golang 基础"
        ],
        "summary": "已经专职做了很久的 Python 开发，不过心中对当初带我入行 C 也一直有些留恋。Go 语言的设计和定位和 C 语言有很多共同之处，也融入了很多现代的设计理念，写起来很有当初写 C 的亲切感。准备好好学习下这门语言，这里记录下一些个人觉得重要的基础知识点，随着不断深入再补充。",
        "title": "Go 基础知识点",
        "status": "Published",
        "urlname": "8a90fccd-b953-4c11-b81f-ef8fc113aa17",
        "updated": "2023-07-17 14:38:00"
      },
      "catalog": [
        {
          "title": "2019-01-31",
          "doc_id": "8a90fccd-b953-4c11-b81f-ef8fc113aa17"
        }
      ],
      "body": "",
      "realName": "Go 基础知识点",
      "relativePath": "/2019-01-31/Go 基础知识点.md"
    },
    {
      "id": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e",
      "doc_id": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e",
      "title": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e",
      "updated": 1689575580000,
      "body_original": "\n日常工作中一直在用 Django 这类 MVC 架构的框架来搭建后台。然而早已对微服务架构闻名已久，早想有机会实践一下，靠着搜索引擎找到这篇不错的教程：[Golang 微服务教程](https://wuyin.io/2018/05/10/microservices-part-1-introduction-and-consignment-service/)，总结了微服务开发、测试到部署的完整过程。跟着初步实践了下微服务的构建过程，过了下微服务的瘾，在这里总结下。\n\n\n## 系统架构\n\n\n通过模拟搭建一套港口的货物管理平台，以 `Golang` 语音和 `go-mirco` 框架 主要实现了如下的服务。\n\n- user-service 用户服务: 提供用户信息管理及鉴权服务\n- consignment-service 货运服务：调度，分配货物到合适的货船\n- vessel-service 货船服务：管理货轮信息\n- email-service 邮件服务：提供邮件通知服务\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190620143102.jpg)\n\n\n## 微服务系统组成\n\n\n在传统的软件开发中，整个应用虽然一般也会分为好几个模块，但一般最终会打包成一个应用来运行。微服务最大的变化便是将这些模块拆分为了一个个独立的程序。在这样的架构下，编写此微服务系统主要涉及到以下的技术。\n\n\n### 服务间通信\n\n\n### RPC\n\n\n微服务架构中各个服务都是独立的程序，当一个服务需要使用到其他服务的功能时，就需要一套通讯协议来实现远程调用接口。在 HTTP 服务中，一般会使用 Json 或者 Xml 的格式，这样格式的数据易读性好，使用便捷，但是由于使用字符串的形式传输，在数据量大的情况下编解码开销也会很大，导致传输的成本很高。因此这里使用了谷歌开源的 `gRPC` 通信框架，内置的 `protobuf` 协议使用二进制的数据帧来通信，为微服务之间提供高效的通信机制。\n\n\n### 消息队列\n\n\n使用 RPC 的方式，可以直接调用其他服务的接口，但无法实现与其他服务的解耦，调用接口时必须保证此服务是在线的。对于一些调用后无需立即知道结果的服务，可以通过消息队列使用发布与订阅的模式，完全解耦，例如此项目中创建用户后，通过邮件服务给用户发送邮件的过程。\n\n\n### 服务发现\n\n\n直接使用 gRPC 时，需要手动指定服务端的地址和端口，这样任一服务重新部署 IP 或者端口发送变化后，此服务的相关服务都要跟着修改，管理起来会很麻烦。为解决服务间调用的问题，就需要引入服务发现，作为一个注册中心记录每个微服务的 IP 和端口，各微服务上线时会在它那注册，下线时会注销，其他服务可通过名字或 ID 直接找到该服务。\n\n\n### API 网关\n\n\n微服务之间可以通过 RPC 等方式来调用，对应一些需要开放给外部的接口，可以通过 API 网关方式，将 RPC 接口转换为一个 Rest 接口，可供外部客户端以 HTTP 的方式来调用。\n\n\n### 容器服务\n\n\n将一套系统拆分为多个微服务后，如何对这些微服务在分布式的环境下开发，测试和部署也是一个必须要考虑的问题。使用 Docker 技术，将微服务打包为一个个独立的容器，隔离操作系统环境影响，实现快速部署与管理各个微服务的状态。\n\n\n## 总结\n\n\n通过实现一个简单的微服务，将一个后台项目的组成拆开来形成独立的微服务，相比传统的架构降低了复杂性，各个微服务之间功能和职责更加明确，大大降低了模块间耦合度，各个模块之间都可以单独的独立运行，测试和部署。同时每个模块间的功能修改、扩展互不影响可以很容易地横向扩展，正适合当下云计算的高性能、高可用和分布式的开发环境。\n\n\n项目地址: [micro-shippy](https://github.com/wanghaoxi3000/micro-shippy)\n\n",
      "properties": {
        "date": "2019-06-19",
        "type": "Post",
        "category": "项目架构",
        "slug": "first-exploration-of-mirco-service",
        "tags": [
          "mircoservices",
          "Go",
          "go-mirco"
        ],
        "summary": "日常工作中一直在用 Django 这类 MVC 架构的框架来搭建后台。然而早已对微服务架构闻名已久，早想有机会实践一下，靠着搜索引擎找到这篇不错的教程：Golang 微服务教程，总结了微服务开发、测试到部署的完整过程。跟着初步实践了下微服务的构建过程，过了下微服务的瘾，在这里总结下。",
        "title": "初探微服务",
        "status": "Published",
        "urlname": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e",
        "updated": "2023-07-17 14:33:00"
      },
      "catalog": [
        {
          "title": "2019-06-19",
          "doc_id": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e"
        }
      ],
      "body": "",
      "realName": "初探微服务",
      "relativePath": "/2019-06-19/初探微服务.md"
    },
    {
      "id": "aee256a0-e9d4-45bb-889d-1bca9f2c8251",
      "doc_id": "aee256a0-e9d4-45bb-889d-1bca9f2c8251",
      "title": "aee256a0-e9d4-45bb-889d-1bca9f2c8251",
      "updated": 1689575580000,
      "body_original": "\n前段时间了解到了`Go-micro`这一微服务开发框架，并基于此框架的教程搭建了一套码头货运管理微服务系统。这次使用Micro来设计和实现了一套更接地气的秒杀系统。\n\n\n对于秒杀，以及抽奖、抢红包这类系统的最大特点便是在某个时间点会瞬间涌入大量的用户，给系统造成瞬间高于平时千百倍的并发压力。针对这样的特点在设计微服务时就需要考虑一系列的措施来保障系统在高并发场景时可以稳定运行。\n\n\n[完整代码地址](https://github.com/wanghaoxi3000/go-secbuy-mirco)\n\n\n## 系统架构\n\n\n一个经典的秒杀场景可以分为如下几个步骤\n\n1. 创建商品的库存信息\n2. 检查库存数量，满足数量就扣库存，否则失败\n3. 成功扣取库存后创建订单\n4. 创建支付记录\n\n依据这个流程，可以将微服务系统分为如下几个业务模块\n\n- 库存 stock\n- 订单 order\n- 支付 payment\n\n系统架构图如下：\n\n\n![framework](https://static-1256611153.file.myqcloud.com/img/picgo/20190901012210.png)\n\n\n## 准备工作\n\n\n本项目采用Golang语言和Go-Micro开发框架，使用Postgres数据库，为了便于快速开发，微服务的服务发现和消息机制就直接使用了Micro自带的机制。\n\n\n### Go和Go-Micro\n\n- [Golang环境](https://golang.google.cn/)\n\nMicro开发框架和工具\n\n\n```text\n## 安装go-micro\ngo get github.com/micro/go-micro\n\n## 安装micro\ngo get github.com/micro/micro\n\n```\n\n\n### protoc\n\n\ngRPC使用protobuf协议，需要安装protoc编译器，protoc编译器可以在GitHub的protobuf项目下下载编译好的工具直接使用。\n\n- [protoc compiler](https://github.com/google/protobuf/releases)\n\n安装好protoc编译器后还需要安装micro服务对应的生成插件。\n\n\n```text\ngo get -u github.com/micro/protoc-gen-micro\ngo get -u github.com/micro/protobuf/protoc-gen-go\n\n```\n\n\n### Postgres\n\n\n我在测试环境中搭建了docker服务，因而可以通过docker快速启动一个Postgres实例。\n\n\n```text\ndocker run --name postgres-dev -d --restart=always -p 5432:5432 -e POSTGRES_PASSWORD=postgres123 postgres:11\n\n```\n\n\n为了方便管理，同时启动了一个adminer服务。\n\n\n```text\ndocker run --name adminer -d --restart=always -p 10080:8080 adminer\n\n```\n\n\n创建一个dev用户和secbuy数据库。\n\n\n```text\nsu potgres\ncreateuser -P -e dev\npsql -U postgres\nCREATE DATABASE secbuy OWNER dev;\nGRANT ALL PRIVILEGES ON DATABASE secbuy to dev;\n\n```\n\n\n## 服务开发\n\n\n有了大体的架构思路后，我们可以开始开发每个微服务了，这里通过Go-Micro提供的工具，我们可以快速搭建起一个微服务的开发模板，同时基于为了尽量去复用代码，可以将微服务的配置相关提取出来，作为一个公共的功能让其余微服务来调用。\n\n\n因此我们这里先搭建一个负责读取配置数据的basic模块：\n[代码路径](https://github.com/wanghaoxi3000/go-secbuy-mirco/tree/master/basic)\n\n\n```text\n.\n├── basic.go            // basic 模块入口, 提供初始化接口\n├── config\n│   ├── config.go       // 读取config配置文件\n│   ├── postgres.go     // postgres配置数据结构\n│   └── profiles.go     // 配置文件属性数据结构\n├── db\n│   ├── db.go           // 数据库orm初始化流程\n│   └── postgres.go     // postgres初始化流程\n├── go.mod\n└── go.sum\n\n```\n\n\n每个微服务通过引用basic模块即可以完成读取自身的配置文件并初始化。\n\n\n完成basic的逻辑编写后，通过Go-Micro的micro工具即可自动生成微服务代码模块，开始微服务的开发。这里以stock库存服务为例，执行如下命令，风别建立stock-srv和stock-web服务，分别提供stock服务的业务逻辑和web接口。\n\n\n```text\nmicro new github.com/wanghaoxi3000/go-secbuy-mirco/stock-srv --namespace=go.micro.secbuy --alias=stock --type=srv\n\nmicro new github.com/wanghaoxi3000/go-secbuy-mirco/stock-web --namespace=go.micro.secbuy --alias=stock --type=web\n\n```\n\n\n生成的代码模板目录如下：\n\n- stock-srv\n\n```text\n.\n├── Dockerfile\n├── handler\n│   └── stock.go\n├── main.go\n├── Makefile\n├── plugin.go\n├── proto\n│   └── stock\n│       └── stock.proto\n├── README.md\n\n```\n\n- stock-web\n\n```text\n.\n├── Dockerfile\n├── handler\n│   └── handler.go\n├── html\n│   └── index.html\n├── main.go\n├── Makefile\n├── plugin.go\n├── proto\n│   └── stock\n│       └── stock.proto\n└── README.md\n\n```\n\n\n可以看见代码模板不但帮我们生成好了基本的代码开发文件，还有Makefile、Dockerfile、README这些一般项目所需的辅助文件也一并生成好了。\n\n\n### stock 服务\n\n\n这里从stock库存服务开始整个项目的开发，先在Postgres数据库中建立stock服务需要的表。注意为了保证高并发下，数据可能出现的超卖情况，在stock表中除了必要的数据字段，还添加了version乐观锁字段。\n\n\n```sql\nCREATE TABLE stock(\n    id SERIAL NOT NULL PRIMARY KEY,\n    name VARCHAR(50) NOT NULL,\n    count INTEGER NOT NULL,\n    sale INTEGER NOT NULL,\n    create_time TIMESTAMP NOT NULL DEFAULT now(),\n    version INTEGER NOT NULL DEFAULT 0\n);\n\nCOMMENT ON COLUMN stock.id IS '主键';\nCOMMENT ON COLUMN stock.name IS '名称';\nCOMMENT ON COLUMN stock.count IS '库存';\nCOMMENT ON COLUMN stock.sale IS '销量';\nCOMMENT ON COLUMN stock.create_time IS '创建时间';\nCOMMENT ON COLUMN stock.version IS '乐观锁';\n\n```\n\n\n在本项目中，为了快速完成数据库的开发，引入了gorm库，在代码的model/stock/stock.go需要定义对应的\n\n\n有了数据表后，可以开始编写proto文件，定义stock微服务可以提供的接口。在sotock微服务中提供三种接口：\n\n- CreateCommodity 创建商品信息\n- GetCommodity 通过ID查询商品信息\n- Sell 对指定ID的商品进行销存操作\n\n服务的接口定义如下：\n\n\n```text\nservice StockService {\n    rpc CreateCommodity (Commodity) returns (Response);\n    rpc GetCommodity(GetRequest) returns (Response);\n    rpc Sell(GetRequest) returns (Response);\n}\n\n```\n\n\n在proto文件中还需对这些接口进一步定义各个类型的字段，完成后通过已编写的的Makefile文件，在终端执行`make proto`即可生成对应的go代码文件stock.pb.go和stock.micro.go的文件。里面定义了proto文件中对应的go代码数据接口和接口。\n\n\n为了方便数据库的开发，在basic模块中引入了gorm，可以通过gorm来完成model的开发。在stock服务的/model/stock/stock.go中可以根据需要定义stock表对应的struct，方便gorm来使用。\n\n\n```text\ntype stockModel struct {\n\tID         int32\n\tName       string\n\tCount      int32\n\tSale       int32\n\tCreateTime time.Time `gorm:\"DEFAULT:now()\"`\n\tVersion    int32\n}\n\n```\n\n\n同时在此文件中，定义了一个`service struct`，用来实现本服务各接口功能的数据库对应的crud功能。在`func (s *service) SellCommodityByID(id int32) (commodity *proto.Commodity, err error)` 方法中，实现了本服务最核心的使用乐观锁销存操作。\n\n\n```text\n// 乐观锁销存\nif row := o.Model(&model).Where(\"version = ?\", model.Version).Updates(\n\tmap[string]interface{}{\n\t\t\"sale\":    model.Sale,\n\t\t\"version\": model.Version + 1,\n\t}).RowsAffected; row == 0 {\n\treturn nil, errors.New(\"commodity info timeout\")\n}\n\n```\n\n\n最后在/handler/stock.go中为微服务实现proto文件中定义的三个接口，stock-srv微服务的开发工作便基本完成了。通过`make build`即可编译生成微服务的可执行文件。完成后的stock-srv结构：\n\n\n```text\n.\n├── conf\n│   ├── application-db.yml\n│   └── application.yml\n├── Dockerfile\n├── go.mod\n├── go.sum\n├── handler\n│   └── stock.go\n├── main.go\n├── Makefile\n├── model\n│   ├── model.go\n│   └── stock\n│       ├── stock.go\n├── plugin.go\n├── proto\n│   └── stock\n│       ├── stock.micro.go\n│       ├── stock.pb.go\n│       └── stock.proto\n├── README.md\n├── stock-srv\n└── utils\n    └── createTabel.sql\n\n```\n\n\nstock服务同时还提供了stock-web来提供web接口的stock创建和查询服务。初始化的模板基本已完成了大部分的开发工作。基本上只需要在handler/handler.go中引入stock的服务，编写好对应的web接口方法即可。\n\n\n```text\n// 初始化 StockService\nimport stock \"github.com/wanghaoxi3000/go-secbuy-mirco/stock-srv/proto/stock\"\n\nvar (\n\tserviceClient stock.StockService\n)\n\nfunc Init() {\n\tserviceClient = stock.NewStockService(\"go.micro.secbuy.srv.stock\", client.DefaultClient)\n}\n\n\n```\n\n\n这里需要注意的是，调用stock服务需要引用stock-srv模块的proto文件，对于还在开发中的项目，对应的文件可能还没发布到代码库中，这时一个是可以将stock-srv的proto文件复制一份到web服务中来使用，但一旦srv中的proto文件有变动web的文件也要同步变更。更方便的是是使用go mod，可以直接引用stock-srv的代码库路径，同时在`go.mod`中添加：\n`replace github.com/wanghaoxi3000/go-secbuy-mirco/stock-srv => ../stock-srv`将代码库路径转换为本地相对路径即可。\n\n\n### order 服务\n\n\norder服务是秒杀中的承上启下的服务，通过提供`CreateOrder`的接口和order-web中的web服务，接收参与秒杀的用户调用请求，完成如下的功能：\n\n1. 查询指定ID的商品信息\n2. 查询到指定ID信息后，检查商品此时的订单和库存信息，若订单已等于库存，则商品已销售完\n3. 若商品订单尚小于库存，则调用stock服务的`SellCommodityByID`接口，执行销存操作\n4. 根据销存的结果，创建订单数据和发送创建支付记录消息，将结果返回给调用用户\n\n存放订单数据的数据库orders表结构定义如下：\n\n\n```text\nCREATE TABLE orders (\n    id SERIAL NOT NULL PRIMARY KEY,\n    sid INTEGER NOT NULL,\n    name VARCHAR(50) NOT NULL DEFAULT '',\n    create_time TIMESTAMP NOT NULL DEFAULT now()\n);\n\nCOMMENT ON COLUMN orders.id IS '主键';\nCOMMENT ON COLUMN orders.sid IS '库存ID';\nCOMMENT ON COLUMN orders.name IS '商品名称';\nCOMMENT ON COLUMN orders.create_time IS '创建时间';\n\n```\n\n\norder服务代码的开发的流程和stock大同小异，在创建完模板后，主要的不太的是在model的`CreateOrder`方法中创建订单记录时，需要通过stock服务客户端调用Sell方法来完成销存服务。\n\n\n```text\nfunc (s *service) CreateOrder(id int32) (*proto.Order, error) {\n\trsp, err := stockClient.Sell(context.TODO(), &stockSrv.GetRequest{Id: id})\n\tif err != nil {\n\t\tlog.Logf(\"[model] Sell 调用库存服务时失败：%s\", err.Error())\n\t\treturn nil, err\n\t}\n\tif !rsp.GetSuccess() {\n\t\treturn nil, errors.New(\"销存失败\")\n\t}\n\n\to := db.GetDB()\n\tmodel := order{\n\t\tSid:  id,\n\t\tName: rsp.GetCommodity().GetName(),\n\t}\n\to.Create(&model)\n\torderProto := &proto.Order{\n\t\tId:         model.ID,\n\t\tName:       model.Name,\n\t\tCreateTime: model.CreateTime.Format(\"2006-01-02T15:04:05\"),\n\t}\n\n\treturn orderProto, nil\n}\n\n```\n\n\n同时在成功销存后，会向payment服务pub一个创建支付记录的消息，创建publisher的方法很简单，通过`publisher := micro.NewPublisher(\"payment.payevent\", service.Client())`即可创建一个`payment.payevent`主题的Publisher，此后通过`PaymentPublisher.Publish()`方法即可发布消息。\n\n\n### payment 服务\n\n\npayment服务主要在接收到用户成功参与秒杀的消息后，创建此用户对应的订单支付记录，存放数据的payments表结构如下：\n\n\n```text\nCREATE TABLE payments (\n    id SERIAL NOT NULL PRIMARY KEY,\n    sid INTEGER NOT NULL,\n    name VARCHAR(50) NOT NULL DEFAULT '',\n    state INTEGER NOT NULL DEFAULT 1,\n    create_time TIMESTAMP NOT NULL DEFAULT now()\n);\n\nCOMMENT ON COLUMN payment.id IS '主键';\nCOMMENT ON COLUMN payment.sid IS '订单ID';\nCOMMENT ON COLUMN payment.state IS '订单状态';\nCOMMENT ON COLUMN payment.name IS '商品名称';\nCOMMENT ON COLUMN payment.create_time IS '创建时间';\n\n```\n\n\npayment服务提供PayOrder接口，通过payment-web服务的web接口，用户可通过此服务完成支付服务。本微服务需要注意的是通过`micro.RegisterSubscriber(\"payment.payevent\", service.Server(), paymentHandle.Process)`来订阅`payment.payevent`主题接收消息，和对应的处理函数。orders表中的`state`表示了支付和未支付订单状态，用户通过payment-web的rest api完成支付操作后state变为1的记录表示用户支付成功。\n\n\n## 测试\n\n\n为了方便测试，这里也编写了一个[测试程序](https://github.com/wanghaoxi3000/go-secbuy-mirco/tree/master/test)，通过Go语言创建指定数量的协程在同一时间发起秒杀请求，来模拟整个秒杀过程。\n\n\n### 创建商品信息\n\n\n在运行启动整个微服务后，通过micro工具执行如下命令来创建一条商品信息：\n\n\n```text\n micro --registry=mdns call go.micro.secbuy.srv.stock StockService.CreateCommodity '{\"name\":\"商品\",\"count\":10,\"sale\":0}'\n\n```\n\n\n可以看到数据库中多了一条商品信息\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190901010240.png)\n\n\n### 模拟秒杀\n\n\n将测试程序的config.json配置文件配置count项目配置为500，同时创建500个协程来模拟秒杀过程，执行完毕后，测试程序报告500个协程中有10个成功完成了秒杀过程，其余则失败了。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190901010805.png)\n\n\n此时orders和payments表中也正好多了10条订单记录：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190901011135.png)\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190901011359.png)\n\n\n### 模拟支付\n\n\n此时通过postman向`/payment/payorder`接口发送一条`{\"id\":2}`的数据，模拟支付此条订单，根据结果代表已成功支付此订单，payments表中对应ID的state字段也已改变。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190901011840.png)\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190901011336.png)\n\n\n## 完整秒杀系统还应具备的功能\n\n\n本文侧重使用Go-Micro搭建一个秒杀的微服务系统框架，只是完成了一个基础的后台功能。当然对于真正的秒杀系统还是远远不够的。\n\n\n在秒杀系统的开发中还应当注意以下等环节：\n\n1. 启动多个服务通过负载均衡将流量分布到多个应用中，缓解每台机器的压力\n2. 拦截重复调用接口等异常流量\n3. 加入Redis等缓存，将秒杀商品的信息放到缓存中，避免直接查询数据库，缓解数据库的压力\n4. 对于类似秒杀商品发货等的非常耗时的操作，可以使用基于MQ来限流削峰\n",
      "properties": {
        "date": "2019-09-01",
        "type": "Post",
        "category": "项目架构",
        "slug": "seckill-backend-system-base-on-go-micro",
        "tags": [
          "mircoservices",
          "go-mirco",
          "秒杀系统"
        ],
        "summary": "前段时间了解到了Go-micro这一微服务开发框架，并基于此框架的教程搭建了一套码头货运管理微服务系统。这次使用Micro来设计和实现了一套更接地气的秒杀系统。\n\n对于秒杀，以及抽奖、抢红包这类系统的最大特点便是在某个时间点会瞬间涌入大量的用户，给系统造成瞬间高于平时千百倍的并发压力。针对这样的特点在设计微服务时就需要考虑一系列的措施来保障系统在高并发场景时可以稳定运行。\n\n完整代码地址",
        "title": "基于Go-micro微服务的秒杀系统",
        "status": "Published",
        "urlname": "aee256a0-e9d4-45bb-889d-1bca9f2c8251",
        "updated": "2023-07-17 14:33:00"
      },
      "catalog": [
        {
          "title": "2019-09-01",
          "doc_id": "aee256a0-e9d4-45bb-889d-1bca9f2c8251"
        }
      ],
      "body": "",
      "realName": "基于Go-micro微服务的秒杀系统",
      "relativePath": "/2019-09-01/基于Go-micro微服务的秒杀系统.md"
    },
    {
      "id": "8456f952-9d1d-4ebd-8a23-542c69ba7d68",
      "doc_id": "8456f952-9d1d-4ebd-8a23-542c69ba7d68",
      "title": "8456f952-9d1d-4ebd-8a23-542c69ba7d68",
      "updated": 1689575520000,
      "body_original": "\n_项目地址：_[_gin-rtsp_](https://github.com/wanghaoxi3000/gin-rtsp)\n\n\n在后台的开发中遇到了对接显示摄像头视频流的需求。目前获取海康及大华等主流的摄像头的视频流使用的基本都是RTSP协议。不过HTML页面并不能直接播放RTSP协议的视频流，查询了一番各种网页播放RTSP的资料，有如下的一些方案：\n\n- 插件开发播放：使用ActiveX等浏览器插件的方式来播放，海康和大华的浏览器管理页面便是通过安装浏览器插件来播放视频的。视频播放稳定，延时短，但是对技术要求较高，对于chrome等现代浏览器也存在兼容性问题，并不想考虑。\n- RTSP 转 HLS：使用FFMPEG将RTSP转为HLS，推流到流服务器，如安装了`nginx-rtmp-module`模块的nginx，用这个方案测试了下，HLS协议在PC端和移动端的浏览器的播放都很稳，但是用HLS协议的直播流延时很大，至少有15秒左右，对于低延时视频的需求只能PASS。\n- RTSP 转 RTMP：与上一方案类似，使用FFMPEG将RTSP转为RTMP推到流服务器分发播放，相比HLS延时很低，本来已经准备使用这个方案了，但是前端使用的video.js库总是会偶现无法加载视频的问题，而且播放RTMP需要使用到Flash，在chrome等浏览器中已经默认禁止加载逐步淘汰，只能抛弃。\n- WebSocket：最终在万能的`Github`上翻到了一个[**JSMpeg**](https://github.com/phoboslab/jsmpeg/)项目，采用FFMPEG转为MPEG1 Video通过WebSocket代理推送到前端直接解码播放的方案。测试了下，延迟低，无需插件，画面质量也可以根据需要调整，效果很不错。\n\n[**JSMpeg**](https://github.com/phoboslab/jsmpeg/)项目示例的WebSocket代理使用的是JS，简单实现了单个视频源的播放功能。我们的后台使用的是golang的Gin框架，会有多个网页客户端播放多个视频流。好在看了下JS的代码，这个WebSocket代理的原理并不难，在Gin中集成WebSocket也很方便。这里记录下我的集成方案。\n\n\n## 主要模块\n\n- API 接口：接收FFMPEG的推流数据和客户端的HTTP请求，将客户端需要播放的RTSP地址转换为一个对应的WebSocket地址，客户端通过这个WebSocket地址便可以直接播放视频，为了及时释放不再观看的视频流，这里设计为客户端播放时需要在每隔60秒的时间里循环请求这个接口，超过指定时间没有收到请求的话后台便会关闭这个视频流。\n- FFMPEG 视频转换：收到前端的请求后，启动一个Goroutine调用系统的FFMPEG命令转换指定的RTSP视频流并推送到后台对应的接口，自动结束已超时转换任务。\n- WebSocket Manager：管理WebSocket客户端，将请求同一WebSocket地址的客户端添加到一个Group中，向各个Group广播对应的RTSP视频流，删除Group中已断开连接的客户端，释放空闲的Group。\n\n这里大致介绍下这三个主要模块的实现要点。\n\n\n### API 接口\n\n\nAPI接收客户端发送的包含了需要播放RTSP流地址的Json数据，格式如：\n\n\n```text\n{\n    \"url\":\"rtsp://admin:admin@192.168.1.11:554/cam/realmonitor?channel=1&subtype=0\"\n}\n\n```\n\n\n在有多个客户端需要播放相同的RTSP流地址时，需要保证返回对应的WebSocket地址相同，这里使用了UUID v3来将RTSP地址散列化保证返回的地址相同。\n\n\n[service/rtsptrans.go](https://github.com/wanghaoxi3000/gin-rtsp/blob/e19e6ccd39a8f720c1178b9c5b865cdbbbcd13f8/service/rtsptrans.go#L37)\n\n\n```javascript\nprocessCh := uuid.NewV3(uuid.NamespaceURL, splitList[1]).String()\nplayURL := fmt.Sprintf(\"/stream/live/%s\", processCh)\n\n```\n\n\nFFMPEG转换的视频数据也会通过HTTP协议传回服务端，每帧byte数据会以`'\\n'`结束，在go语言中可以通过`bufio`模块来读出这样的数据。\n\n\n[api/rtsp.go](https://github.com/wanghaoxi3000/gin-rtsp/blob/e19e6ccd39a8f720c1178b9c5b865cdbbbcd13f8/api/rtsp.go#L24)\n\n\n```javascript\nbodyReader := bufio.NewReader(c.Request.Body)\n\nfor {\n\tdata, err := bodyReader.ReadBytes('\\n')\n\tif err != nil {\n\t\tbreak\n\t}\n}\n\n```\n\n\n### FFMPEG 视频转换\n\n\n视频转换模块会在收到需要转换的RTSP流地址后，启动一个FFMPEG子进程来转换RTSP视频流，这里是使用`exec.Command`来完成：\n\n\n[service/rtsptrans.go](https://github.com/wanghaoxi3000/gin-rtsp/blob/ae4ae486c002574161193fd8a7cb8b7dd15b8044/service/rtsptrans.go#L57)\n\n\n```text\nparams := []string{\n\t\"-rtsp_transport\",\n\t\"tcp\",\n\t\"-re\",\n\t\"-i\",\n\trtsp,\n\t\"-q\",\n\t\"5\",\n\t\"-f\",\n\t\"mpegts\",\n\t\"-fflags\",\n\t\"nobuffer\",\n\t\"-c:v\",\n\t\"mpeg1video\",\n\t\"-an\",\n\t\"-s\",\n\t\"960x540\",\n\tfmt.Sprintf(\"http://127.0.0.1:3000/stream/upload/%s\", playCh),\n}\n\ncmd := exec.Command(\"ffmpeg\", params...)\ncmd.Stdout = nil\ncmd.Stderr = nil\nstdin, err := cmd.StdinPipe()\n\n```\n\n\n通过FFMPEG的 -q 和 -s 参数可以调试视频的质量和分辨率。为了简便，命令的stdout和stderr都赋值为了nil，实际项目中可以保存到日志中方便排查问题。为了及时释放不再播放的资源，客户端停止请求超过一定时间后，FFMPEG子进程会自动关闭，通过golang的select可以很方便的实现这个功能。\n\n\n[service/rtsptrans.go](https://github.com/wanghaoxi3000/gin-rtsp/blob/ae4ae486c002574161193fd8a7cb8b7dd15b8044/service/rtsptrans.go#L94)\n\n\n```text\nfor {\n\tselect {\n\tcase <-*ch:\n\t\tutil.Log().Info(\"reflush channel %s rtsp %v\", playCh, rtsp)\n\n\tcase <-time.After(60 * time.Second):\n\t\tstdin.Write([]byte(\"q\"))\n\t\terr = cmd.Wait()\n\t\tif err != nil {\n\t\t\tutil.Log().Error(\"Run ffmpeg err:%v\", err.Error)\n\t\t}\n\t\treturn\n\t}\n}\n\n```\n\n\n这里的`*ch` channel通过一个map和每个子进程关联，子进程关闭时需要从map中清除，需要考虑并发的问题，可以使用`sync.Map`来保证线程安全。\n\n\n### WebSocket Manager\n\n\nWebSocket Manager 负责对页面上请求视频数据的 ws 客户端进行管理，在Gin中，主要是使用`github.com/gorilla/websocket`这个库来开发相关功能。**JSMpeg**库连接WebSocket时使用到了`Sec-WebSocket-Protocol`这个header，需要对其处理：\n\n\n```text\nupgrader := websocket.Upgrader{\n\t// cross origin domain\n\tCheckOrigin: func(r *http.Request) bool {\n\t\treturn true\n\t},\n\t// 处理 Sec-WebSocket-Protocol Header\n\tSubprotocols: []string{ctx.GetHeader(\"Sec-WebSocket-Protocol\")},\n}\nconn, err := upgrader.Upgrade(ctx.Writer, ctx.Request, nil)\n\n```\n\n\nws 客户端连接后，会分配一个唯一的UUID，放入到URL对应的Group中，相同Group下的客户端会收到同一视频流的数据。客户端断开连接后，需要从Group中删除，同时释放掉已经为空的Group。这个过程同样需要考虑到并发的问题，WebSocket Manager通过单独启动一个Goroutine监听注册，断开连接，广播的三个对应的golang的channel，来统一管理各个Group，可以很好的解决这个问题。具体实现在 [service/wsservice.go#L75](https://github.com/wanghaoxi3000/gin-rtsp/blob/ae4ae486c002574161193fd8a7cb8b7dd15b8044/service/wsservice.go#L75)，代码比较长就不贴了。\n\n\n## 测试\n\n\n项目需要运行在安装有FFMPEG程序的环境中。通过编写了一份Dockerfile已经封装好了需要的环境，可以使用Docker build后，以Docker的方式运行。\n\n\n```text\n$ docker build -t ginrtsp .\n$ docker run -td -p 3000:3000 ginrtsp\n\n```\n\n\n### 使用内置的FFMPEG转换\n\n\n将需要播放的RTSP流地址提交到 /stream/play 接口，例如：\n\n\n```text\nPOST /stream/play\n{\n   \"url\": \"rtsp://admin:password@192.168.3.10:554/cam/realmonitor?channel=1&subtype=0\"\n}\n\n```\n\n\n后台可以正常转换此RTSP地址时便会返回一个对应的地址，例如：\n\n\n```text\n{\n    \"code\": 0,\n    \"data\": {\n        \"path\": \"/stream/live/5b96bff4-bdb2-3edb-9d6e-f96eda03da56\"\n    },\n    \"msg\": \"success\"\n}\n\n```\n\n\n编辑`html`文件夹下view-stream.html文件，将script部分的url修改为此地址，在浏览器中打开，便可以看到视频了。\n\n\n### 手动运行FFMPEG\n\n\n由于后台转换RTSP的进程在超过60秒没有请求后便会停止，也可以通过手动运行ffmpeg命令，来更方便地在测试状态下查看视频。\n\n\n```text\nffmpeg -rtsp_transport tcp -re -i 'rtsp://admin:password@192.168.3.10:554/cam/realmonitor?channel=1&subtype=0' -q 0 -f mpegts -c:v mpeg1video -an -s 960x540 http://127.0.0.1:3000/stream/upload/test\n\n```\n\n\n通过如上命令，运行之后在view-stream.html文件的url中填入对应的地址为/stream/upload/test，在浏览器中打开查看视频。\n\n\n显示效果\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20191218160012.png)\n\n\n## 总结\n\n\n得益于**JSMpeg**项目的强大，实现一个WebSocket的在网页上播放RTSP视频流还是很简单的了。随着golang语言日渐成熟，基于现成的库也可以方便的在Gin中添加WebSocket功能。需要注意主要是并发时，对FFMPEG子进程，WebSocket客户端的增删问题，好在golang天生对并发有良好的支持，gouroutine，channel，sync库这些golang核心知识掌握好了便可很好的应对这些问题。\n\n",
      "properties": {
        "date": "2019-12-18",
        "type": "Post",
        "category": "项目架构",
        "slug": "use-gin-and-websocket-to-play-rtsp-video",
        "tags": [
          "Gin",
          "WebSocket",
          "RTSP",
          "Go"
        ],
        "summary": "项目地址：gin-rtsp\n\n在后台的开发中遇到了对接显示摄像头视频流的需求。目前获取海康及大华等主流的摄像头的视频流使用的基本都是RTSP协议。不过HTML页面并不能直接播放RTSP协议的视频流，查询了一番各种网页播放RTSP的资料，有如下的一些方案：",
        "title": "使用Gin+WebSocket在HTML中无插件播放RTSP",
        "status": "Published",
        "urlname": "8456f952-9d1d-4ebd-8a23-542c69ba7d68",
        "updated": "2023-07-17 14:32:00"
      },
      "catalog": [
        {
          "title": "2019-12-18",
          "doc_id": "8456f952-9d1d-4ebd-8a23-542c69ba7d68"
        }
      ],
      "body": "",
      "realName": "使用Gin+WebSocket在HTML中无插件播放RTSP",
      "relativePath": "/2019-12-18/使用Gin+WebSocket在HTML中无插件播放RTSP.md"
    },
    {
      "id": "0498bc63-4538-4d18-94f2-6edf9b92f43f",
      "doc_id": "0498bc63-4538-4d18-94f2-6edf9b92f43f",
      "title": "0498bc63-4538-4d18-94f2-6edf9b92f43f",
      "updated": 1689696300000,
      "body_original": "\n转载至 [https://www.cnblogs.com/qcrao-2018/p/11442998.html](https://www.cnblogs.com/qcrao-2018/p/11442998.html), 一篇很不错讲解 Golang scheduler 的文章。\n\n\n> 在 Go 语言里，go func 是并发的单元，chan 是协调并发单元的机制，panic 和 recover 是出错处理的机制，而 defer 是神来之笔，大大简化了出错的管理。\n\n\nGoroutines 在同一个用户空间里同时独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。\n\n\n## 前置知识\n\n\n### os scheduler\n\n\n从操作系统角度看，我们写的程序最终都会转换成一系列的机器指令，机器只要按顺序执行完所有的指令就算完成了任务。完成“按顺序执行指令”任务的实体就是线程，也就是说，线程是 CPU 调度的实体，线程是真正在 CPU 上执行指令的实体。\n\n\n每个程序启动的时候，都会创建一个初始进程，并且启动一个线程。而线程可以去创建更多的线程，这些线程可以独立地执行，CPU 在这一层进行调度，而非进程。\n\n\nOS scheduler 保证如果有可以执行的线程时，就不会让 CPU 闲着。并且它还要保证，所有可执行的线程都看起来在同时执行。另外，OS scheduler 在保证高优先级的线程执行机会大于低优先级线程的同时，不能让低优先级的线程始终得不到执行的机会。OS scheduler 还需要做到迅速决策，以降低延时。\n\n\n### 线程切换\n\n\nOS scheduler 调度线程的依据就是它的状态，线程有三种状态（简化模型）：`Waiting`, `Runnable` or `Executing`。\n\n\n| 状态        | 解释                                                                         |\n| --------- | -------------------------------------------------------------------------- |\n| Waiting   | 等待状态。线程在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes |\n| Runnable  | 就绪状态。只要给 CPU 资源我就能运行                                                       |\n| Executing | 运行状态。线程在执行指令，这是我们想要的                                                       |\n\n\n线程能做的事一般分为两种：计算型、IO 型。\n\n\n计算型主要是占用 CPU 资源，一直在做计算任务，例如对一个大数做质数分解。这种类型的任务不会让线程跳到 Waiting 状态。\n\n\nIO 型则是要获取外界资源，例如通过网络、系统调用等方式。内存同步访问控制原语：mutexes 也可以看作这种类型。共同特点是需要等待外界资源就绪。IO 型的任务会让线程跳到 Waiting 状态。\n\n\n线程切换就是操作系统用一个处于 Runnable 的线程将 CPU 上正在运行的处于 Executing 状态的线程换下来的过程。新上场的线程会变成 Executing 状态，而下场的线程则可能变成 Waiting 或 Runnable 状态。正在做计算型任务的线程，会变成 Runnable 状态；正在做 IO 型任务的线程，则会变成 Waiting 状态。\n\n\n因此，计算密集型任务和 IO 密集型任务对线程切换的“态度”是不一样的。由于计算型密集型任务一直都有任务要做，或者说它一直有指令要执行，线程切换的过程会让它停掉当前的任务，损失非常大。\n\n\n相反，专注于 IO 密集型的任务的线程，如果它因为某个操作而跳到 Waiting 状态，那么把它从 CPU 上换下，对它而言是没有影响的。而且，新换上来的线程可以继续利用 CPU 完成任务。从整个操作系统来看，“工作进度”是往前的。\n\n\n记住，对于 OS scheduler 来说，最重要的是不要让一个 CPU 核心闲着，尽量让每个 CPU 核心都有任务可做。\n\n\n> If you have a program that is focused on IO\\-Bound work, then context switches are going to be an advantage. Once a Thread moves into a Waiting state, another Thread in a Runnable state is there to take its place. This allows the core to always be doing work. This is one of the most important aspects of scheduling. Don’t allow a core to go idle if there is work (Threads in a Runnable state) to be done.\n\n\n### 函数调用过程分析\n\n\n要想理解 Go scheduler 的底层原理，对于函数调用过程的理解是必不可少的。它涉及到函数参数的传递，CPU 的指令跳转，函数返回值的传递等等。这需要对汇编语言有一定的了解，因为只有汇编语言才能进行像寄存器赋值这样的底层操作。之前的一些文章里也有说明，这里再来复习一遍。\n\n\n> 函数栈帧的空间主要由函数参数和返回值、局部变量和被调用其它函数的参数和返回值空间组成。\n\n\n宏观看一下，Go 语言中函数调用的规范，引用曹大博客里的一张图：\n\n\n![曹大 asmshare 函数调用规范](https://static-1256611153.file.myqcloud.com/img/picgo/20200101160154.png)\n\n\nGo plan9 汇编通过栈传递函数参数和返回值。\n\n\n调用子函数时，先将参数在栈顶准备好，再执行 CALL 指令。CALL 指令会将 IP 寄存器的值压栈，这个值就是函数调用完成后即将执行的下一条指令。\n\n\n然后，就会进入被调用者的栈帧。首先会将 caller BP 压栈，这表示栈基址，也就是栈底。栈顶和栈基址定义函数的栈帧。\n\n\n> CALL 指令类似 PUSH IP 和 JMP somefunc 两个指令的组合，首先将当前的 IP 指令寄存器的值压入栈中，然后通过 JMP 指令将要调用函数的地址写入到 IP 寄存器实现跳转。\n\n\n> 而 RET 指令则是和 CALL 相反的操作，基本和 POP IP 指令等价，也就是将执行 CALL 指令时保存在 SP 中的返回地址重新载入到 IP 寄存器，实现函数的返回。\n\n\n> 首先是调用函数前准备的输入参数和返回值空间。然后 CALL 指令将首先触发返回地址入栈操作。在进入到被调用函数内之后，汇编器自动插入了 BP 寄存器相关的指令，因此 BP 寄存器和返回地址是紧挨着的。再下面就是当前函数的局部变量的空间，包含再次调用其它函数需要准备的调用参数空间。被调用的函数执行 RET 返回指令时，先从栈恢复 BP 和 SP 寄存器，接着取出的返回地址跳转到对应的指令执行。\n\n\n上面两段描述来自《Go 语言高级编程》一书的汇编语言章节，说得很好，再次推荐阅读。\n\n\n## goroutine 是怎么工作的\n\n\n### 什么是 goroutine\n\n\nGoroutine 可以看作对 thread 加的一层抽象，它更轻量级，可以单独执行。因为有了这层抽象，Gopher 不会直接面对 thread，我们只会看到代码里满天飞的 goroutine。操作系统却相反，管你什么 goroutine，我才没空理会。我安心地执行线程就可以了，线程才是我调度的基本单位。\n\n\n### goroutine 和 thread 的区别\n\n\n谈到 goroutine，绕不开的一个话题是：它和 thread 有什么区别？\n\n\n参考资料【How Goroutines Work】告诉我们可以从三个角度区别：内存消耗、创建与销毀、切换。\n\n- 内存占用\n\n创建一个 goroutine 的栈内存消耗为 2 KB，实际运行过程中，如果栈空间不够用，会自动进行扩容。创建一个 thread 则需要消耗 1 MB 栈内存，而且还需要一个被称为 “a guard page” 的区域用于和其他 thread 的栈空间进行隔离。\n\n\n对于一个用 Go 构建的 HTTP Server 而言，对到来的每个请求，创建一个 goroutine 用来处理是非常轻松的一件事。而如果用一个使用线程作为并发原语的语言构建的服务，例如 Java 来说，每个请求对应一个线程则太浪费资源了，很快就会出 OOM 错误（OutOfMermoryError）。\n\n- 创建和销毀\n\nThread 创建和销毀都会有巨大的消耗，因为要和操作系统打交道，是内核级的，通常解决的办法就是线程池。而 goroutine 因为是由 Go runtime 负责管理的，创建和销毁的消耗非常小，是用户级。\n\n- 切换\n\n当 threads 切换时，需要保存各种寄存器，以便将来恢复：\n\n\n> 16 general purpose registers, PC (Program Counter), SP (Stack Pointer), segment registers, 16 XMM registers, FP coprocessor state, 16 AVX registers, all MSRs etc.\n\n\n而 goroutines 切换只需保存三个寄存器：Program Counter, Stack Pointer and BP。\n\n\n一般而言，线程切换会消耗 1000\\-1500 纳秒，一个纳秒平均可以执行 12\\-18 条指令。所以由于线程切换，执行指令的条数会减少 12000\\-18000。\n\n\nGoroutine 的切换约为 200 ns，相当于 2400\\-3600 条指令。\n\n\n因此，goroutines 切换成本比 threads 要小得多。\n\n\n### M:N 模型\n\n\n我们都知道，Go runtime 会负责 goroutine 的生老病死，从创建到销毁，都一手包办。Runtime 会在程序启动的时候，创建 M 个线程（CPU 执行调度的单位），之后创建的 N 个 goroutine 都会依附在这 M 个线程上执行。这就是 M:N 模型：\n\n\n![M:N scheduling](https://static-1256611153.file.myqcloud.com/img/picgo/20200101161011.png)\n\n\n在同一时刻，一个线程上只能跑一个 goroutine。当 goroutine 发生阻塞（例如上篇文章提到的向一个 channel 发送数据，被阻塞）时，runtime 会把当前 goroutine 调度走，让其他 goroutine 来执行。目的就是不让一个线程闲着，榨干 CPU 的每一滴油水。\n\n\n### 什么是 scheduler\n\n\nGo 程序的执行由两层组成：Go Program，Runtime，即用户程序和运行时。它们之间通过函数调用来实现内存管理、channel 通信、goroutines 创建等功能。用户程序进行的系统调用都会被 Runtime 拦截，以此来帮助它进行调度以及垃圾回收相关的工作。\n\n\n一个展现了全景式的关系如下图：\n\n\n![runtime overall](https://static-1256611153.file.myqcloud.com/img/picgo/20200101161329.png)\n\n\n### 为什么要 scheduler\n\n\nGo scheduler 可以说是 Go 运行时的一个最重要的部分了。Runtime 维护所有的 goroutines，并通过 scheduler 来进行调度。Goroutines 和 threads 是独立的，但是 goroutines 要依赖 threads 才能执行。\n\n\nGo 程序执行的高效和 scheduler 的调度是分不开的。\n\n\n### scheduler 底层原理\n\n\n实际上在操作系统看来，所有的程序都是在执行多线程。将 goroutines 调度到线程上执行，仅仅是 runtime 层面的一个概念，在操作系统之上的层面。\n\n\n有三个基础的结构体来实现 goroutines 的调度。g，m，p。\n\n\n`g` 代表一个 goroutine，它包含：表示 goroutine 栈的一些字段，指示当前 goroutine 的状态，指示当前运行到的指令地址，也就是 PC 值。\n\n\n`m` 表示内核线程，包含正在运行的 goroutine 等字段。\n\n\n`p` 代表一个虚拟的 Processor，它维护一个处于 Runnable 状态的 g 队列，`m` 需要获得 `p` 才能运行 `g`。\n\n\n当然还有一个核心的结构体：`sched`，它总览全局。\n\n\nRuntime 起始时会启动一些 G：垃圾回收的 G，执行调度的 G，运行用户代码的 G；并且会创建一个 M 用来开始 G 的运行。随着时间的推移，更多的 G 会被创建出来，更多的 M 也会被创建出来。\n\n\n当然，在 Go 的早期版本，并没有 p 这个结构体，`m` 必须从一个全局的队列里获取要运行的 `g`，因此需要获取一个全局的锁，当并发量大的时候，锁就成了瓶颈。后来在大神 Dmitry Vyokov 的实现里，加上了 `p` 结构体。每个 `p` 自己维护一个处于 Runnable 状态的 `g` 的队列，解决了原来的全局锁问题。\n\n\nGo scheduler 的目标：\n\n\n> For scheduling goroutines onto kernel threads.\n\n\n![Go scheduler goals](https://static-1256611153.file.myqcloud.com/img/picgo/20200101162735.png)\n\n\nGo scheduler 的核心思想是：\n\n1. reuse threads；\n2. 限制同时运行（不包含阻塞）的线程数为 N，N 等于 CPU 的核心数目；\n3. 线程私有的 runqueues，并且可以从其他线程 stealing goroutine 来运行，线程阻塞后，可以将 runqueues 传递给其他线程。\n\n为什么需要 P 这个组件，直接把 runqueues 放到 M 不行吗？\n\n\n> You might wonder now, why have contexts at all? Can't we just put the runqueues on the threads and get rid of contexts? Not really. The reason we have contexts is so that we can hand them off to other threads if the running thread needs to block for some reason.\n\n\n> An example of when we need to block, is when we call into a syscall. Since a thread cannot both be executing code and be blocked on a syscall, we need to hand off the context so it can keep scheduling.\n\n\n翻译一下，当一个线程阻塞的时候，将和它绑定的 P 上的 goroutines 转移到其他线程。\n\n\nGo scheduler 会启动一个后台线程 sysmon，用来检测长时间（超过 10 ms）运行的 goroutine，将其调度到 global runqueues。这是一个全局的 runqueue，优先级比较低，以示惩罚。\n\n\n![Go scheduler limitations](https://user-images.githubusercontent.com/7698088/61874781-d55b0280-af1b-11e9-9965-da4efe53d2db.png)\n\n\n## 总览\n\n\n通常讲到 Go scheduler 都会提到 GPM 模型，我们来一个个地看。\n\n\n下图是我使用的 mac 的硬件信息，只有 2 个核。\n\n\n![mac 硬件信息](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163210.png)\n\n\n但是配上 CPU 的超线程，1 个核可以变成 2 个，所以当我在 mac 上运行下面的程序时，会打印出 4。\n\n\n```text\nfunc main() {\n    // NumCPU 返回当前进程可以用到的逻辑核心数\n    fmt.Println(runtime.NumCPU())\n}\n\n```\n\n\n因为 NumCPU 返回的是逻辑核心数，而非物理核心数，所以最终结果是 4。\n\n\nGo 程序启动后，会给每个逻辑核心分配一个 P（Logical Processor）；同时，会给每个 P 分配一个 M（Machine，表示内核线程），这些内核线程仍然由 OS scheduler 来调度。\n\n\n总结一下，当我在本地启动一个 Go 程序时，会得到 4 个系统线程去执行任务，每个线程会搭配一个 P。\n\n\n在初始化时，Go 程序会有一个 G（initial Goroutine），执行指令的单位。G 会在 M 上得到执行，内核线程是在 CPU 核心上调度，而 G 则是在 M 上进行调度。\n\n\nG、P、M 都说完了，还有两个比较重要的组件没有提到： 全局可运行队列（GRQ）和本地可运行队列（LRQ）。 LRQ 存储本地（也就是具体的 P）的可运行 goroutine，GRQ 存储全局的可运行 goroutine，这些 goroutine 还没有分配到具体的 P。\n\n\n![GPM global review](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163511.png)\n\n\nGo scheduler 是 Go runtime 的一部分，它内嵌在 Go 程序里，和 Go 程序一起运行。因此它运行在用户空间，在 kernel 的上一层。和 Os scheduler 抢占式调度（preemptive）不一样，Go scheduler 采用协作式调度（cooperating）。\n\n\n> Being a cooperating scheduler means the scheduler needs well\\-defined user space events that happen at safe points in the code to make scheduling decisions.\n\n\n协作式调度一般会由用户设置调度点，例如 python 中的 yield 会告诉 Os scheduler 可以将我调度出去了。\n\n\n但是由于在 Go 语言里，goroutine 调度的事情是由 Go runtime 来做，并非由用户控制，所以我们依然可以将 Go scheduler 看成是抢占式调度，因为用户无法预测调度器下一步的动作是什么。\n\n\n和线程类似，goroutine 的状态也是三种（简化版的）：\n\n\n| 状态        | 解释                                                                                 |\n| --------- | ---------------------------------------------------------------------------------- |\n| Waiting   | 等待状态，goroutine 在等待某件事的发生。例如等待网络数据、硬盘；调用操作系统 API；等待内存同步访问条件 ready，如 atomic, mutexes |\n| Runnable  | 就绪状态，只要给 M 我就可以运行                                                                  |\n| Executing | 运行状态。goroutine 在 M 上执行指令，这是我们想要的                                                   |\n\n\n下面这张 GPM 全局的运行示意图见得比较多，可以留着，看完后面的系列文章之后再回头来看，还是很有感触的：\n\n\n![goroutine workflow](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163615.png)\n\n\n### goroutine 调度时机\n\n\n在四种情形下，goroutine 可能会发生调度，但也并不一定会发生，只是说 Go scheduler 有机会进行调度。\n\n\n| 情形         | 说明                                                                                                                 |\n| ---------- | ------------------------------------------------------------------------------------------------------------------ |\n| 使用关键字 `go` | go 创建一个新的 goroutine，Go scheduler 会考虑调度                                                                             |\n| GC         | 由于进行 GC 的 goroutine 也需要在 M 上运行，因此肯定会发生调度。当然，Go scheduler 还会做很多其他的调度，例如调度不涉及堆访问的 goroutine 来运行。GC 不管栈上的内存，只会回收堆上的内存 |\n| 系统调用       | 当 goroutine 进行系统调用时，会阻塞 M，所以它会被调度走，同时一个新的 goroutine 会被调度上来                                                         |\n| 内存同步访问     | atomic，mutex，channel 操作等会使 goroutine 阻塞，因此会被调度走。等条件满足后（例如其他 goroutine 解锁了）还会被调度上来继续运行                              |\n\n\n### work stealing\n\n\nGo scheduler 的职责就是将所有处于 runnable 的 goroutines 均匀分布到在 P 上运行的 M。\n\n\n当一个 P 发现自己的 LRQ 已经没有 G 时，会从其他 P “偷” 一些 G 来运行。看看这是什么精神！自己的工作做完了，为了全局的利益，主动为别人分担。这被称为 `Work-stealing`，Go 从 1.1 开始实现。\n\n\nGo scheduler 使用 M:N 模型，在任一时刻，M 个 goroutines（G） 要分配到 N 个内核线程（M），这些 M 跑在个数最多为 GOMAXPROCS 的逻辑处理器（P）上。每个 M 必须依附于一个 P，每个 P 在同一时刻只能运行一个 M。如果 P 上的 M 阻塞了，那它就需要其他的 M 来运行 P 的 LRQ 里的 goroutines。\n\n\n![GPM relatioship](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163711.png)\n\n\n个人感觉，上面这张图比常见的那些用三角形表示 M，圆形表示 G，矩形表示 P 的那些图更生动形象。\n\n\n实际上，Go scheduler 每一轮调度要做的工作就是找到处于 runnable 的 goroutines，并执行它。找的顺序如下：\n\n\n```go\nruntime.schedule() {\n    // only 1/61 of the time, check the global runnable queue for a G.\n    // if not found, check the local queue.\n    // if not found,\n    //     try to steal from other Ps.\n    //     if not, check the global runnable queue.\n    //     if not found, poll network.\n}\n\n```\n\n\n找到一个可执行的 goroutine 后，就会一直执行下去，直到被阻塞。\n\n\n当 P2 上的一个 G 执行结束，它就会去 LRQ 获取下一个 G 来执行。如果 LRQ 已经空了，就是说本地可运行队列已经没有 G 需要执行，并且这时 GRQ 也没有 G 了。这时，P2 会随机选择一个 P（称为 P1），P2 会从 P1 的 LRQ “偷”过来一半的 G。\n\n\n![Work Stealing](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163744.png)\n\n\n这样做的好处是，有更多的 P 可以一起工作，加速执行完所有的 G。\n\n\n### 同步/异步系统调用\n\n\n当 G 需要进行系统调用时，根据调用的类型，它所依附的 M 有两种情况：`同步`和`异步`。\n\n\n对于同步的情况，M 会被阻塞，进而从 P 上调度下来，P 可不养闲人，G 仍然依附于 M。之后，一个新的 M 会被调用到 P 上，接着执行 P 的 LRQ 里嗷嗷待哺的 G 们。一旦系统调用完成，G 还会加入到 P 的 LRQ 里，M 则会被“雪藏”，待到需要时再“放”出来。\n\n\n![同步系统调用](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163821.png)\n\n\n对于异步的情况，M 不会被阻塞，G 的异步请求会被“代理人” network poller 接手，G 也会被绑定到 network poller，等到系统调用结束，G 才会重新回到 P 上。M 由于没被阻塞，它因此可以继续执行 LRQ 里的其他 G。\n\n\n![异步系统调用](https://static-1256611153.file.myqcloud.com/img/picgo/20200101163851.png)\n\n\n可以看到，异步情况下，通过调度，Go scheduler 成功地将 I/O 的任务转变成了 CPU 任务，或者说将内核级别的线程切换转变成了用户级别的 goroutine 切换，大大提高了效率。\n\n\n> The ability to turn IO/Blocking work into CPU\\-bound work at the OS level is where we get a big win in leveraging more CPU capacity over time.\n\n\nGo scheduler 像一个非常苛刻的监工一样，不会让一个 M 闲着，总是会通过各种办法让你干更多的事。\n\n\n> In Go, it’s possible to get more work done, over time, because the Go scheduler attempts to use less Threads and do more on each Thread, which helps to reduce load on the OS and the hardware.\n\n\n### scheduler 的陷阱\n\n\n由于 Go 语言是协作式的调度，不会像线程那样，在时间片用完后，由 CPU 中断任务强行将其调度走。对于 Go 语言中运行时间过长的 goroutine，Go scheduler 有一个后台线程在持续监控，一旦发现 goroutine 运行超过 10 ms，会设置 goroutine 的“抢占标志位”，之后调度器会处理。但是设置标志位的时机只有在函数“序言”部分，对于没有函数调用的就没有办法了。\n\n\n> Golang implements a co\\-operative partially preemptive scheduler.\n\n\n所以在某些极端情况下，会掉进一些陷阱。下面这个例子来自参考资料【scheduler 的陷阱】。\n\n\n```go\nfunc main() {\n    var x int\n    threads := runtime.GOMAXPROCS(0)\n    for i := 0; i < threads; i++ {\n        go func() {\n            for { x++ }\n        }()\n    }\n    time.Sleep(time.Second)\n    fmt.Println(\"x =\", x)\n}\n\n```\n\n\n运行结果是：在死循环里出不来，不会输出最后的那条打印语句。\n\n\n为什么？上面的例子会启动和机器的 CPU 核心数相等的 goroutine，每个 goroutine 都会执行一个无限循环。\n\n\n创建完这些 goroutines 后，main 函数里执行一条 `time.Sleep(time.Second)` 语句。Go scheduler 看到这条语句后，简直高兴坏了，要来活了。这是调度的好时机啊，于是主 goroutine 被调度走。先前创建的 `threads` 个 goroutines，刚好“一个萝卜一个坑”，把 M 和 P 都占满了。\n\n\n在这些 goroutine 内部，又没有调用一些诸如 `channel`，`time.sleep` 这些会引发调度器工作的事情。麻烦了，只能任由这些无限循环执行下去了。\n\n\n解决的办法也有，把 threads 减小 1：\n\n\n```go\nfunc main() {\n    var x int\n    threads := runtime.GOMAXPROCS(0) - 1\n    for i := 0; i < threads; i++ {\n        go func() {\n            for { x++ }\n        }()\n    }\n    time.Sleep(time.Second)\n    fmt.Println(\"x =\", x)\n}\n```\n\n\n运行结果：\n\n\n```text\nx = 0\n```\n\n\n不难理解了吧，主 goroutine 休眠一秒后，被 go schduler 重新唤醒，调度到 M 上继续执行，打印一行语句后，退出。主 goroutine 退出后，其他所有的 goroutine 都必须跟着退出。所谓“覆巢之下 焉有完卵”，一损俱损。\n\n\n至于为什么最后打印出的 x 为 0，之前的文章[《曹大谈内存重排》](https://qcrao.com/2019/06/17/cch-says-memory-reorder/)里有讲到过，这里不再深究了。\n\n\n还有一种解决办法是在 for 循环里加一句：\n\n\n```go\ngo func() {\n    time.Sleep(time.Second)\n    for { x++ }\n}()\n```\n\n\n同样可以让 main goroutine 有机会调度执行。\n\n\n## 总结\n\n\n这篇文章，从宏观角度来看 Go 调度器，讲到了很多方面。接下来连续的 10 篇文章，我会深入源码，层层解析。敬请期待！\n\n\n参考资料里有很多篇英文博客写得很好，当你掌握了基本原理后，看这些文章会有一种熟悉的感觉，讲得真好！\n\n\n## 参考资料\n\n\n【知乎回答，怎样理解阻塞非阻塞与同步异步的区别】https://www.zhihu.com/question/19732473/answer/241673170\n\n\n【从零开始学架构 Reactor与Proactor】https://book.douban.com/subject/30335935/\n\n\n【思否上 goalng 排名第二的大佬译文】https://segmentfault.com/a/1190000016038785\n\n\n【ardan labs】https://www.ardanlabs.com/blog/2018/08/scheduling\\-in\\-go\\-part1.html\n\n\n【论文 Analysis of the Go runtime scheduler】http://www.cs.columbia.edu/~aho/cs6998/reports/12\\-12\\-11_DeshpandeSponslerWeiss_GO.pdf\n\n\n【译文传播很广的】https://morsmachine.dk/go\\-scheduler\n\n\n【码农翻身文章】https://mp.weixin.qq.com/s/BV25ngvWgbO3_yMK7eHhew\n\n\n【goroutine 资料合集】https://github.com/ardanlabs/gotraining/tree/master/topics/go/concurrency/goroutines\n\n\n【大彬调度器系列文章】http://lessisbetter.site/2019/03/10/golang\\-scheduler\\-1\\-history/\n\n\n【Scalable scheduler design doc 2012】https://docs.google.com/document/d/1TTj4T2JO42uD5ID9e89oa0sLKhJYD0Y_kqxDv3I3XMw/edit#heading=h.rvfa6uqbq68u\n\n\n【Go scheduler blog post】https://morsmachine.dk/go\\-scheduler\n\n\n【work stealing】https://rakyll.org/scheduler/\n\n\n【Tony Bai 也谈goroutine调度器】https://tonybai.com/2017/06/23/an\\-intro\\-about\\-goroutine\\-scheduler/\n\n\n【Tony Bai 调试实例分析】https://tonybai.com/2017/11/23/the\\-simple\\-analysis\\-of\\-goroutine\\-schedule\\-examples/\n\n\n【Tony Bai goroutine 是如何工作的】https://tonybai.com/2014/11/15/how\\-goroutines\\-work/\n\n\n【How Goroutines Work】https://blog.nindalf.com/posts/how\\-goroutines\\-work/\n\n\n【知乎回答 什么是阻塞，非阻塞，同步，异步？】https://www.zhihu.com/question/26393784/answer/328707302\n\n\n【知乎文章 完全理解同步/异步与阻塞/非阻塞】https://zhuanlan.zhihu.com/p/22707398\n\n\n【The Go netpoller】https://morsmachine.dk/netpoller\n\n\n【知乎专栏 Head First of Golang Scheduler】https://zhuanlan.zhihu.com/p/42057783\n\n\n【鸟窝 五种 IO 模型】https://colobu.com/2019/07/26/IO\\-models/\n\n\n【Go Runtime Scheduler】https://speakerdeck.com/retervision/go\\-runtime\\-scheduler?slide=32\n\n\n【go\\-scheduler】https://povilasv.me/go\\-scheduler/#\n\n\n【追踪 scheduler】https://www.ardanlabs.com/blog/2015/02/scheduler\\-tracing\\-in\\-go.html\n\n\n【go tool trace 使用】https://making.pusher.com/go\\-tool\\-trace/\n\n\n【goroutine 之旅】https://medium.com/@riteeksrivastava/a\\-complete\\-journey\\-with\\-goroutines\\-8472630c7f5c\n\n\n【介绍 concurreny 和 parallelism 区别的视频】https://www.youtube.com/watch?v=cN_DpYBzKso&t=422s\n\n\n【scheduler 的陷阱】http://www.sarathlakshman.com/2016/06/15/pitfall\\-of\\-golang\\-scheduler\n\n\n【boya 源码阅读】https://github.com/zboya/golang_runtime_reading/blob/master/src/runtime/proc.go\n\n\n【阿波张调度器系列教程】http://mp.weixin.qq.com/mp/homepage?__biz=MzU1OTg5NDkzOA==&hid=1&sn=8fc2b63f53559bc0cee292ce629c4788&scene=18#wechat_redirect\n\n\n【曹大 asmshare】https://github.com/cch123/asmshare/blob/master/layout.md\n\n\n【Go调度器介绍和容易忽视的问题】https://www.cnblogs.com/CodeWithTxT/p/11370215.html\n\n\n【最近发现的一位大佬的源码分析】https://github.com/changkun/go\\-under\\-the\\-hood/blob/master/book/zh\\-cn/TOC.md\n\n",
      "properties": {
        "date": "2020-01-01",
        "type": "Post",
        "category": "Golang",
        "slug": "golang-scheduler",
        "tags": [
          "Golang 底层",
          "Golang scheduler"
        ],
        "summary": "转载至 https://www.cnblogs.com/qcrao-2018/p/11442998.html, 一篇很不错讲解 Golang scheduler 的文章。\n\n在 Go 语言里，go func 是并发的单元，chan 是协调并发单元的机制，panic 和 recover 是出错处理的机制，而 defer 是神来之笔，大大简化了出错的管理。\n\nGoroutines 在同一个用户空间里同时独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。",
        "title": "[转载]深度解密Go语言之 scheduler",
        "status": "Published",
        "urlname": "0498bc63-4538-4d18-94f2-6edf9b92f43f",
        "updated": "2023-07-19 00:05:00"
      },
      "catalog": [
        {
          "title": "2020-01-01",
          "doc_id": "0498bc63-4538-4d18-94f2-6edf9b92f43f"
        }
      ],
      "body": "",
      "realName": "[转载]深度解密Go语言之 scheduler",
      "relativePath": "/2020-01-01/[转载]深度解密Go语言之 scheduler.md"
    },
    {
      "id": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8",
      "doc_id": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8",
      "title": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8",
      "updated": 1689564660000,
      "body_original": "\n在后端的开发领域，各类开发框架都已经很多，在开发项目时可以根据不同的需要和需求选择合适的开发框架。然而在需要开发一个完善的工程化项目时，仅仅一个后端开发框架是不够的，还面临着在对开发项目的快速迭代中进行测试，部署，监控等问题。为了解决这些问题，DevOps的开发模式应运而生。\n\n\n基于个人对DevOps的理解，搭建了一个基于Gin的开源后端项目来实践下DevOps的各个概念：[https://github.com/wanghaoxi3000/advproject](https://github.com/wanghaoxi3000/advproject)。\n\n\nDevOps是一个宽泛的概念，这个项目也只是抛砖引玉，在测试环境下串联起各个DevOps的基础工具，存在的不足欢迎指出，一起学习和交流。\n\n\n## 如何构建DevOps模式的项目\n\n\n什么是DevOps呢，对DevOps比较官方的定义如下：\n\n\n> DevOps 集文化理念、实践和工具于一身，可以提高组织高速交付应用程序和服务的能力，与使用传统软件开发和基础设施管理流程相比，能够帮助组织更快地发展和改进产品。这种速度使组织能够更好地服务其客户，并在市场上更高效地参与竞争。\n\n\n可以说DevOps是一组过程、方法与系统的统称，涉及到开发中的组织架构，开发工具，基础架构等等方面。但它的一个核心便是强调通过各类自动化的工具来自动执行软件交付和基础架构更改流程，从而快速、频繁且更可靠地构建、测试和发布软件。这里也将主要围绕这个思想来构建DevOps的项目。\n\n\n在这个基础项目中，将主要围绕如下部分的Devops实践进行构建：\n\n- 持续集成：一种软件开发实践经验，开发人员会定期将他们的代码变更合并到一个中央存储库中，之后系统会自动运行构建和测试操作。\n- 持续交付：自动构建和测试代码更改，并为将其发布到生产环境做好准备，实现对持续集成的扩展。\n- 基础设施即代码：使用基于代码的工具来连接基础设施，并且能够以处理应用程序代码的方式来处理基础设施。基础设施和服务器由代码进行定义。\n- 监控和日志记录：组织对各项指标和日志进行监控，以了解应用程序和基础设施性能如何影响其产品的最终用户体验。\n\n整个项目的开发流程如下：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201162949.jpg)\n\n\n## 开发工具及环境\n\n\n要完成从开发到部署的一系列的流程，当然也少不了各种自动化工具及环境的支持，本项目所使用的环境如下：\n\n1. 代码开发环境Go 1.13\n2. Github账户\n3. 容器仓库，本项目使用腾讯云容器服务\n4. Jenkins 2.190\n5. Kubernetes 本项目使用基于k8s v1.16.1的三节点集群\n\n## DevOps项目开发流程\n\n\n通过[advproject](https://github.com/wanghaoxi3000/advproject)这个基于Gin的后端项目的代码更新、提交、完成对项目的自动化测试、打包、部署的流程。\n\n\n### 后端项目\n\n\n[advproject](https://github.com/wanghaoxi3000/advproject)项目主要包含了如下部分：\n\n- 接口文档 [swag](https://github.com/swaggo/swag)\n- 日志 [zap](https://github.com/uber-go/zap)\n- 配置 [godotenv](https://github.com/joho/godotenv)\n- docker容器化文件 [Dockerfile](https://github.com/wanghaoxi3000/advproject/blob/master/Dockerfile)\n- Jenkinsflie [Jenkinsfile](https://github.com/wanghaoxi3000/advproject/blob/master/Jenkinsfile)\n- Kubernetes部署文件 [deployment-template.yaml](https://github.com/wanghaoxi3000/advproject/blob/master/deployment-template.yaml)\n\n整个代码的结构如下\n\n\n```text\n.\n├── Dockerfile                  // Docker镜像打包文件\n├── Jenkinsfile                 // Jenkins CI 定义\n├── README.md\n├── api\n│   └── status.go               // 运行状态接口\n├── config\n│   ├── base.go                 // 基础配置\n│   └── init.go                 // 配置模块初始化\n├── deployment-template.yaml    // Kubernetes部署模板文件\n├── docs                        // swag 接口文档\n│   ├── docs.go\n│   ├── swagger.json\n│   └── swagger.yaml\n├── go.mod\n├── go.sum\n├── main.go\n├── serializer\n│   └── common.go               // 接口格式定义\n├── server\n│   └── router.go               // 路由\n├── test\n│   └── status_test.go          // 测试代码\n└── util\n    └── logger.go               // 日志模块\n\n```\n\n\n### Jenkins CI配置\n\n\n在代码有更新时，提交代码到Github后，Jenkins会收到代码Github推送通知，拉取代码并读取代码中的Jenkinsfile文件来运行指定的流程。\n\n\n可通过如下命令docker来快速运行一个Jenkins。为了在Jenkins容器中使用`docker`命令，将docker命令映射到了容器中，同时指定以root身份来运行容器。\n\n\n```text\ndocker run --name=jenkins_lts -d -u root -v jenkins_home:/var/jenkins_home -v /var/run/docker.sock:/var/run/docker.sock -v $(which docker):/bin/docker -p 8080:8080 -p 50000:50000 -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai jenkins/jenkins:lts\n\n```\n\n\n在Jenksin容器启动完成并成功登陆后，可以点击主界面右下角的`Jenkins 中文社区`链接，然后更新中心镜像设置为国内源，加快插件的下载速度。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201164726.png)\n\n\n### 环境配置\n\n\n本项目中主要使用到这些Jenkins插件，可以在插件管理页面中搜索安装：\n\n- Blue Ocean 方便和Pipeline搭配使用\n- Kubernetes Cli Plugin 通过kubectl操控k8s集群\n\n在执行部署的推送镜像、通知等过程中，需要使用到不方便暴露在代码中的密钥，如何在Jenkinsfile中使用这些密钥呢？可以提前在Jenkins的凭据管理中录入这些密钥，Jenkinsfile中以变量的方式进行调用。这里配置了如下的凭证：\n\n- tcloud-docker-reg 镜像仓库登录密钥\n- kubctl-config kubectl密钥\n- PUSH_KEY 基于Server酱通知推送的密钥\n\n### 建立项目\n\n\n通过Jenkinsfile文件以代码声明的方式来定义持续集成的流程，需要在Jenkins中建立一个 Pipeline流水线项目。\n\n\n选择新建任务，输入任务名建立一个流水线项目：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201164905.png)\n\n\nGeneral选项卡中勾选GitHub项目，并填入项目地址：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201164954.png)\n\n\n在代码推送后，使用GitHub的webhook功能推送代码更新消息，需要在构建触发器中勾选`GitHub hook trigger for GITScm polling`：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201165029.png)\n\n\n此后还需要在GitHub的代码项目中配置webhook推送更新的地址，相关文章已有很多，这里就不再累述了。\n\n\n最后，在流水线配置中填入代码地址：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201165130.png)\n\n\n指定分支中默认为`*/master`，表示拉取master分支的更新，如果想要拉取指定tag的代码。可以按这样的格式来配置：`+refs/tags/*:refs/remotes/origin/tags/*`。\n\n\n运行一下，可以看见Jenkins开始启动并运行了。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201165502.png)\n\n\n通过Blue Ocean，可以看见更详细的运行图。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200201165535.png)\n\n\n### 推送结果\n\n\n推送的结果将通过[Server酱](http://sc.ftqq.com/3.version)推送到绑定的微信中。Server酱是一个很方便的微信推送服务，只需要绑定下GitHub账户，之后请求对应地址即可向微信推送消息。推送的信息包含本次集成的结果和代码更新的记录，集成结果在Jenkinsfile中可以通过`${currentBuild.result}`来获取。代码更新记录Jenkins没有对应的变量，可以通过运行`git log --pretty=format:\\'%h - %an,%ar : %s\\' --since=\\'1 hours\\' | head -n 1`来获取代码最近一次的变更记录。\n\n\n### 部署到Kubernetes\n\n\n项目每次更新完成，同通过Jenkins拉取代码测试无误后，将会把项目打包成镜像并以`build-${BUILD_NUMBER}`作为tag，并推送到腾讯云的私有镜像仓库中，`${BUILD_NUMBER}`是Jenkins运行任务时的环境变量，表示运行本次集成任务的序号。之后以项目中`deployment-template.yaml`为模板，替换对应变量后部署到k8s集群上。\n\n\nJenkins pipeline 执行完成后登录集群节点，运行`kubectl get pods`，可以看到刚刚部署上的项目，已全处于了Running状态了。\n\n\n```text\nNAME                          READY   STATUS    RESTARTS   AGE\nadvproject-6f5d4d7d5d-pwmrp   1/1     Running   0          33s\nadvproject-6f5d4d7d5d-zscz2   1/1     Running   0          19s\n\n```\n\n\n为了便于测试，快速访问集群中的服务，可以按如下配置启动一个`NodePort`的Service，将Pod的端口暴露出来。\n\n\n```text\napiVersion: v1\nkind: Service\nmetadata:\n  name: advproject-svc\nspec:\n  type: NodePort\n  ports:\n  - port: 3000\n    targetPort: 3000\n    protocol: TCP\n  selector:\n    app: advproject\n\n```\n\n\n通过`kubectl get service`可以看到NodePode分配的端口号为30942：\n\n\n```text\nNAME             TYPE        CLUSTER-IP       EXTERNAL-IP   PORT(S)          AGE\nadvproject-svc   NodePort    10.110.152.165   <none>        3000:30942/TCP   25d\n\n```\n\n\n在节点上运行`curl localhost:30942/api/v1/hostname`，可以查看到项目对应的hostname，由于部署的Deployment文件中设置的`replicas: 2`，项目部署的节点数为2，请求的hostname也会随机出现两种。\n\n\n### 日志监控\n\n\n进入k8s的dashboard，在侧边栏选择容器组，可以看见运行项目的两个容器的，点击日志可以在网页中分别查看每个容器的控制台日志。这里可以看到刚刚请求hostname接口的日志，以及k8s在定时请求status接口进行健康检查。\n\n\n![容器日志](https://static-1256611153.file.myqcloud.com/img/picgo/20200201172141.png)\n\n\n为了更好的收集和分析日志，这里将通过k8s的ELK插件，来统一收集日志。克隆k8s对应版本的代码，使用k8s项目`/cluster/addons/fluentd-elasticsearch`目录下的示例代码，使用`kubectl apply -f .`命令可以快速部署一个ELk插件。\n\n\n部署完成后，登录kibana，创建一个默认的 logstash-* pattern。\n\n\n![index](https://static-1256611153.file.myqcloud.com/img/picgo/20200201172640.png)\n\n\n稍等一会，就可以`Discover`菜单下看到ElasticSearch logging中汇聚的日志，在Filters中搜索Gin，可以看到本项目的日志了。\n\n\n![日志](https://static-1256611153.file.myqcloud.com/img/picgo/20200201172734.png)\n\n\n## 总结\n\n\n至此，一个以DevOps模式的项目开发流程便大致完成了。当然这个过程也还有很多可以继续完善的地方，比如生成更详细的代码测试报表、使用kibana生成日志报表、监测代码中的错误日志并报警等等。通过DevOps，将开发、测试、运维这些步骤紧密联系了起来，使得构建、测试、发布软件能够更加地快捷、频繁和可靠。除了这些技术和工具，DevOps也更需要组织中各个部门之间的进行良好的沟通、协作与整合。在实际开发中，需要通过各个部门的分工合作，开发人员编写业务和单元测试代码；测试人员设计测试用例，关注代码测试报告；运维人员设计Kubernetes部署模板，监控系统及日志数据，这样才能发挥DevOps的最大效力，更好地为客户服务并在市场中更有竞争力。\n\n",
      "properties": {
        "date": "2020-02-10",
        "type": "Post",
        "category": "项目架构",
        "slug": "build-devops-project",
        "tags": [
          "devOps",
          "Jenkins",
          "kubernetes",
          "Gin"
        ],
        "summary": "在后端的开发领域，各类开发框架都已经很多，在开发项目时可以根据不同的需要和需求选择合适的开发框架。然而在需要开发一个完善的工程化项目时，仅仅一个后端开发框架是不够的，还面临着在对开发项目的快速迭代中进行测试，部署，监控等问题。为了解决这些问题，DevOps的开发模式应运而生。\n\n基于个人对DevOps的理解，搭建了一个基于Gin的开源后端项目来实践下DevOps的各个概念：https://github.com/wanghaoxi3000/advproject。\n\nDevOps是一个宽泛的概念，这个项目也只是抛砖引玉，在测试环境下串联起各个DevOps的基础工具，存在的不足欢迎指出，一起学习和交流。",
        "title": "搭建DevOps模式的项目",
        "status": "Published",
        "urlname": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8",
        "updated": "2023-07-17 11:31:00"
      },
      "catalog": [
        {
          "title": "2020-02-10",
          "doc_id": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8"
        }
      ],
      "body": "",
      "realName": "搭建DevOps模式的项目",
      "relativePath": "/2020-02-10/搭建DevOps模式的项目.md"
    },
    {
      "id": "dbd2a274-4236-478d-9324-880043009ccd",
      "doc_id": "dbd2a274-4236-478d-9324-880043009ccd",
      "title": "dbd2a274-4236-478d-9324-880043009ccd",
      "updated": 1689564600000,
      "body_original": "\n国内的网络问题，经常需要替换软件本身的更新源，加快软件的下载速度。这里记录下常用国内镜像源。\n\n\n主要使用阿里云镜像源服务：[https://developer.aliyun.com/mirror/](https://developer.aliyun.com/mirror/)\n\n\n## Linux 系统\n\n\n### Ubuntu\n\n\n```text\nsed -i s/archive.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list\nsed -i s/security.ubuntu.com/mirrors.aliyun.com/g /etc/apt/sources.list\n\n```\n\n\n### Fedora\n\n\n```text\nsu\ncd /etc/yum.repos.d/\nmv fedora.repo fedora.repo.backup\nmv fedora-updates.repo fedora-updates.repo.backup\nwget -O /etc/yum.repos.d/fedora.repo http://mirrors.aliyun.com/repo/fedora.repo\nwget -O /etc/yum.repos.d/fedora-updates.repo http://mirrors.aliyun.com/repo/fedora-updates.repo\ndnf clean all\ndnf makecache\n```\n\n",
      "properties": {
        "date": "2020-06-16",
        "type": "Post",
        "category": "Linux管理",
        "slug": "source-mirrors-change",
        "tags": [
          "mirror",
          "镜像源"
        ],
        "summary": "国内的网络问题，经常需要替换软件本身的更新源，加快软件的下载速度。这里记录下常用国内镜像源。",
        "title": "国内镜像源",
        "status": "Published",
        "urlname": "dbd2a274-4236-478d-9324-880043009ccd",
        "updated": "2023-07-17 11:30:00"
      },
      "catalog": [
        {
          "title": "2020-06-16",
          "doc_id": "dbd2a274-4236-478d-9324-880043009ccd"
        }
      ],
      "body": "",
      "realName": "国内镜像源",
      "relativePath": "/2020-06-16/国内镜像源.md"
    },
    {
      "id": "de496bfb-9b9d-4b57-8faa-d40e479c7d41",
      "doc_id": "de496bfb-9b9d-4b57-8faa-d40e479c7d41",
      "title": "de496bfb-9b9d-4b57-8faa-d40e479c7d41",
      "updated": 1689564540000,
      "body_original": "\n在Golang中，当一个map的value为一个值类型的结构体时，是不能对其赋值的，修改结构体的数值的。\n\n\n### 示例代码\n\n\n```javascript\npackage main\n\nimport \"fmt\"\n\ntype person struct {\n\tname string\n\tage  int\n\tsex  string\n}\n\nfunc main() {\n\t//建立结构体map\n\ts := make(map[int]person)\n\n\t//给map赋值\n\ts[1] = person{\"tony\", 20, \"man\"}\n\tfmt.Println(s[1])\n\n\t//修改map里结构体的成员属性的值\n\ts[1].name = \"tom\" // cannot assign to struct field s[1].name in map\n\tfmt.Println(s[1].name)\n}\n\n```\n\n\n以上代码在对`s[1]`的结构体执行赋值操作`s[1].name = \"tom\"`时，便会产生`cannot assign to struct field s[1].name in map`的错误。\n\n\n### 错误原因\n\n- `x = y` 这种赋值的方式，你必须知道 `x`的地址，然后才能把值 `y` 赋给 `x`。\n- 但 `go` 中的 `map` 的 `value` 本身是不可寻址的，因为 `map` 的扩容的时候，可能要做 `key/val pair`迁移，`value` 本身地址是会改变的\n- `value`不支持寻址，因而无法赋值\n\n### 解决方法\n\n\n在需要对map中结构体进行赋值修改的操作时，需要在map中保存结构体的地址，这时便可以赋值了。\n\n\n```text\npackage main\n\nimport \"fmt\"\n\ntype person struct {\n\tname string\n\tage  int\n\tsex  string\n}\n\nfunc main() {\n\t//建立结构体map，声明为结构体地址\n\ts := make(map[int]*person)\n\n\t//给map赋值\n\ts[1] = &person{\"tony\", 20, \"man\"}\n\tfmt.Println(s[1])\n\n\t//修改map里结构体的成员属性的值\n\ts[1].name = \"tom\"\n\tfmt.Println(s[1].name)\n}\n\n\n```\n\n",
      "properties": {
        "date": "2020-06-23",
        "type": "Post",
        "category": "Golang",
        "slug": "the-value-type-struct-of-map-cannot-assign",
        "tags": [
          "Golang 基础"
        ],
        "summary": "在Golang中，当一个map的value为一个值类型的结构体时，是不能对其赋值的，修改结构体的数值的。",
        "title": "map中值类型结构体无法赋值",
        "status": "Published",
        "urlname": "de496bfb-9b9d-4b57-8faa-d40e479c7d41",
        "updated": "2023-07-17 11:29:00"
      },
      "catalog": [
        {
          "title": "2020-06-23",
          "doc_id": "de496bfb-9b9d-4b57-8faa-d40e479c7d41"
        }
      ],
      "body": "",
      "realName": "map中值类型结构体无法赋值",
      "relativePath": "/2020-06-23/map中值类型结构体无法赋值.md"
    },
    {
      "id": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39",
      "doc_id": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39",
      "title": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39",
      "updated": 1689564480000,
      "body_original": "\nGolang 语言中，我们可以用关键字`type`声明自定义的各种类型。在使用`type`时，声明的自定义类型有不同的区别。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20200916203327.png)\n\n\n### 别名类型\n\n\n```go\ntype MyString = string\n\n```\n\n\n这条语句表示，MyString是string类型的别名类型。别名类型与其源类型的区别只是在名称上，它们是完全相同的。源类型与别名类型是一对概念，是两个对立的称呼。别名类型主要是为了代码重构而存在的。详细的信息可参见 Go 语言官方的文档[Proposal: Type Aliases](https://golang.org/design/18130-type-alias)。\n\n\nGo 语言内建的基本类型中就存在两个别名类型。`byte`是`uint8`的别名类型，而`rune`是`int32`的别名类型。\n\n\n### 类型再定义\n\n\n```go\ntype MyString2 string // 没有等号\n\n```\n\n\n这条语句表示，string类型再定义成了另外一个类型MyString2。这种方式也可以被叫做对类型的再定义。 **string可以被称为MyString2的潜在类型**。潜在类型的含义是，某个类型在本质上是哪个类型。\n\n\n潜在类型相同的不同类型的值之间是可以进行类型转换的。因此，MyString2类型的值与string类型的值可以使用类型转换表达式进行互转。\n\n\n但对于集合类的类型[]MyString2与[]string来说这样做却是不合法的，因为[]MyString2与[]string的潜在类型不同，分别是[]MyString2和[]string。另外，即使两个不同类型的潜在类型相同，它们的值之间也不能进行判等或比较，它们的变量之间也不能赋值。\n\n",
      "properties": {
        "date": "2020-09-16",
        "type": "Post",
        "category": "Golang",
        "slug": "type-declarations-and-type-aliases",
        "tags": [
          "Golang 基础"
        ],
        "summary": "Golang 语言中，我们可以用关键字type声明自定义的各种类型。在使用type时，声明的自定义类型有不同的区别。",
        "title": "别名和类型再定义",
        "status": "Published",
        "urlname": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39",
        "updated": "2023-07-17 11:28:00"
      },
      "catalog": [
        {
          "title": "2020-09-16",
          "doc_id": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39"
        }
      ],
      "body": "",
      "realName": "别名和类型再定义",
      "relativePath": "/2020-09-16/别名和类型再定义.md"
    },
    {
      "id": "5254d509-659c-488c-9fc6-28b07901dd5d",
      "doc_id": "5254d509-659c-488c-9fc6-28b07901dd5d",
      "title": "5254d509-659c-488c-9fc6-28b07901dd5d",
      "updated": 1689564240000,
      "body_original": "\nGolang 中 goroutine 中的运行是无序的，如果要让多个 goroutine 顺序执行，例如每个 goroutine 在并行执行时顺序打印 0-9，这里记录一种通过 `atomic` 包的原子操作来实现的方法。\n\n\n```go\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sync/atomic\"\n\t\"time\"\n)\n\nfunc ParallelPrintOrderdNum() {\n\tvar count uint32\n\n\ttrigger := func(i uint32, fn func()) {\n\t\tfor {\n\t\t\tif n := atomic.LoadUint32(&count); n == i {\n\t\t\t\tfn()\n\t\t\t\tatomic.AddUint32(&count, 1)\n\t\t\t\tbreak\n\t\t\t}\n\t\t\t// sleep 等代，让此 goroutine 有被调度的机会\n\t\t\ttime.Sleep(time.Nanosecond)\n\t\t}\n\t}\n\n\tfor i := uint32(0); i < 10; i++ {\n\t\tgo func(i uint32) {\n\t\t\tfn := func() {\n\t\t\t\tfmt.Println(i)\n\t\t\t}\n\t\t\ttrigger(i, fn)\n\t\t}(i)\n\t}\n\n    // 主 goroutine 也需要等待\n\ttrigger(10, func() {})\n}\n\nfunc main() {\n\tParallelPrintOrderdNum()\n}\n\n```\n\n",
      "properties": {
        "date": "2020-10-01",
        "type": "Post",
        "category": "Golang",
        "slug": "run-goroutine-by-ordered",
        "tags": [
          "Golang 基础"
        ],
        "summary": "Golang 中 goroutine 中的运行是无序的，如果要让多个 goroutine 顺序执行，例如每个 goroutine 在并行执行时顺序打印 0-9，这里记录一种通过 atomic 包的原子操作来实现的方法。",
        "title": "多个goroutine按既定顺序运行",
        "status": "Published",
        "urlname": "5254d509-659c-488c-9fc6-28b07901dd5d",
        "updated": "2023-07-17 11:24:00"
      },
      "catalog": [
        {
          "title": "2020-10-01",
          "doc_id": "5254d509-659c-488c-9fc6-28b07901dd5d"
        }
      ],
      "body": "",
      "realName": "多个goroutine按既定顺序运行",
      "relativePath": "/2020-10-01/多个goroutine按既定顺序运行.md"
    },
    {
      "id": "ba9c45bd-1568-4097-a5b4-e64168d3755d",
      "doc_id": "ba9c45bd-1568-4097-a5b4-e64168d3755d",
      "title": "ba9c45bd-1568-4097-a5b4-e64168d3755d",
      "updated": 1689564180000,
      "body_original": "\nGo 语言的 range 表达式遵循如下两个规则：\n\n1. range表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代\n2. range表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值\n\n在使用 range 遍历数组和切片遇到需要修改遍历对象本身的情况时，便会出现差异。\n\n\n### 遍历数组\n\n\n```go\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers2 := [...]int{1, 2, 3, 4, 5, 6}\n\tmaxIndex2 := len(numbers2) - 1\n\tfor i, e := range numbers2 {\n\t\tif i == maxIndex2 {\n\t\t\tnumbers2[0] += e\n\t\t} else {\n\t\t\tnumbers2[i+1] += e\n\t\t}\n\t}\n\tfmt.Println(numbers2)\n}\n```\n\n\n打印结果为：`[7 3 5 7 9 11]`。\n\n\nrange 循环中 e 并未随着数组改变，因为数组是值类型的。\n\n\n### 遍历切片\n\n\n```text\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tnumbers2 := []int{1, 2, 3, 4, 5, 6}\n\tmaxIndex2 := len(numbers2) - 1\n\tfor i, e := range numbers2 {\n\t\tif i == maxIndex2 {\n\t\t\tnumbers2[0] += e\n\t\t} else {\n\t\t\tnumbers2[i+1] += e\n\t\t}\n\t}\n\tfmt.Println(numbers2)\n}\n```\n\n\n打印结果为：`[22 3 6 10 15 21]`。\n\n\nrange 循环中 e 并会随着数组改变而改变，因为切片是引用类型的。\n\n",
      "properties": {
        "date": "2020-10-13",
        "type": "Post",
        "category": "Golang",
        "slug": "the-difference-of-range-array-and-slice",
        "tags": [
          "Golang 基础"
        ],
        "summary": "Go 语言的 range 表达式遵循如下两个规则：\nrange表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代\nrange表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值",
        "title": "range 数组和切片的差异",
        "status": "Published",
        "urlname": "ba9c45bd-1568-4097-a5b4-e64168d3755d",
        "updated": "2023-07-17 11:23:00"
      },
      "catalog": [
        {
          "title": "2020-10-13",
          "doc_id": "ba9c45bd-1568-4097-a5b4-e64168d3755d"
        }
      ],
      "body": "",
      "realName": "range 数组和切片的差异",
      "relativePath": "/2020-10-13/range 数组和切片的差异.md"
    },
    {
      "id": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a",
      "doc_id": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a",
      "title": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a",
      "updated": 1689564000000,
      "body_original": "\n看完了 [go-advice](https://github.com/cristaloleg/go-advice), 记录下一些要点和自己值得注意的地方。\n\n\n## Go 箴言\n\n- 不要通过共享内存进行通信，通过通信共享内存\n- 并发不是并行\n- 通道编排；互斥体序列化\n- 接口越大，抽象就越弱\n- 使零值有用\n- `interface{}` 什么也没说\n- Gofmt 的风格不是人们最喜欢的，但 gofmt 是每个人的最爱\n- 一点点复制比一点点依赖更好\n- 系统调用必须始终使用构建标记进行保护\n- 必须始终使用构建标记保护 Cgo\n- Cgo 不是 Go\n- 对于不安全的 package，没有任何保证\n- 清楚比聪明更好\n- 反射永远不清晰\n- 错误就是价值观\n- 不要只检查错误，还要优雅地处理它们\n- 设计架构，命名组件，记录细节\n- 文档是供用户使用的\n- 不要恐慌\n\nAuthor: Rob Pike See more: [https://go\\-proverbs.github.io/](https://go-proverbs.github.io/)\n\n\n## Go 之禅\n\n- 每个 package 实现单一的目的\n- 显式处理错误\n- 尽早返回，而不是使用深嵌套\n- 让调用者选择并发\n- 在启动一个 goroutine 时，需要知道何时它会停止\n- 避免 package 级别的状态\n- 简单很重要\n- 编写测试以锁定 package API 的行为\n- 如果你觉得慢，先编写 benchmark 来证明\n- 节制是一种美德\n- 可维护性\n\nAuthor: Dave Cheney See more: [https://the\\-zen\\-of\\-go.netlify.com/](https://the-zen-of-go.netlify.com/)\n\n\n## 代码\n\n\n### 用 `chan struct{}` 来传递信号, `chan bool` 表达的不够清楚\n\n\n刚开始使用Go时，需要使用chan来传递一个信号时，并没有一个明确的约束，`chan int`，`chan bool`等，都在使用。\n\n\n但使用`struct{}`时是最推荐的，字面量struct{}代表了空的结构体类型，空结构体类型变量不占内存空间，内存地址相同，既不包含任何字段也没有任何方法。该类型的值所需的存储空间几乎可以忽略不计。相比其他类型，也可以一目了然是用来传递信号的。\n\n\n### 30 * time.Second 比 time.Duration(30) * time.Second 更好\n\n\n需要将无类型的 const 包装在类型中，编译器会找出来。最好将 const 移到第一位：\n\n\n```go\n// BAD\ndelay := time.Second * 60 * 24 * 60\n\n// VERY BAD\ndelay := 60 * time.Second * 60 * 24\n\n// GOOD\ndelay := 24 * 60 * 60 * time.Second\n```\n\n\n### 用 a := []T{} 来简单初始化 slice\n\n\n相比 `make` 这样的写法更快捷，可以借鉴。\n\n\n### 从一个 slice 生成简单的随机元素\n\n\n```go\n[]string{\"one\", \"two\", \"three\"}[rand.Intn(3)]\n```\n\n",
      "properties": {
        "date": "2020-11-25",
        "type": "Post",
        "category": "Golang",
        "slug": "go-advance-summary",
        "tags": [
          "Golang 基础"
        ],
        "summary": "看完了 go-advice, 记录下一些要点和自己值得注意的地方。",
        "title": "Go-Advance 总结",
        "status": "Published",
        "urlname": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a",
        "updated": "2023-07-17 11:20:00"
      },
      "catalog": [
        {
          "title": "2020-11-25",
          "doc_id": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a"
        }
      ],
      "body": "",
      "realName": "Go-Advance 总结",
      "relativePath": "/2020-11-25/Go-Advance 总结.md"
    },
    {
      "id": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc",
      "doc_id": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc",
      "title": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc",
      "updated": 1689303840000,
      "body_original": "\n准备深入的学习下kafka，先从搭建一个开发环境，编写一个简单的测试程序开始吧。\n\n\n## 搭建Kafka开发环境\n\n\n使用如下的 Yaml 文件在K8S中搭建一个测试可用的 Kafka 实例。\n\n\n**deployment.yaml**\n\n\n```yaml\nkind: Deployment\napiVersion: apps/v1\nmetadata:\n  name: kafka-dev\n  namespace: dev\n  labels:\n    app: kafka-dev\nspec:\n  replicas: 1\n  selector:\n    matchLabels:\n      app: kafka-dev\n  template:\n    metadata:\n      labels:\n        app: kafka-dev\n      containers:\n        - name: zookeeper\n          image: 'docker.io/bitnami/zookeeper:3-debian-10'\n          ports:\n            - name: tcp-zookeeper\n              containerPort: 2181\n              protocol: TCP\n          env:\n            - name: ALLOW_ANONYMOUS_LOGIN\n              value: 'yes'\n          resources:\n            limits:\n              memory: 512Mi\n          volumeMounts:\n            - name: host-time\n              readOnly: true\n              mountPath: /etc/localtime\n            - name: zookeeper-data\n              mountPath: /bitnami\n          imagePullPolicy: IfNotPresent\n        - name: kafka\n          image: 'docker.io/bitnami/kafka:2-debian-10'\n          ports:\n            - name: tcp-kafka\n              containerPort: 9092\n              protocol: TCP\n          env:\n            - name: KAFKA_CFG_ZOOKEEPER_CONNECT\n              value: 'localhost:2181'\n            - name: ALLOW_PLAINTEXT_LISTENER\n              value: 'yes'\n            - name: KAFKA_LISTENERS\n              value: 'PLAINTEXT://:9092'\n            - name: KAFKA_ADVERTISED_LISTENERS\n              value: 'PLAINTEXT://192.168.50.35:9092'\n          resources:\n            limits:\n              memory: 1Gi\n          volumeMounts:\n            - name: host-time\n              readOnly: true\n              mountPath: /etc/localtime\n            - name: kafka-data\n              mountPath: /bitnami\n          imagePullPolicy: IfNotPresent\n    spec:\n      volumes:\n        - name: host-time\n          hostPath:\n            path: /etc/localtime\n            type: ''\n        - name: zookeeper-data\n          emptyDir: {}\n        - name: kafka-data\n          emptyDir: {}\n\n```\n\n\n**service.yaml**\n\n\n```yaml\nkind: Service\napiVersion: v1\nmetadata:\n  name: kafka\n  namespace: dev\n  labels:\n    app: kafka\n  annotations:\n    kubesphere.io/creator: admin\nspec:\n  ports:\n    - name: tcp-kafka\n      protocol: TCP\n      port: 9092\n      targetPort: 9092\n      nodePort: 30667\n  selector:\n    app: kafka-dev\n  clusterIP: 10.233.10.125\n  type: NodePort\n  externalIPs:\n    - 192.168.50.35\n  sessionAffinity: None\n  externalTrafficPolicy: Cluster\n\n```\n\n\n为了方便部署，kafka和zookeeper部署到了同一个pod中，可以直接通过localhost来直接访问。另外需要注意的是 `KAFKA_ADVERTISED_LISTENERS` 要配置为一个外部可访问的地址，才能在集群外进行访问。这里使用我的机器地址`192.168.50.35`，在service.yaml中，同样需要配置上`externalIPs:[192.168.50.35]`，这样可以直接使用`192.168.50.35:9092`来访问kafka，而无需使用分配的nodePort端口号。\n\n\n## 代码测试\n\n\n通过编写一个生产者和消费者，来测试搭建的kafka测试环境是否可用。\n\n\n### 编写 Kafka 生产者\n\n\n使用 `gopkg.in/Shopify/sarama.v1` 库编写一个Golang版本的消息生产者，用同步模式向`web_log` Topic中发送一条`this is a test log`的消息。\n\n\n**producer.go**\n\n\n```javascript\npackage main\n\nimport (\n\t\"log\"\n\n\tsarama \"gopkg.in/Shopify/sarama.v1\"\n)\n\nfunc main() {\n\t// 设置消费者相关配置\n\tconfig := sarama.NewConfig()\n\n\tconfig.Producer.RequiredAcks = sarama.WaitForAll          // 发送完数据需要leader和follow都确认\n\tconfig.Producer.Partitioner = sarama.NewRandomPartitioner // 选择分区（此处随机设置一个分区）\n\tconfig.Producer.Return.Successes = true                   // 成功交付的消息将在success channel返回\n\tconfig.Producer.Return.Errors = true\n\n\t// 构造⼀个消息\n\tmsg := &sarama.ProducerMessage{}\n\tmsg.Topic = \"web_log\"\n\tmsg.Value = sarama.StringEncoder(\"this is a test log\")\n\n\t// 连接kafka\n\tclient, err := sarama.NewSyncProducer([]string{\"192.168.50.35:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\t// 发送消息\n\tpid, offset, err := client.SendMessage(msg)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tlog.Printf(\"pid:%v offset:%v\\n\", pid, offset)\n}\n\n```\n\n\n代码执行结果:\n\n\n```bash\n2021/04/12 20:25:02 pid:0 offset:3\n```\n\n\n### 编写 Kafka 消费者\n\n\n再基于 `gopkg.in/Shopify/sarama.v1` 编写一个Golang的同步消费者客户端，客户端中创建了`c1`和`c2`两个客户端\n\n\n**consumer.go**\n\n\n```go\npackage main\n\nimport (\n\t\"context\"\n\t\"fmt\"\n\t\"os\"\n\t\"os/signal\"\n\t\"sync\"\n\n\t\"gopkg.in/Shopify/sarama.v1\"\n)\n\ntype consumerGroupHandler struct {\n\tname string\n}\n\nfunc (consumerGroupHandler) Setup(_ sarama.ConsumerGroupSession) error   { return nil }\nfunc (consumerGroupHandler) Cleanup(_ sarama.ConsumerGroupSession) error { return nil }\nfunc (h consumerGroupHandler) ConsumeClaim(sess sarama.ConsumerGroupSession, claim sarama.ConsumerGroupClaim) error {\n\tfor msg := range claim.Messages() {\n\t\tfmt.Printf(\"%s Message topic:%q partition:%d offset:%d  value:%s\\n\", h.name, msg.Topic, msg.Partition, msg.Offset, string(msg.Value))\n\t\t// 手动确认消息\n\t\tsess.MarkMessage(msg, \"\")\n\t}\n\treturn nil\n}\n\nfunc consume(group *sarama.ConsumerGroup, wg *sync.WaitGroup, name string) {\n\tfmt.Println(name + \"start\")\n\twg.Done()\n\tctx := context.Background()\n\tfor {\n\t\ttopics := []string{\"web_log\"}\n\t\thandler := consumerGroupHandler{name: name}\n\t\terr := (*group).Consume(ctx, topics, handler)\n\t\tif err != nil {\n\t\t\tpanic(err)\n\t\t}\n\t}\n}\n\nfunc main() {\n\tconfig := sarama.NewConfig()\n\tconfig.Version = sarama.V0_10_2_0\n\tconfig.Consumer.Return.Errors = false\n\tconfig.Consumer.Offsets.Initial = sarama.OffsetOldest\n\n\tclient, err := sarama.NewClient([]string{\"192.168.50.35:9092\"}, config)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer client.Close()\n\n\tgroup1, err := sarama.NewConsumerGroupFromClient(\"c1\", client)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer group1.Close()\n\n\tgroup2, err := sarama.NewConsumerGroupFromClient(\"c2\", client)\n\tif err != nil {\n\t\tpanic(err)\n\t}\n\tdefer group2.Close()\n\n\tvar wg sync.WaitGroup\n\n\twg.Add(2)\n\tgo consume(&group1, &wg, \"c1\")\n\tgo consume(&group2, &wg, \"c2\")\n\twg.Wait()\n\n\tsignals := make(chan os.Signal, 1)\n\tsignal.Notify(signals, os.Interrupt)\n\t<-signals\n}\n\n```\n\n\n代码执行结果:\n\n\n```bash\nc2 Message topic:\"web_log\" partition:0 offset:3  value:this is a test log\nc1 Message topic:\"web_log\" partition:0 offset:3  value:this is a test log\n```\n\n\nProducer 发送到 Kafka 中的消息已被 Consumer 成功接收到。\n\n\n## 总结\n\n\n这里在k8s搭建了一个测试可用的kafka环境，并通过简单的生产者和消费者程序进行了测试，方便之后可以更深入的学习kafka。\n\n",
      "properties": {
        "date": "2021-04-18",
        "type": "Post",
        "category": "kafka",
        "slug": "kafka-study-note--deploy-kafka-test-env-in-k8s",
        "tags": [
          "kafka",
          "k8s"
        ],
        "summary": "准备深入的学习下kafka，先从搭建一个开发环境，编写一个简单的测试程序开始吧。",
        "title": "kafka学习笔记-搭建基于k8s的kafka测试环境",
        "status": "Published",
        "urlname": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc",
        "updated": "2023-07-14 11:04:00"
      },
      "catalog": [
        {
          "title": "2021-04-18",
          "doc_id": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc"
        }
      ],
      "body": "",
      "realName": "kafka学习笔记-搭建基于k8s的kafka测试环境",
      "relativePath": "/2021-04-18/kafka学习笔记-搭建基于k8s的kafka测试环境.md"
    },
    {
      "id": "c2c92a3e-f090-44de-a28e-12cb3fff3c20",
      "doc_id": "c2c92a3e-f090-44de-a28e-12cb3fff3c20",
      "title": "c2c92a3e-f090-44de-a28e-12cb3fff3c20",
      "updated": 1689303780000,
      "body_original": "\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20210511151354.jpg)\n\n\n### kafka工作机制图示说明\n\n\nkafka 第一层是主题层，每个主题可以配置 M 个分区，而每个分区又可以配置 N 个副本。第二层是分区层，每个分区的 N 个副本中只能有一个充当领导者角色，对外提供服务；其他 N-1 个副本是追随者副本，只是提供数据冗余之用。第三层是消息层，分区中包含若干条消息，每条消息的位移从 0 开始，依次递增。最后，客户端程序只能与分区的领导者副本进行交互。\n\n\n### 术语解释\n\n- **Topic** 发布订阅的对象是主题，你可以为每个业务、每个应用甚至是每类数据都创建专属的主题\n- **Producer** 向主题发布消息的客户端应用程序称为Producer\n- **Consumer** 订阅这些主题消息的客户端应用程序就被称为Consumer。和生产者类似，消费者也能够同时订阅多个主题的消息\n- **Clients** 生产者和消费者统称为Clients\n- **Broker** Kafka 的服务器端由被称为 Broker 的服务进程构成，即一个 Kafka 集群由多个 Broker 组成，Broker 负责接收和处理客户端发送过来的请求，以及对消息进行持久化。虽然多个 Broker 进程能够运行在同一台机器上，但更常见的做法是将不同的 Broker 分散运行在不同的机器上，这样如果集群中某一台机器宕机，即使在它上面运行的所有 Broker 进程都挂掉了，其他机器上的 Broker 也依然能够对外提供服务。这其实就是 Kafka 提供高可用的手段之一。\n- **Replication 和 Replica** 实现高可用的另一个手段就是备份机制（Replication）。是把相同的数据拷贝到多台机器上，而这些相同的数据拷贝在 Kafka 中被称为副本（Replica）。\n- **Leader Replica 和 Follower Replica** 领导者副本和追随者副本。前者对外提供服务，这里的对外指的是与客户端程序进行交互；而后者只是被动地追随领导者副本而已，不能与外界进行交互。追随者副本只做一件事：向领导者副本发送请求，请求领导者把最新生产的消息发给它，这样它能保持与领导者的同步。\n- **Scalability** 伸缩性，分布式系统中非常重要且必须要谨慎对待的问题。什么是伸缩性呢？我们拿副本来说，虽然现在有了领导者副本和追随者副本，但倘若领导者副本积累了太多的数据以至于单台 Broker 机器都无法容纳了，Kafka可以把数据分割成多份保存在不同的 Broker 上。\n- **Partition** Kafka 中的分区机制指的是将每个主题划分成多个分区（Partition），每个分区是一组有序的消息日志。生产者生产的每条消息只会被发送到一个分区中，也就是说如果向一个双分区的主题发送一条消息，这条消息要么在分区 0 中，要么在分区 1 中。Kafka 的分区编号是从 0 开始的，如果 Topic 有 100 个分区，那么它们的分区号就是从 0 到 99。\n- **Offset** 每个分区下可以配置若干个副本，其中只能有 1 个领导者副本和 N-1 个追随者副本。生产者向分区写入消息，每条消息在分区中的位置信息由一个叫位移（Offset）的数据来表征。\n- **Log** Kafka 使用消息日志（Log）来保存数据，一个日志就是磁盘上一个只能追加写（Append-only）消息的物理文件。因此 Kafka 必然要定期地通过日志段（Log Segment）机制删除消息以回收磁盘。在 Kafka 底层，一个日志又进一步细分成多个日志段，消息被追加写到当前最新的日志段中，当写满了一个日志段后，Kafka 会自动切分出一个新的日志段，并将老的日志段封存起来。Kafka 在后台还有定时任务会定期地检查老的日志段是否能够被删除，从而实现回收磁盘空间的目的。\n- **Consumer Group** 消费者组指的是多个消费者实例共同组成一个组来消费一组主题。这组主题中的每个分区都只会被组内的一个消费者实例消费，其他消费者实例不能消费它。这主要是为了提升消费者端的吞吐量。多个消费者实例同时消费，加速整个消费端的吞吐量（TPS）。\n- **Rebalance** 消费者组里面的所有消费者实例不仅“瓜分”订阅主题的数据，而且它们还能彼此协助。假设组内某个实例挂掉了，Kafka 能够自动检测到，然后把这个 Failed 实例之前负责的分区转移给其他活着的消费者。这个过程就是 Kafka 中大名鼎鼎的“重平衡”（Rebalance）。\n- **Consumer Offset** 每个消费者在消费消息的过程中必然需要有个字段记录它当前消费到了分区的哪个位置上，这个字段就是消费者位移（Consumer Offset）。\n",
      "properties": {
        "date": "2021-05-11",
        "type": "Post",
        "category": "kafka",
        "slug": "kafka--kafka-study-note--kafka-term",
        "tags": [
          "kafka"
        ],
        "title": "kafka学习笔记-kafka术语介绍",
        "status": "Published",
        "urlname": "c2c92a3e-f090-44de-a28e-12cb3fff3c20",
        "updated": "2023-07-14 11:03:00"
      },
      "catalog": [
        {
          "title": "2021-05-11",
          "doc_id": "c2c92a3e-f090-44de-a28e-12cb3fff3c20"
        }
      ],
      "body": "",
      "realName": "kafka学习笔记-kafka术语介绍",
      "relativePath": "/2021-05-11/kafka学习笔记-kafka术语介绍.md"
    },
    {
      "id": "8fa8898a-3851-4346-8e67-8d17aa5430f5",
      "doc_id": "8fa8898a-3851-4346-8e67-8d17aa5430f5",
      "title": "8fa8898a-3851-4346-8e67-8d17aa5430f5",
      "updated": 1689303540000,
      "body_original": "\n> 原文链接 https://mp.weixin.qq.com/s/TO_lmlFbVDgFmns9s_mMzw\n\n\n程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域 — 栈区（Stack）和堆区（Heap）。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。\n\n\n不同的编程语言会选择不同的方式管理内存，本节会介绍 Go 语言内存分配器，详细分析内存分配的过程以及其背后的设计与实现原理。\n\n\n## 设计原理\n\n\n内存管理一般包含三个不同的组件，分别是用户程序（Mutator）、分配器（Allocator）和收集器（Collector）[1]，当用户程序申请内存时，它会通过内存分配器申请新的内存，而分配器会负责从堆中初始化相应的内存区域。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225103751.webp)\n\n\nmutator-allocator-collector\n\n\n**图 7-1 内存管理的组件**\n\n\nGo 语言的内存分配器实现非常复杂，在分析内存分配器的实现之前，我们需要了解内存分配的设计原理，帮助我们更快掌握内存的分配过程。这里将要详细介内存分配器的分配方法以及 Go 语言内存分配器的分级分配方法、虚拟内存布局和地址空间。\n\n\n### 分配方法\n\n\n编程语言的内存分配器一般包含两种分配方法，一种是线性分配器（Sequential Allocator，Bump Allocator），另一种是空闲链表分配器（Free\\-List Allocator），这两种分配方法有着不同的实现机制和特性，本节会依次介绍它们的分配过程。\n\n\n### 线性分配器\n\n\n线性分配（Bump Allocator）是一种高效的内存分配方法，但是有较大的局限性。当我们在编程语言中使用线性分配器，我们只需要在内存中维护一个指向内存特定位置的指针，当用户程序申请内存时，分配器只需要检查剩余的空闲内存、返回分配的内存区域并修改指针在内存中的位置，即移动下图中的指针：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104034.webp)\n\n\nbump-allocator\n\n\n**图 7-2 线性分配器**\n\n\n根据线性分配器的原理，我们可以推测它有较快的执行速度，以及较低的实现复杂度；但是线性分配器无法在内存被释放时重用内存。如下图所示，如果已经分配的内存被回收，线性分配器是无法重新利用红色的这部分内存的：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104127.webp)\n\n\nbump-allocator-reclaim-memory\n\n\n**图 7-3 线性分配器回收内存**\n\n\n正是因为线性分配器的这种特性，我们需要合适的垃圾回收算法配合使用。标记压缩（Mark-Compact）、复制回收（Copying GC）和分代回收（Generational GC）等算法可以通过拷贝的方式整理存活对象的碎片，将空闲内存定期合并，这样就能利用线性分配器的效率提升内存分配器的性能了。\n\n\n因为线性分配器的使用需要配合具有拷贝特性的垃圾回收算法，所以 C 和 C++ 等需要直接对外暴露指针的语言就无法使用该策略，我们会在下一节详细介绍常见垃圾回收算法的设计原理。\n\n\n### 空闲链表分配器\n\n\n空闲链表分配器（Free-List Allocator）可以重用已经被释放的内存，它在内部会维护一个类似链表的数据结构。当用户程序申请内存时，空闲链表分配器会依次遍历空闲的内存块，找到足够大的内存，然后申请新的资源并修改链表：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104217.webp)\n\n\nfree-list-allocator\n\n\n**图 7\\-4 空闲链表分配器**\n\n\n因为不同的内存块以链表的方式连接，所以使用这种方式分配内存的分配器可以重新利用回收的资源，但是因为分配内存时需要遍历链表，所以它的时间复杂度就是O\\(n\\)。空闲链表分配器可以选择不同的策略在链表中的内存块中进行选择，最常见的就是以下四种方式：\n\n- 首次适应（First-Fit）— 从链表头开始遍历，选择第一个大小大于申请内存的内存块；\n- 循环首次适应（Next-Fit）— 从上次遍历的结束位置开始遍历，选择第一个大小大于申请内存的内存块；\n- 最优适应（Best-Fit）— 从链表头遍历整个链表，选择最合适的内存块；\n- 隔离适应（Segregated-Fit）— 将内存分割成多个链表，每个链表中的内存块大小相同，申请内存时先找到满足条件的链表，再从链表中选择合适的内存块；\n\n上述四种策略的前三种就不过多介绍了，Go 语言使用的内存分配策略与第四种策略有些相似，我们通过下图了解一下该策略的原理：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104636.webp)\n\n\nsegregated-list\n\n\n**图 7\\-5 隔离适应策略**\n\n\n如上图所示，该策略会将内存分割成由 4、8、16、32 字节的内存块组成的链表，当我们向内存分配器申请 8 字节的内存时，我们会在上图中的第二个链表找到空闲的内存块并返回。隔离适应的分配策略减少了需要遍历的内存块数量，提高了内存分配的效率。\n\n\n### 分级分配\n\n\n线程缓存分配（Thread-Caching Malloc，TCMalloc）是用于分配内存的的机制，它比 glibc 中的 `malloc` 函数还要快很多\\[^2\\]。Go 语言的内存分配器就借鉴了 TCMalloc 的设计实现高速的内存分配，它的核心理念是使用多级缓存根据将对象根据大小分类，并按照类别实施不同的分配策略。\n\n\n### 对象大小\n\n\nGo 语言的内存分配器会根据申请分配的内存大小选择不同的处理逻辑，运行时根据对象的大小将对象分成微对象、小对象和大对象三种：\n\n\n| 类别  | 大小            |\n| --- | ------------- |\n| 微对象 | `(0, 16B)`    |\n| 小对象 | `[16B, 32KB]` |\n| 大对象 | `(32KB, +∞)`  |\n\n\n**表 7\\-1 对象的类别和大小**\n\n\n因为程序中的绝大多数对象的大小都在 32KB 以下，而申请的内存大小影响 Go 语言运行时分配内存的过程和开销，所以分别处理大对象和小对象有利于提高内存分配器的性能。\n\n\n### 多级缓存\n\n\n内存分配器不仅会区别对待大小不同的对象，还会将内存分成不同的级别分别管理，TCMalloc 和 Go 运行时分配器都会引入线程缓存（Thread Cache）、中心缓存（Central Cache）和页堆（Page Heap）三个组件分级管理内存：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104816.webp)\n\n\nmulti-level-cache\n\n\n**图 7\\-6 多级缓存内存分配**\n\n\n线程缓存属于每一个独立的线程，它能够满足线程上绝大多数的内存分配需求，因为不涉及多线程，所以也不需要使用互斥锁来保护内存，这能够减少锁竞争带来的性能损耗。当线程缓存不能满足需求时，就会使用中心缓存作为补充解决小对象的内存分配问题；在遇到 32KB 以上的对象时，内存分配器就会选择页堆直接分配大量的内存。\n\n\n这种多层级的内存分配设计与计算机操作系统中的多级缓存也有些类似，因为多数的对象都是小对象，我们可以通过线程缓存和中心缓存提供足够的内存空间，发现资源不足时就从上一级组件中获取更多的内存资源。\n\n\n### 虚拟内存布局\n\n\n这里会介绍 Go 语言堆区内存地址空间的设计以及演进过程，在 Go 语言 1.10 以前的版本，堆区的内存空间都是连续的；但是在 1.11 版本，Go 团队使用稀疏的堆内存空间替代了连续的内存，解决了连续内存带来的限制以及在特殊场景下可能出现的问题。\n\n\n### 线性内存\n\n\nGo 语言程序的 1.10 版本在启动时会初始化整片虚拟内存区域，如下所示的三个区域 `spans`、 `bitmap` 和 `arena` 分别预留了 512MB、16GB 以及 512GB 的内存空间，这些内存并不是真正存在的物理内存，而是虚拟内存：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104845.webp)\n\n\nheap-before-go-1-11\n\n\n**图 7\\-7 堆区的线性内存**\n\n- `spans` 区域存储了指向内存管理单元 `runtime.mspan` 的指针，每个内存单元会管理几页的内存空间，每页大小为 8KB；\n- `bitmap` 用于标识 `arena` 区域中的那些地址保存了对象，位图中的每个字节都会表示堆区中的 32 字节是否包含空闲；\n- `arena` 区域是真正的堆区，运行时会将 8KB 看做一页，这些内存页中存储了所有在堆上初始化的对象；\n\n对于任意一个地址，我们都可以根据 `arena` 的基地址计算该地址所在的页数并通过 `spans` 数组获得管理该片内存的管理单元 `runtime.mspan`， `spans` 数组中多个连续的位置可能对应同一个 `runtime.mspan`。\n\n\nGo 语言在垃圾回收时会根据指针的地址判断对象是否在堆中，并通过上一段中介绍的过程找到管理该对象的 `runtime.mspan`。这些都建立在**堆区的内存是连续的**这一假设上。这种设计虽然简单并且方便，但是在 C 和 Go 混合使用时会导致程序崩溃：\n\n1. 分配的内存地址会发生冲突，导致堆的初始化和扩容失败\\[^3\\]；\n2. 没有被预留的大块内存可能会被分配给 C 语言的二进制，导致扩容后的堆不连续\\[^4\\]；\n\n线性的堆内存需要预留大块的内存空间，但是申请大块的内存空间而不使用是不切实际的，不预留内存空间却会在特殊场景下造成程序崩溃。虽然连续内存的实现比较简单，但是这些问题我们也没有办法忽略。\n\n\n### 稀疏内存\n\n\n稀疏内存是 Go 语言在 1.11 中提出的方案，使用稀疏的内存布局不仅能移除堆大小的上限\\[^5\\]，还能解决 C 和 Go 混合使用时的地址空间冲突问题\\[^6\\]。不过因为基于稀疏内存的内存管理失去了内存的连续性这一假设，这也使内存管理变得更加复杂：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225104924.webp)\n\n\nheap-after-go-1-11\n\n\n**图 7-8 二维稀疏内存**\n\n\n如上图所示，运行时使用二维的 `runtime.heapArena` 数组管理所有的内存，每个单元都会管理 64MB 的内存空间：\n\n\n```go\ntype heapArena struct {\n    bitmap [heapArenaBitmapBytes]byte\n    spans [pagesPerArena]*mspan\n    pageInUse [pagesPerArena / 8]uint8\n    pageMarks [pagesPerArena / 8]uint8\n    zeroedBase uintptr\n}\n```\n\n\n该结构体中的 `bitmap` 和 `spans` 与线性内存中的 `bitmap` 和 `spans` 区域一一对应，`zeroedBase` 字段指向了该结构体管理的内存的基地址。这种设计将原有的连续大内存切分成稀疏的小内存，而用于管理这些内存的元信息也被切分成了小块。\n\n\n不同平台和架构的二维数组大小可能完全不同，如果我们的 Go 语言服务在 Linux 的 x86\\-64 架构上运行，二维数组的一维大小会是 1，而二维大小是 4,194,304，因为每一个指针占用 8 字节的内存空间，所以元信息的总大小为 32MB。由于每个 `runtime.heapArena` 都会管理 64MB 的内存，整个堆区最多可以管理 256TB 的内存，这比之前的 512GB 多好几个数量级。\n\n\nGo 语言团队在 1.11 版本中通过以下几个提交将线性内存变成稀疏内存，移除了 512GB 的内存上限以及堆区内存连续性的假设：\n\n- runtime: use sparse mappings for the heap\n- runtime: fix various contiguous bitmap assumptions\n- runtime: make the heap bitmap sparse\n- runtime: abstract remaining mheap.spans access\n- runtime: make span map sparse\n- runtime: eliminate most uses of mheap\\_.arena\\_\\*\n- runtime: remove non\\-reserved heap logic\n- runtime: move comment about address space sizes to malloc.go\n\n由于内存的管理变得更加复杂，上述改动对垃圾回收稍有影响，大约会增加 1% 的垃圾回收开销，不过这也是我们为了解决已有问题必须付出的成本\\[^7\\]。\n\n\n### 地址空间\n\n\n因为所有的内存最终都是要从操作系统中申请的，所以 Go 语言的运行时构建了操作系统的内存管理抽象层，该抽象层将运行时管理的地址空间分成以下的四种状态\\[^8\\]：\n\n\n| 状态         | 解释                                                |\n| ---------- | ------------------------------------------------- |\n| `None`     | 内存没有被保留或者映射，是地址空间的默认状态                            |\n| `Reserved` | 运行时持有该地址空间，但是访问该内存会导致错误                           |\n| `Prepared` | 内存被保留，一般没有对应的物理内存访问该片内存的行为是未定义的可以快速转换到 `Ready` 状态 |\n| `Ready`    | 可以被安全访问                                           |\n\n\n**表 7\\-2 地址空间的状态**\n\n\n每一个不同的操作系统都会包含一组特定的方法，这些方法可以让内存地址空间在不同的状态之间做出转换，我们可以通过下图了解不同状态之间的转换过程：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225105123.webp)\n\n\nmemory-regions-states-and-transitions\n\n\n**图 7-9 地址空间的状态转换**\n\n\n运行时中包含多个操作系统对状态转换方法的实现，所有的实现都包含在以 `mem_` 开头的文件中，本节将介绍 Linux 操作系统对上图中方法的实现：\n\n- `runtime.sysAlloc` 会从操作系统中获取一大块可用的内存空间，可能为几百 KB 或者几 MB；\n- `runtime.sysFree` 会在程序发生内存不足（Out\\-of Memory，OOM）时调用并无条件地返回内存；\n- `runtime.sysReserve` 会保留操作系统中的一片内存区域，对这片内存的访问会触发异常；\n- `runtime.sysMap` 保证内存区域可以快速转换至准备就绪；\n- `runtime.sysUsed` 通知操作系统应用程序需要使用该内存区域，需要保证内存区域可以安全访问；\n- `runtime.sysUnused` 通知操作系统虚拟内存对应的物理内存已经不再需要了，它可以重用物理内存；\n- `runtime.sysFault` 将内存区域转换成保留状态，主要用于运行时的调试；\n\n运行时使用 Linux 提供的 `mmap`、 `munmap` 和 `madvise` 等系统调用实现了操作系统的内存管理抽象层，抹平了不同操作系统的差异，为运行时提供了更加方便的接口，除了 Linux 之外，运行时还实现了 BSD、Darwin、Plan9 以及 Windows 等平台上抽象层。\n\n\n## 内存管理组件\n\n\nGo 语言的内存分配器包含内存管理单元、线程缓存、中心缓存和页堆几个重要组件，本节将介绍这几种最重要组件对应的数据结构 `runtime.mspan`、 `runtime.mcache`、`runtime.mcentral` 和 `runtime.mheap`，我们会详细介绍它们在内存分配器中的作用以及实现。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225105155.jpg)\n\n\ngo-memory-layout\n\n\n**图 7\\-10 Go 程序的内存布局**\n\n\n所有的 Go 语言程序都会在启动时初始化如上图所示的内存布局，每一个处理器都会被分配一个线程缓存 `runtime.mcache` 用于处理微对象和小对象的分配，它们会持有内存管理单元 `runtime.mspan`。\n\n\n每个类型的内存管理单元都会管理特定大小的对象，当内存管理单元中不存在空闲对象时，它们会从 `runtime.mheap` 持有的 134 个中心缓存 `runtime.mcentral` 中获取新的内存单元，中心缓存属于全局的堆结构体 `runtime.mheap`，它会从操作系统中申请内存。\n\n\n在 amd64 的 Linux 操作系统上，`runtime.mheap` 会持有 4,194,304 `runtime.heapArena`，每一个 `runtime.heapArena` 都会管理 64MB 的内存，单个 Go 语言程序的内存上限也就是 256TB。\n\n\n### 内存管理单元\n\n\n`runtime.mspan` 是 Go 语言内存管理的基本单元，该结构体中包含 `next` 和 `prev` 两个字段，它们分别指向了前一个和后一个 `runtime.mspan`：\n\n\n```go\ntype mspan struct {\n    next *mspan\n    prev *mspan\n    ...\n}\n```\n\n\n串联后的上述结构体会构成如下双向链表，运行时会使用 `runtime.mSpanList` 存储双向链表的头结点和尾节点并在线程缓存以及中心缓存中使用。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225105309.png)\n\n\nmspan-and-linked-list\n\n\n**图 7-11 内存管理单元与双向链表**\n\n\n因为相邻的管理单元会互相引用，所以我们可以从任意一个结构体访问双向链表中的其他节点。\n\n\n### 页和内存\n\n\n每个 `runtime.mspan` 都管理 `npages` 个大小为 8KB 的页，这里的页不是操作系统中的内存页，它们是操作系统内存页的整数倍，该结构体会使用下面的这些字段来管理内存页的分配和回收：\n\n\n```go\ntype mspan struct {\n    startAddr uintptr // 起始地址\n    npages    uintptr // 页数\n    freeindex uintptr\n\n    allocBits  *gcBits\n    gcmarkBits *gcBits\n    allocCache uint64\n    ...\n}\n```\n\n- `startAddr` 和 `npages` — 确定该结构体管理的多个页所在的内存，每个页的大小都是 8KB；\n- `freeindex` — 扫描页中空闲对象的初始索引；\n- `allocBits` 和 `gcmarkBits` — 分别用于标记内存的占用和回收情况；\n- `allocCache` — `allocBits` 的补码，可以用于快速查找内存中未被使用的内存；\n\n`runtime.mspan` 会以两种不同的视角看待管理的内存，当结构体管理的内存不足时，运行时会以页为单位向堆申请内存：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225105413.webp)\n\n\nmspan-and-pages\n\n\n**图 7-12 内存管理单元与页**\n\n\n当用户程序或者线程向 `runtime.mspan` 申请内存时，该结构会使用 `allocCache` 字段以对象为单位在管理的内存中快速查找待分配的空间：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225105440.webp)\n\n\nmspan-and-objects\n\n\n**图 7\\-13 内存管理单元与对象**\n\n\n如果我们能在内存中找到空闲的内存单元，就会直接返回，当内存中不包含空闲的内存时，上一级的组件 `runtime.mcache` 可能会为该结构体添加更多的内存页以满足为更多对象分配内存的需求。\n\n\n### 状态\n\n\n运行时会使用 `runtime.mSpanStateBox` 结构体存储内存管理单元的状态 `runtime.mSpanState`：\n\n\n```go\ntype mspan struct {\n    ...\n    state       mSpanStateBox\n    ...\n}\n```\n\n\n该状态可能处于 `mSpanDead`、 `mSpanInUse`、`mSpanManual` 和 `mSpanFree` 四种情况。当 `runtime.mspan` 在空闲堆中，它会处于 `mSpanFree` 状态；当 `runtime.mspan` 已经被分配时，它会处于 `mSpanInUse`、 `mSpanManual` 状态，这些状态会在遵循以下规则发生转换：\n\n- 在垃圾回收的任意阶段，可能从 `mSpanFree` 转换到 `mSpanInUse` 和 `mSpanManual`；\n- 在垃圾回收的清除阶段，可能从 `mSpanInUse` 和 `mSpanManual` 转换到 `mSpanFree`；\n- 在垃圾回收的标记阶段，不能从 `mSpanInUse` 和 `mSpanManual` 转换到 `mSpanFree`；\n\n设置 `runtime.mspan` 结构体状态的读写操作必须是原子性的避免垃圾回收造成的线程竞争问题。\n\n\n### 跨度类\n\n\n`runtime.spanClass` 是 `runtime.mspan` 结构体的跨度类，它决定了内存管理单元中存储的对象大小和个数：\n\n\n```go\ntype mspan struct {\n    ...\n    spanclass   spanClass\n    ...\n}\n```\n\n\nGo 语言的内存管理模块中一共包含 67 种跨度类，每一个跨度类都会存储特定大小的对象并且包含特定数量的页数以及对象，所有的数据都会被预选计算好并存储在 `runtime.class_to_size` 和 `runtime.class_to_allocnpages` 等变量中：\n\n\n| class | bytes/obj | bytes/span | objects | tail waste | max waste |\n| ----- | --------- | ---------- | ------- | ---------- | --------- |\n| 1     | 8         | 8192       | 1024    | 0          | 87.50%    |\n| 2     | 16        | 8192       | 512     | 0          | 43.75%    |\n| 3     | 32        | 8192       | 256     | 0          | 46.88%    |\n| 4     | 48        | 8192       | 170     | 32         | 31.52%    |\n| 5     | 64        | 8192       | 128     | 0          | 23.44%    |\n| 6     | 80        | 8192       | 102     | 32         | 19.07%    |\n| ...   | ...       | ...        | ...     | ...        | ...       |\n| 66    | 32768     | 32768      | 1       | 0          | 12.50%    |\n\n\n**表 7\\-3 跨度类的数据**\n\n\n上表展示了对象大小从 8B 到 32KB，总共 66 种跨度类的大小、存储的对象数以及浪费的内存空间，以表中的第四个跨度类为例，跨度类为 4 的 `runtime.mspan` 中对象的大小上限为 48 字节、管理 1 个页、最多可以存储 170 个对象。因为内存需要按照页进行管理，所以在尾部会浪费 32 字节的内存，当页中存储的对象都是 33 字节时，最多会浪费 31.52% 的资源：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225105827.png)\n\n\nmspan-max-waste-memory\n\n\n**图 7-14 跨度类浪费的内存**\n\n\n除了上述 66 个跨度类之外，运行时中还包含 ID 为 0 的特殊跨度类，它能够管理大于 32KB 的特殊对象，我们会在后面详细介绍大对象的分配过程，在这里就不展开说明了。\n\n\n跨度类中除了存储类别的 ID 之外，它还会存储一个 `noscan` 标记位，该标记位表示对象是否包含指针，垃圾回收会对包含指针的 `runtime.mspan` 结构体进行扫描。我们可以通过下面的几个函数和方法了解 ID 和标记位的底层存储方式：\n\n\n```go\nfunc makeSpanClass(sizeclass uint8, noscan bool) spanClass {\n    return spanClass(sizeclass<<1) | spanClass(bool2int(noscan))\n}\n\nfunc (sc spanClass) sizeclass() int8 {\n    return int8(sc >> 1)\n}\n\nfunc (sc spanClass) noscan() bool {\n    return sc&1 != 0\n}\n```\n\n\n`runtime.spanClass` 是一个 `uint8` 类型的整数，它的前 7 位存储着跨度类的 ID，最后一位表示是否包含指针，该类型提供的两个方法能够帮我们快速获取对应的字段。\n\n\n### 线程缓存\n\n\n`runtime.mcache` 是 Go 语言中的线程缓存，它会与线程上的处理器一一绑定，主要用来缓存用户程序申请的微小对象。每一个线程缓存都持有 67 \\* 2 个 `runtime.mspan`，这些内存管理单元都存储在结构体的 `alloc` 字段中：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225110041.webp)\n\n\nmcache-and-mspans\n\n\n**图 7-15 线程缓存与内存管理单元**\n\n\n线程缓存在刚刚被初始化时是不包含 `runtime.mspan` 的，只有当用户程序申请内存时才会从上一级组件获取新的 `runtime.mspan` 满足内存分配的需求。\n\n\n### 初始化\n\n\n运行时在初始化处理器时会调用 `runtime.allocmcache` 初始化线程缓存，该函数会在系统栈中使用 `runtime.mheap` 中的线程缓存分配器初始化新的 `runtime.mcache` 结构体：\n\n\n```go\nfunc allocmcache() *mcache {\n    var c *mcache\n    systemstack(func() {\n        lock(&mheap_.lock)\n        c = (*mcache)(mheap_.cachealloc.alloc())\n        c.flushGen = mheap_.sweepgen\n        unlock(&mheap_.lock)\n    })\n    for i := range c.alloc {\n        c.alloc[i] = &emptymspan\n\n    }\n    return c\n}\n```\n\n\n就像我们在上面提到的，初始化后的 `runtime.mcache` 中的所有 `runtime.mspan` 都是空的占位符 `emptymspan`。\n\n\n### 替换\n\n\n`runtime.mcache.refill` 方法会为线程缓存获取一个指定跨度类的内存管理单元，被替换的单元不能包含空闲的内存空间，而获取的单元中需要至少包含一个空闲对象用于分配内存：\n\n\n```go\nfunc (c *mcache) refill(spc spanClass) {\n    s := c.alloc[spc]\n    s = mheap_.central[spc].mcentral.cacheSpan()\n    c.alloc[spc] = s\n}\n\n```\n\n\n如上述代码所示，该函数会从中心缓存中申请新的 `runtime.mspan` 存储到线程缓存中，这也是向线程缓存中插入内存管理单元的唯一方法。\n\n\n### 微分配器\n\n\n线程缓存中还包含几个用于分配微对象的字段，下面的这三个字段组成了微对象分配器，专门为 16 字节以下的对象申请和管理内存：\n\n\n```go\ntype mcache struct {\n    tiny             uintptr\n    tinyoffset       uintptr\n    local_tinyallocs uintptr\n}\n```\n\n\n微分配器只会用于分配非指针类型的内存，上述三个字段中 `tiny` 会指向堆中的一篇内存，`tinyOffset` 是下一个空闲内存所在的偏移量，最后的 `local_tinyallocs` 会记录内存分配器中分配的对象个数。\n\n\n### 中心缓存\n\n\n`runtime.mcentral` 是内存分配器的中心缓存，与线程缓存不同，访问中心缓存中的内存管理单元需要使用互斥锁：\n\n\n```go\ntype mcentral struct {\n    lock      mutex\n    spanclass spanClass\n    nonempty  mSpanList\n    empty     mSpanList\n    nmalloc uint64\n}\n```\n\n\n每一个中心缓存都会管理某个跨度类的内存管理单元，它会同时持有两个 `runtime.mSpanList`，分别存储包含空闲对象的列表和不包含空闲对象的链表：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225110329.png)\n\n\nmcentral\\-and\\-mspans\n\n\n**图 7\\-16 中心缓存和内存管理单元**\n\n\n该结构体在初始化时，两个链表都不包含任何内存，程序运行时会扩容结构体持有的两个链表，`nmalloc` 字段也记录了该结构体中分配的对象个数。\n\n\n### 内存管理单元\n\n\n线程缓存会通过中心缓存的 `runtime.mcentral.cacheSpan` 方法获取新的内存管理单元，该方法的实现比较复杂，我们可以将其分成以下几个部分：\n\n1. 从有空闲对象的 `runtime.mspan` 链表中查找可以使用的内存管理单元；\n2. 从没有空闲对象的 `runtime.mspan` 链表中查找可以使用的内存管理单元；\n3. 调用 `runtime.mcentral.grow` 从堆中申请新的内存管理单元；\n4. 更新内存管理单元的 `allocCache` 等字段帮助快速分配内存；\n\n首先我们会在中心缓存的非空链表中查找可用的 `runtime.mspan`，根据 `sweepgen` 字段分别进行不同的处理：\n\n1. 当内存单元等待回收时，将其插入 `empty` 链表、调用 `runtime.mspan.sweep` 清理该单元并返回；\n2. 当内存单元正在被后台回收时，跳过该内存单元；\n3. 当内存单元已经被回收时，将内存单元插入 `empty` 链表并返回；\n\n```go\nfunc (c *mcentral) cacheSpan() *mspan {\n    sg := mheap_.sweepgen\n\nretry:\n    var s *mspan\n    for s = c.nonempty.first; s != nil; s = s.next {\n        if s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) { // 等待回收\n            c.nonempty.remove(s)\n            c.empty.insertBack(s)\n            s.sweep(true)\n            goto havespan\n        }\n        if s.sweepgen == sg-1 { // 正在回收\n            continue\n        }\n        c.nonempty.remove(s) // 已经回收\n        c.empty.insertBack(s)\n        goto havespan\n\n    }\n    ...\n}\n\n```\n\n\n如果中心缓存没有在 `nonempty` 中找到可用的内存管理单元，就会继续遍历其持有的 `empty` 链表，我们在这里的处理与包含空闲对象的链表几乎完全相同。当找到需要回收的内存单元时，我们也会触发 `runtime.mspan.sweep` 进行清理，如果清理后的内存单元仍然不包含空闲对象，就会重新执行相应的代码：\n\n\n```go\nfunc (c *mcentral) cacheSpan() *mspan {\n\t...\n\tfor s = c.empty.first; s != nil; s = s.next {\n\t\tif s.sweepgen == sg-2 && atomic.Cas(&s.sweepgen, sg-2, sg-1) {\n\t\t\tc.empty.remove(s)\n\t\t\ts.sweep(true)\n\t\t\tfreeIndex := s.nextFreeIndex()\n\t\t\tif freeIndex != s.nelems {\n\t\t\t\ts.freeindex = freeIndex\n\t\t\t\tgoto havespan\n\t\t\t}\n\t\t\tgoto retry // 不包含空闲对象\n\t\t}\n\t\tif s.sweepgen == sg-1 {\n\t\t\tcontinue\n\t\t}\n\t\tbreak\n\t}\n\t...\n}\n\n```\n\n\n如果 `runtime.mcentral` 在两个链表中都没有找到可用的内存单元，它会调用 `runtime.mcentral.grow` 触发扩容操作从堆中申请新的内存：\n\n\n```go\nfunc (c *mcentral) cacheSpan() *mspan {\n\t...\n\ts = c.grow()\n\tif s == nil {\n\t\treturnnil\n\t}\n\tc.empty.insertBack(s)\n\nhavespan:\n\tn := int(s.nelems) - int(s.allocCount)\n\tatomic.Xadd64(&c.nmalloc, int64(n))\n\tif gcBlackenEnabled != 0 {\n\t\tgcController.revise()\n\t}\n\tfreeByteBase := s.freeindex &^ (64 - 1)\n\twhichByte := freeByteBase / 8\n\ts.refillAllocCache(whichByte)\n\ts.allocCache >>= s.freeindex % 64\n\n\treturn s\n}\n\n```\n\n\n无论通过哪种方法获取到了内存单元，该方法的最后都会对内存单元的 `allocBits` 和 `allocCache` 等字段进行更新，让运行时在分配内存时能够快速找到空闲的对象。\n\n\n### 扩容\n\n\n中心缓存的扩容方法 `runtime.mcentral.grow` 会根据预先计算的 `class_to_allocnpages` 和 `class_to_size` 获取待分配的页数以及跨度类并调用 `runtime.mheap.alloc` 获取新的 `runtime.mspan` 结构：\n\n\n```go\nfunc (c *mcentral) grow() *mspan {\n\tnpages := uintptr(class_to_allocnpages[c.spanclass.sizeclass()])\n\tsize := uintptr(class_to_size[c.spanclass.sizeclass()])\n\n\ts := mheap_.alloc(npages, c.spanclass, true)\n\tif s == nil {\n\t\treturnnil\n\t}\n\n\tn := (npages << _PageShift) >> s.divShift * uintptr(s.divMul) >> s.divShift2\n\ts.limit = s.base() + size*n\n\theapBitsForAddr(s.base()).initSpan(s)\n\treturn s\n}\n\n```\n\n\n获取了 `runtime.mspan` 之后，我们会在上述方法中初始化 `limit` 字段并清除该结构在堆上对应的位图。\n\n\n### 页堆\n\n\n`runtime.mheap` 是内存分配的核心结构体，Go 语言程序只会存在一个全局的结构，而堆上初始化的所有对象都由该结构体统一管理，该结构体中包含两组非常重要的字段，其中一个是全局的中心缓存列表 `central`，另一个是管理堆区内存区域的 `arenas` 以及相关字段。\n\n\n页堆中包含一个长度为 134 的 `runtime.mcentral` 数组，其中 67 个为跨度类需要 `scan` 的中心缓存，另外的 67 个是 `noscan` 的中心缓存：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225110708.png)\n\n\nmheap-and-mcentrals\n\n\n**图 7\\-17 页堆与中心缓存列表**\n\n\n我们在设计原理一节中已经介绍过 Go 语言所有的内存空间都由如下所示的二维矩阵 `runtime.heapArena` 管理的，这个二维矩阵管理的内存可以是不连续的：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225110730.png)\n\n\nmheap-and-memories\n\n\n**图 7-18 页堆管理的内存区域**\n\n\n在除了 Windows 以外的 64 位操作系统中，每一个 `runtime.heapArena` 都会管理 64MB 的内存空间，如下所示的表格展示了不同平台上 Go 语言程序管理的堆区大小以及 `runtime.heapArena` 占用的内存空间：\n\n\n| 平台            | 地址位数 | Arena 大小 | 一维大小 | 二维大小        |\n| ------------- | ---- | -------- | ---- | ----------- |\n| 64-bit        | 48   | 64MB     | 1    | 4M (32MB)   |\n| windows64-bit | 48   | 4MB      | 64   | 1M  (8MB)   |\n| 32-bit        | 32   | 4MB      | 1    | 1024  (4KB) |\n| mips(le)      | 31   | 4MB      | 1    | 512  (2KB)  |\n\n\n**表 7-3 平台与页堆大小的关系**\n\n\n本节将介绍页堆的初始化、内存分配以及内存管理单元分配的过程，这些过程能够帮助我们理解全局变量页堆与其他组件的关系以及它管理内存的方式。\n\n\n### 初始化\n\n\n堆区的初始化会使用 `runtime.mheap.init` 方法，我们能看到该方法初始化了非常多的结构体和字段，不过其中初始化的两类变量比较重要：\n\n1. `spanalloc`、 `cachealloc` 以及 `arenaHintAlloc` 等 `runtime.fixalloc` 类型的空闲链表分配器；\n2. `central` 切片中 `runtime.mcentral` 类型的中心缓存；\n\n```go\nfunc (h *mheap) init() {\n\th.spanalloc.init(unsafe.Sizeof(mspan{}), recordspan, unsafe.Pointer(h), &memstats.mspan_sys)\n\th.cachealloc.init(unsafe.Sizeof(mcache{}), nil, nil, &memstats.mcache_sys)\n\th.specialfinalizeralloc.init(unsafe.Sizeof(specialfinalizer{}), nil, nil, &memstats.other_sys)\n\th.specialprofilealloc.init(unsafe.Sizeof(specialprofile{}), nil, nil, &memstats.other_sys)\n\th.arenaHintAlloc.init(unsafe.Sizeof(arenaHint{}), nil, nil, &memstats.other_sys)\n\n\th.spanalloc.zero = false\n\n\tfor i := range h.central {\n\t\th.central[i].mcentral.init(spanClass(i))\n\t}\n\n\th.pages.init(&h.lock, &memstats.gc_sys)\n}\n\n```\n\n\n堆中初始化的多个空闲链表分配器与我们在设计原理一节中提到的分配器没有太多区别，当我们调用 `runtime.fixalloc.init` 初始化分配器时，需要传入带初始化的结构体大小等信息，这会帮助分配器分割待分配的内存，该分配器提供了以下两个用于分配和释放内存的方法：\n\n1. `runtime.fixalloc.alloc` — 获取下一个空闲的内存空间；\n2. `runtime.fixalloc.free` — 释放指针指向的内存空间；\n\n除了这些空闲链表分配器之外，我们还会在该方法中初始化所有的中心缓存，这些中心缓存会维护全局的内存管理单元，各个线程会通过中心缓存获取新的内存单元。\n\n\n### 内存管理单元\n\n\n`runtime.mheap` 是内存分配器中的核心组件，运行时会通过它的 `runtime.mheap.alloc` 方法在系统栈中获取新的 `runtime.mspan`：\n\n\n```go\nfunc (h *mheap) alloc(npages uintptr, spanclass spanClass, needzero bool) *mspan {\n\tvar s *mspan\n\tsystemstack(func() {\n\t\tif h.sweepdone == 0 {\n\t\t\th.reclaim(npages)\n\t\t}\n\t\ts = h.allocSpan(npages, false, spanclass, &memstats.heap_inuse)\n\t})\n\t...\n\treturn s\n}\n\n```\n\n\n为了阻止内存的大量占用和堆的增长，我们在分配对应页数的内存前需要先调用 `runtime.mheap.reclaim` 方法回收一部分内存，接下来我们将通过 `runtime.mheap.allocSpan` 分配新的内存管理单元，我们会将该方法的执行过程拆分成两个部分：\n\n1. 从堆上分配新的内存页和内存管理单元 `runtime.mspan`；\n2. 初始化内存管理单元并将其加入 `runtime.mheap` 持有内存单元列表；\n\n首先我们需要在堆上申请 `npages` 数量的内存页并初始化 `runtime.mspan`：\n\n\n```go\nfunc (h *mheap) allocSpan(npages uintptr, manual bool, spanclass spanClass, sysStat *uint64) (s *mspan) {\n\tgp := getg()\n\tbase, scav := uintptr(0), uintptr(0)\n\tpp := gp.m.p.ptr()\n\tif pp != nil && npages < pageCachePages/4 {\n\t\tc := &pp.pcache\n\t\tbase, scav = c.alloc(npages)\n\t\tif base != 0 {\n\t\t\ts = h.tryAllocMSpan()\n\t\t\tif s != nil && gcBlackenEnabled == 0 && (manual || spanclass.sizeclass() != 0) {\n\t\t\t\tgoto HaveSpan\n\t\t\t}\n\t\t}\n\t}\n\n\tif base == 0 {\n\t\tbase, scav = h.pages.alloc(npages)\n\t\tif base == 0 {\n\t\t\th.grow(npages)\t\t\tbase, scav = h.pages.alloc(npages)\n\t\t\tif base == 0 {\n\t\t\t\tthrow(\"grew heap, but no adequate free space found\")\n\t\t\t}\n\t\t}\n\t}\n\tif s == nil {\n\t\ts = h.allocMSpanLocked()\n\t}\n\t...\n}\n\n```\n\n\n上述方法会通过处理器的页缓存 `runtime.pageCache` 或者全局的页分配器 `runtime.pageAlloc` 两种途径从堆中申请内存：\n\n1. 如果申请的内存比较小，获取申请内存的处理器并尝试调用 `runtime.pageCache.alloc` 获取内存区域的基地址和大小；\n2. 如果申请的内存比较大或者线程的页缓存中内存不足，会通过 `runtime.pageAlloc.alloc` 在页堆上申请内存；\n3. 如果发现页堆上的内存不足，会尝试通过 `runtime.mheap.grow` 进行扩容并重新调用 `runtime.pageAlloc.alloc` 申请内存；\n4. 如果申请到内存，意味着扩容成功；\n5. 如果没有申请到内存，意味着扩容失败，宿主机可能不存在空闲内存，运行时会直接中止当前程序；\n\n无论通过哪种方式获得内存页，我们都会在该函数中分配新的 `runtime.mspan` 结构体；该方法的剩余部分会通过页数、内存空间以及跨度类等参数初始化它的多个字段：\n\n\n```go\nfunc (h *mheap) alloc(npages uintptr, spanclass spanClass, needzero bool) *mspan {\n\t...\nHaveSpan:\n\ts.init(base, npages)\n\n\t...\n\n\ts.freeindex = 0\n\ts.allocCache = ^uint64(0)\n\ts.gcmarkBits = newMarkBits(s.nelems)\n\ts.allocBits = newAllocBits(s.nelems)\n\th.setSpans(s.base(), npages, s)\n\treturn s\n}\n\n```\n\n\n在上述代码中，我们通过调用 `runtime.mspan.init` 方法以及设置参数初始化刚刚分配的 `runtime.mspan` 结构并通过 `runtime.mheaps.setSpans` 方法建立页堆与内存单元的联系。\n\n\n### 扩容\n\n\n`runtime.mheap.grow` 方法会向操作系统申请更多的内存空间，传入的页数经过对齐可以得到期望的内存大小，我们可以将该方法的执行过程分成以下几个部分：\n\n1. 通过传入的页数获取期望分配的内存空间大小以及内存的基地址；\n2. 如果 `arena` 区域没有足够的空间，调用 `runtime.mheap.sysAlloc` 从操作系统中申请更多的内存；\n3. 扩容 `runtime.mheap` 持有的 `arena` 区域并更新页分配器的元信息；\n4. 在某些场景下，调用 `runtime.pageAlloc.scavenge` 回收不再使用的空闲内存页；\n\n在页堆扩容的过程中，`runtime.mheap.sysAlloc` 是页堆用来申请虚拟内存的方法，我们会分几部分介绍该方法的实现。首先，该方法会尝试在预保留的区域申请内存：\n\n\n```go\nfunc (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {\n\tn = alignUp(n, heapArenaBytes)\n\n\tv = h.arena.alloc(n, heapArenaBytes, &memstats.heap_sys)\n\tif v != nil {\n\t\tsize = n\n\t\tgoto mapped\n\t}\n\t...\n}\n\n```\n\n\n上述代码会调用线性分配器的 `runtime.linearAlloc.alloc` 方法在预先保留的内存中申请一块可以使用的空间。如果没有可用的空间，我们会根据页堆的 `arenaHints` 在目标地址上尝试扩容：\n\n\n```go\nfunc (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {\n\t...\n\tfor h.arenaHints != nil {\n\t\thint := h.arenaHints\n\t\tp := hint.addr\n\t\tv = sysReserve(unsafe.Pointer(p), n)\n\t\tif p == uintptr(v) {\n\t\t\thint.addr = p\n\t\t\tsize = n\n\t\t\tbreak\n\t\t}\n\t\th.arenaHints = hint.next\n\t\th.arenaHintAlloc.free(unsafe.Pointer(hint))\n\t}\n\t...\n\tsysMap(v, size, &memstats.heap_sys)\n\t...\n}\n```\n\n\n`runtime.sysReserve` 和 `runtime.sysMap` 是上述代码的核心部分，它们会从操作系统中申请内存并将内存转换至 `Prepared` 状态。\n\n\n```go\nfunc (h *mheap) sysAlloc(n uintptr) (v unsafe.Pointer, size uintptr) {\n\t...\nmapped:\n\tfor ri := arenaIndex(uintptr(v)); ri <= arenaIndex(uintptr(v)+size-1); ri++ {\n\t\tl2 := h.arenas[ri.l1()]\n\t\tr := (*heapArena)(h.heapArenaAlloc.alloc(unsafe.Sizeof(*r), sys.PtrSize, &memstats.gc_sys))\n\t\t...\n\t\th.allArenas = h.allArenas[:len(h.allArenas)+1]\n\t\th.allArenas[len(h.allArenas)-1] = ri\n\t\tatomic.StorepNoWB(unsafe.Pointer(&l2[ri.l2()]), unsafe.Pointer(r))\n\t}\n\treturn\n}\n```\n\n\n`runtime.mheap.sysAlloc` 方法在最后会初始化一个新的 `runtime.heapArena` 结构体来管理刚刚申请的内存空间，该结构体会被加入页堆的二维矩阵中。\n\n\n## 内存分配\n\n\n堆上所有的对象都会通过调用 `runtime.newobject` 函数分配内存，该函数会调用 `runtime.mallocgc` 分配指定大小的内存空间，这也是用户程序向堆上申请内存空间的必经函数：\n\n\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n\tmp := acquirem()\n\tmp.mallocing = 1\n\n\tc := gomcache()\n\tvar x unsafe.Pointer\n\tnoscan := typ == nil || typ.ptrdata == 0\n\tif size <= maxSmallSize {\n\t\tif noscan && size < maxTinySize {\n\t\t\t// 微对象分配\n\t\t} else {\n\t\t\t// 小对象分配\n\t\t}\n\t} else {\n\t\t// 大对象分配\n\t}\n\n\tpublicationBarrier()\n\tmp.mallocing = 0\n\treleasem(mp)\n\n\treturn x\n}\n```\n\n\n上述代码使用 `runtime.gomcache` 获取了线程缓存并通过类型判断类型是否为指针类型。我们从这个代码片段可以看出 `runtime.mallocgc` 会根据对象的大小执行不同的分配逻辑，在前面的章节也曾经介绍过运行时根据对象大小将它们分成微对象、小对象和大对象，这里会根据大小选择不同的分配逻辑：\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225110935.webp)\n\n\nallocator-and-memory-size\n\n\n**图 7-19 三种对象**\n\n- 微对象 `(0, 16B)` — 先使用微型分配器，再依次尝试线程缓存、中心缓存和堆分配内存；\n- 小对象 `[16B, 32KB]` — 依次尝试使用线程缓存、中心缓存和堆分配内存；\n- 大对象 `(32KB, +∞)` — 直接在堆上分配内存；\n\n我们会依次介绍运行时分配微对象、小对象和大对象的过程，梳理内存分配的核心执行流程。\n\n\n### 微对象\n\n\nGo 语言运行时将小于 16 字节的对象划分为微对象，它会使用线程缓存上的微分配器提高微对象分配的性能，我们主要使用它来分配较小的字符串以及逃逸的临时变量。微分配器可以将多个较小的内存分配请求合入同一个内存块中，只有当内存块中的所有对象都需要被回收时，整片内存才可能被回收。\n\n\n微分配器管理的对象不可以是指针类型，管理多个对象的内存块大小 `maxTinySize` 是可以调整的，在默认情况下，内存块的大小为 16 字节。`maxTinySize` 的值越大，组合多个对象的可能性就越高，内存浪费也就越严重；`maxTinySize` 越小，内存浪费就会越少，不过无论如何调整，8 的倍数都是一个很好的选择。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20201225111018.webp)\n\n\ntiny-allocator\n\n\n**图 7-20 微分配器的工作原理**\n\n\n如上图所示，微分配器已经在 16 字节的内存块中分配了 12 字节的对象，如果下一个待分配的对象小于 4 字节，它就会直接使用上述内存块的剩余部分，减少内存碎片，不过该内存块只有在 3 个对象都被标记为垃圾时才会被回收。\n\n\n线程缓存 `runtime.mcache` 中的 `tiny` 字段指向了 `maxTinySize` 大小的块，如果当前块中还包含大小合适的空闲内存，运行时会通过基地址和偏移量获取并返回这块内存：\n\n\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n\t...\n\tif size <= maxSmallSize {\n\t\tif noscan && size < maxTinySize {\n\t\t\toff := c.tinyoffset\n\t\t\tif off+size <= maxTinySize && c.tiny != 0 {\n\t\t\t\tx = unsafe.Pointer(c.tiny + off)\n\t\t\t\tc.tinyoffset = off + size\n\t\t\t\tc.local_tinyallocs++\n\t\t\t\treleasem(mp)\n\t\t\t\treturn x\n\t\t\t}\n\t\t\t...\n\t\t}\n\t\t...\n\t}\n\t...\n}\n```\n\n\n当内存块中不包含空闲的内存时，下面的这段代码会从先线程缓存找到跨度类对应的内存管理单元 `runtime.mspan`，调用 `runtime.nextFreeFast` 获取空闲的内存；当不存在空闲内存时，我们会调用 `runtime.mcache.nextFree` 从中心缓存或者页堆中获取可分配的内存块：\n\n\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n\t...\n\tif size <= maxSmallSize {\n\t\tif noscan && size < maxTinySize {\n\t\t\t...\n\t\t\tspan := c.alloc[tinySpanClass]\n\t\t\tv := nextFreeFast(span)\n\t\t\tif v == 0 {\n\t\t\t\tv, _, _ = c.nextFree(tinySpanClass)\n\t\t\t}\n\t\t\tx = unsafe.Pointer(v)\n\t\t\t(*[2]uint64)(x)[0] = 0\n\t\t\t(*[2]uint64)(x)[1] = 0\n\t\t\tif size < c.tinyoffset || c.tiny == 0 {\n\t\t\t\tc.tiny = uintptr(x)\n\t\t\t\tc.tinyoffset = size\n\t\t\t}\n\t\t\tsize = maxTinySize\n\t\t}\n\t\t...\n\t}\n\t...\n\treturn x\n}\n```\n\n\n获取新的空闲内存块之后，上述代码会清空空闲内存中的数据、更新构成微对象分配器的几个字段 `tiny` 和 `tinyoffset` 并返回新的空闲内存。\n\n\n### 小对象\n\n\n小对象是指大小为 16 字节到 32,768 字节的对象以及所有小于 16 字节的指针类型的对象，小对象的分配可以被分成以下的三个步骤：\n\n1. 确定分配对象的大小以及跨度类 `runtime.spanClass`；\n2. 从线程缓存、中心缓存或者堆中获取内存管理单元并从内存管理单元找到空闲的内存空间；\n3. 调用 `runtime.memclrNoHeapPointers` 清空空闲内存中的所有数据；\n\n确定待分配的对象大小以及跨度类需要使用预先计算好的 `size_to_class8`、 `size_to_class128` 以及 `class_to_size` 字典，这些字典能够帮助我们快速获取对应的值并构建 `runtime.spanClass`：\n\n\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n\t...\n\tif size <= maxSmallSize {\n\t\t...\n\t\t} else {\n\t\t\tvar sizeclass uint8\n\t\t\tif size <= smallSizeMax-8 {\n\t\t\t\tsizeclass = size_to_class8[(size+smallSizeDiv-1)/smallSizeDiv]\n\t\t\t} else {\n\t\t\t\tsizeclass = size_to_class128[(size-smallSizeMax+largeSizeDiv-1)/largeSizeDiv]\n\t\t\t}\n\t\t\tsize = uintptr(class_to_size[sizeclass])\n\t\t\tspc := makeSpanClass(sizeclass, noscan)\n\t\t\tspan := c.alloc[spc]\n\t\t\tv := nextFreeFast(span)\n\t\t\tif v == 0 {\n\t\t\t\tv, span, _ = c.nextFree(spc)\n\t\t\t}\n\t\t\tx = unsafe.Pointer(v)\n\t\t\tif needzero && span.needzero != 0 {\n\t\t\t\tmemclrNoHeapPointers(unsafe.Pointer(v), size)\n\t\t\t}\n\t\t}\n\t} else {\n\t\t...\n\t}\n\t...\n\treturn x\n}\n```\n\n\n在上述代码片段中，我们会重点分析两个函数和方法的实现原理，它们分别是 `runtime.nextFreeFast` 和 `runtime.mcache.nextFree`，这两个函数会帮助我们获取空闲的内存空间。 `runtime.nextFreeFast` 会利用内存管理单元中的 `allocCache` 字段，快速找到该字段中位 1 的位数，我们在上面介绍过 1 表示该位对应的内存空间是空闲的：\n\n\n```go\nfunc nextFreeFast(s *mspan) gclinkptr {\n\ttheBit := sys.Ctz64(s.allocCache)\n\tif theBit < 64 {\n\t\tresult := s.freeindex + uintptr(theBit)\n\t\tif result < s.nelems {\n\t\t\tfreeidx := result + 1\n\t\t\tif freeidx%64 == 0 && freeidx != s.nelems {\n\t\t\t\treturn0\n\t\t\t}\n\t\t\ts.allocCache >>= uint(theBit + 1)\n\t\t\ts.freeindex = freeidx\n\t\t\ts.allocCount++\n\t\t\treturn gclinkptr(result*s.elemsize + s.base())\n\t\t}\n\t}\n\treturn0\n}\n```\n\n\n找到了空闲的对象后，我们就可以更新内存管理单元的 `allocCache`、 `freeindex` 等字段并返回该片内存了；如果我们没有找到空闲的内存，运行时会通过 `runtime.mcache.nextFree` 找到新的内存管理单元：\n\n\n```go\nfunc (c *mcache) nextFree(spc spanClass) (v gclinkptr, s *mspan, shouldhelpgc bool) {\n\ts = c.alloc[spc]\n\tfreeIndex := s.nextFreeIndex()\n\tif freeIndex == s.nelems {\n\t\tc.refill(spc)\n\t\ts = c.alloc[spc]\n\t\tfreeIndex = s.nextFreeIndex()\n\t}\n\n\tv = gclinkptr(freeIndex*s.elemsize + s.base())\n\ts.allocCount++\n\treturn\n}\n```\n\n\n在上述方法中，如果我们在线程缓存中没有找到可用的内存管理单元，会通过前面介绍的 `runtime.mcache.refill` 使用中心缓存中的内存管理单元替换已经不存在可用对象的结构体，该方法会调用新结构体的 `runtime.mspan.nextFreeIndex` 获取空闲的内存并返回。\n\n\n### 大对象\n\n\n运行时对于大于 32KB 的大对象会单独处理，我们不会从线程缓存或者中心缓存中获取内存管理单元，而是直接在系统的栈中调用 `runtime.largeAlloc` 函数分配大片的内存：\n\n\n```go\nfunc mallocgc(size uintptr, typ *_type, needzero bool) unsafe.Pointer {\n\t...\n\tif size <= maxSmallSize {\n\t\t...\n\t} else {\n\t\tvar s *mspan\n\t\tsystemstack(func() {\n\t\t\ts = largeAlloc(size, needzero, noscan)\n\t\t})\n\t\ts.freeindex = 1\n\t\ts.allocCount = 1\n\t\tx = unsafe.Pointer(s.base())\n\t\tsize = s.elemsize\n\t}\n\n\tpublicationBarrier()\n\tmp.mallocing = 0\n\treleasem(mp)\n\n\treturn x\n}\n```\n\n\n`runtime.largeAlloc` 函数会计算分配该对象所需要的页数，它会按照 8KB 的倍数为对象在堆上申请内存：\n\n\n```go\nfunc largeAlloc(size uintptr, needzero bool, noscan bool) *mspan {\n\tnpages := size >> _PageShift\n\tif size&_PageMask != 0 {\n\t\tnpages++\n\t}\n\t...\n\ts := mheap_.alloc(npages, makeSpanClass(0, noscan), needzero)\n\ts.limit = s.base() + size\n\theapBitsForAddr(s.base()).initSpan(s)\n\treturn s\n}\n```\n\n\n申请内存时会创建一个跨度类为 0 的 `runtime.spanClass` 并调用 `runtime.mheap.alloc` 分配一个管理对应内存的管理单元。\n\n\n## 小结\n\n\n内存分配是 Go 语言运行时内存管理的核心逻辑，运行时的内存分配器使用类似 TCMalloc 的分配策略将对象根据大小分类，并设计多层级的组件提高内存分配器的性能。本节不仅介绍了 Go 语言内存分配器的设计与实现原理，同时也介绍了内存分配器的常见设计，帮助我们理解不同编程语言在设计内存分配器时做出的不同选择。\n\n\n内存分配器虽然非常重要，但是它只解决了如何分配内存的问题，我们在本节中省略了很多与垃圾回收相关的代码，没有分析运行时垃圾回收的实现原理，在下一节中我们将详细分析 Go 语言垃圾回收的设计与实现原理。\n\n",
      "properties": {
        "date": "2022-02-27",
        "type": "Post",
        "category": "Golang",
        "slug": "the-design-and-implement-of-golang-malloc",
        "tags": [
          "Golang 原理"
        ],
        "summary": "原文链接 https://mp.weixin.qq.com/s/TO_lmlFbVDgFmns9s_mMzw\n\n程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域 — 栈区（Stack）和堆区（Heap）。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。\n\n不同的编程语言会选择不同的方式管理内存，本节会介绍 Go 语言内存分配器，详细分析内存分配的过程以及其背后的设计与实现原理。",
        "title": "Go 内存分配器的设计与实现[转载]",
        "status": "Published",
        "urlname": "8fa8898a-3851-4346-8e67-8d17aa5430f5",
        "updated": "2023-07-14 10:59:00"
      },
      "catalog": [
        {
          "title": "2022-02-27",
          "doc_id": "8fa8898a-3851-4346-8e67-8d17aa5430f5"
        }
      ],
      "body": "",
      "realName": "Go 内存分配器的设计与实现[转载]",
      "relativePath": "/2022-02-27/Go 内存分配器的设计与实现[转载].md"
    },
    {
      "id": "6962857b-5906-4f7e-825a-d671e2b403e7",
      "doc_id": "6962857b-5906-4f7e-825a-d671e2b403e7",
      "title": "6962857b-5906-4f7e-825a-d671e2b403e7",
      "updated": 1689301260000,
      "body_original": "\n## 什么是内存逃逸\n\n\n在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在`堆上分配`，这种从\"栈\"上逃逸到\"堆\"上的现象就成为`内存逃逸`。\n\n\n## 典型场景\n\n- **函数返回局部指针变量**。 局部变量原本应该在栈中分配，在栈中回收。但是由于返回时被外部引用，因此其生命周期大于栈，则溢出。\n- **发送指针或带有指针的值到 channel 中。** 在编译时，是没有办法知道哪个 goroutine 会在 channel 上接收数据。所以编译器没法知道变量什么时候才会被释放。\n- **在一个切片上存储指针或带指针的值。** 一个典型的例子就是 []*string 。这会导致切片的内容逃逸。尽管其后面的数组可能是在栈上分配的，但其引用的值一定是在堆上。\n- **slice 的背后数组被重新分配了，因为 append 时可能会超出其容量( cap )。** slice 初始化的地方在编译时是可以知道的，它最开始会在栈上分配。如果切片背后的存储要基于运行时的数据进行扩充，就会在堆上分配。\n- **interface动态类型逃逸**。`interface{}` 可以表示任意的类型，如果函数参数为 `interface{}`，编译期间很难确定其参数的具体类型，也会发生逃逸。\n- **在 interface 类型上调用方法。** 在 interface 类型上调用方法都是动态调度的 —— 方法的真正实现只能在运行时知道。想像一个 io.Reader 类型的变量 r , 调用 r.Read(b) 会使得 r 的值和切片b 的背后存储都逃逸掉，所以会在堆上分配。\n- **变量大小不确定及栈空间不足引发逃逸**。我们可以看到，当栈空间足够时，不会发生逃逸，但是当变量过大时，已经完全超过栈空间的大小时，将会发生逃逸到堆上分配内存。同样当我们初始化切片时，没有直接指定大小，而是填入的变量，这种情况为了保证内存的安全，编译器也会触发逃逸，在堆上进行分配内存。\n\n## 举例\n\n\n通过 `go build -gcflags=-m` 可以查看逃逸的情况，使用 `go build -gcflags=\"-m -m -l\"` 可以查看到更详细的逃逸分析的结果。`-m -m` 查看编译器的所有优化，`-l` 禁用掉内联优化。\n\n\n### 函数返回局部指针变量\n\n\n```go\npackage main\n\nimport \"fmt\"\n\ntype A struct {\n  s string\n}\n\nfunc foo(s string) *A {\n  a := new(A)\n  a.s = s\n  return a //返回局部变量a,在C语言中妥妥野指针，但在go则ok，但a会逃逸到堆\n}\n\nfunc main() {\n  a := foo(\"hello\")\n  b := a.s + \" world\"\n  c := b + \"!\"\n  fmt.Println(c)\n}\n```\n\n\n执行`go build -gcflags=-m main.go`\n\n\n```bash\n# go build -gcflags=-m main.go\n\n# command-line-arguments\n.\\main.go:11:6: can inline foo\n.\\main.go:18:10: inlining call to foo\n.\\main.go:21:13: inlining call to fmt.Println\n.\\main.go:11:10: leaking param: s\n.\\main.go:12:10: new(A) escapes to heap\n.\\main.go:18:10: new(A) does not escape\n.\\main.go:19:11: a.s + \" world\" does not escape\n.\\main.go:20:9: b + \"!\" escapes to heap\n.\\main.go:21:13: c escapes to heap\n.\\main.go:21:13: []interface {}{...} does not escape\n<autogenerated>:1: leaking param content: .this\n<autogenerated>:1: .this does not escape\n```\n\n- `.\\main.go:12:10: new(A) escapes to heap` 说明 `new(A)` 逃逸了,符合上述提到的常见情况中的第一种。\n- `.\\main.go:19:11: a.s + \" world\" does not escape` 说明 `b` 变量没有逃逸，因为它只在方法内存在，会在方法结束时被回收。\n- `.\\main.go:20:9: b + \"!\" escapes to heap` 说明 `c` 变量逃逸，通过`fmt.Println(a ...interface{})`打印的变量，都会发生逃逸。\n\n### interface类型逃逸\n\n\n```go\nfunc main()  {\n    str := \"This is str\"\n    fmt.Printf(\"%v\",str)\n}\n```\n\n\n逃逸分析结果：\n\n\n```go\ngo build -gcflags=\"-m -m -l\" ./main.go\n# command-line-arguments\n.\\main.go:7:13: str escapes to heap:\n.\\main.go:7:13:   flow: {storage for ... argument} = &{storage for str}:\n.\\main.go:7:13:     from str (spill) at .\\main.go:7:13\n.\\main.go:7:13:     from ... argument (slice-literal-element) at .\\main.go:7:12\n.\\main.go:7:13:   flow: {heap} = {storage for ... argument}:\n.\\main.go:7:13:     from ... argument (spill) at .\\main.go:7:12\n.\\main.go:7:13:     from fmt.Printf(\"%v\", ... argument...) (call parameter) at .\\main.go:7:12\n.\\main.go:7:12: ... argument does not escape\n.\\main.go:7:13: str escapes to heap\n```\n\n\n`str`是`main`函数中的一个局部变量，传递给`fmt.Println()`函数后发生了逃逸，这是因为`fmt.Println()`函数的入参是一个`interface{}`类型，如果函数参数为`interface{}`，那么在编译期间就很难确定其参数的具体类型，也会发送逃逸。\n\n\n观察这个分析结果，我们可以看到没有`moved to heap: str`，这也就是说明`str`变量并没有在堆上进行分配，只是它存储的值逃逸到堆上了，也就说任何被`str`引用的对象必须分配在堆上。如果我们把代码改成这样：\n\n\n```go\nfunc main() {\n  str := \"This is str\"\n  fmt.Printf(\"%v\", &str)\n}\n```\n\n\n逃逸分析结果：\n\n\n```bash\ngo build -gcflags=\"-m -m -l\" ./main.go\n# command-line-arguments\n.\\main.go:6:2: str escapes to heap:\n.\\main.go:6:2:   flow: {storage for ... argument} = &str:\n.\\main.go:6:2:     from &str (address-of) at .\\main.go:7:19\n.\\main.go:6:2:     from &str (interface-converted) at .\\main.go:7:19\n.\\main.go:6:2:     from ... argument (slice-literal-element) at .\\main.go:7:12\n.\\main.go:6:2:   flow: {heap} = {storage for ... argument}:\n.\\main.go:6:2:     from ... argument (spill) at .\\main.go:7:12\n.\\main.go:6:2:     from fmt.Printf(\"%v\", ... argument...) (call parameter) at .\\main.go:7:12\n.\\main.go:6:2: moved to heap: str\n.\\main.go:7:12: ... argument does not escape\n```\n\n\n这回`str`也逃逸到了堆上，在堆上进行内存分配，这是因为我们访问`str`的地址，因为入参是`interface`类型，所以变量`str`的地址以实参的形式传入`fmt.Printf`后被装箱到一个`interface{}`形参变量中，装箱的形参变量的值要在堆上分配，但是还要存储一个栈上的地址，也就是`str`的地址，堆上的对象不能存储一个栈上的地址，所以`str`也逃逸到堆上，在堆上分配内存。（**这里注意一个知识点：Go语言的参数传递只有值传递**）\n\n\n### 闭包产生的逃逸\n\n\n```go\nfunc Increase() func() int {\n    n := 0\n    return func() int {\n        n++\n        return n\n    }\n}\n\nfunc main() {\n    in := Increase()\n    fmt.Println(in()) // 1\n}\n```\n\n\n查看逃逸分析结果：\n\n\n```bash\ngo build -gcflags=\"-m -m -l\" .\\main.go\n# command-line-arguments\n.\\main.go:6:2: Increase capturing by ref: n (addr=false assign=true width=8)\n.\\main.go:7:9: func literal escapes to heap:\n.\\main.go:7:9:   flow: ~r0 = &{storage for func literal}:\n.\\main.go:7:9:     from func literal (spill) at .\\main.go:7:9\n.\\main.go:7:9:     from return func literal (return) at .\\main.go:7:2\n.\\main.go:6:2: n escapes to heap:\n.\\main.go:6:2:   flow: {storage for func literal} = &n:\n.\\main.go:6:2:     from n (captured by a closure) at .\\main.go:8:3\n.\\main.go:6:2:     from n (reference) at .\\main.go:8:3\n.\\main.go:6:2: moved to heap: n\n.\\main.go:7:9: func literal escapes to heap\n.\\main.go:15:16: in() escapes to heap:\n.\\main.go:15:16:   flow: {storage for ... argument} = &{storage for in()}:\n.\\main.go:15:16:     from in() (spill) at .\\main.go:15:16\n.\\main.go:15:16:     from ... argument (slice-literal-element) at .\\main.go:15:13\n.\\main.go:15:16:   flow: {heap} = {storage for ... argument}:\n.\\main.go:15:16:     from ... argument (spill) at .\\main.go:15:13\n.\\main.go:15:16:     from fmt.Println(... argument...) (call parameter) at .\\main.go:15:13.\\main.go:15:13: ... argument does not escape\n.\\main.go:15:16: in() escapes to heap\n```\n\n\n因为函数也是一个指针类型，所以匿名函数当作返回值时也发生了逃逸，在匿名函数中使用外部变量`n`，这个变量`n`会一直存在直到`in`被销毁，所以`n`变量逃逸到了堆上。\n\n",
      "properties": {
        "date": "2022-09-25",
        "type": "Post",
        "category": "Golang",
        "slug": "golang-memory-escape",
        "tags": [
          "Golang 原理"
        ],
        "summary": "什么是内存逃逸在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从\"栈\"上逃逸到\"堆\"上的现象就成为内存逃逸。",
        "title": "Golang 内存逃逸",
        "status": "Published",
        "urlname": "6962857b-5906-4f7e-825a-d671e2b403e7",
        "updated": "2023-07-14 10:21:00"
      },
      "catalog": [
        {
          "title": "2022-09-25",
          "doc_id": "6962857b-5906-4f7e-825a-d671e2b403e7"
        }
      ],
      "body": "",
      "realName": "Golang 内存逃逸",
      "relativePath": "/2022-09-25/Golang 内存逃逸.md"
    },
    {
      "id": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9",
      "doc_id": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9",
      "title": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9",
      "updated": 1689300600000,
      "body_original": "\n## 前言\n\n\n前段时间看了B站发的[20210713网站崩溃事件](https://www.bilibili.com/read/cv17521097) 的总结分析。小破站崩掉的具体原因已在文章做了详细的分析，就不在这里做详谈了，而是总结下文章多次提及了七层SLB、四层LB相关的 Load Balance 负载均衡知识点。\n\n\n## 四层负载均衡\n\n\n四层负载均衡就是基于 IP + 端口的负载均衡，通过虚拟 IP + 端口接收请求，然后再分配到真实的服务器。\n\n\n以常见的TCP为例，负载均衡设备在接收到第一个来自客户端的SYN 请求时，即通过上述方式选择一个最佳的服务器，并对报文中目标IP地址进行修改(改为后端服务器IP），直接转发给该服务器。TCP的连接建立，即三次握手是客户端和服务器直接建立的，负载均衡设备只是起到一个类似路由器的转发动作。在某些部署情况下，为保证服务器回包可以正确返回给负载均衡设备，在转发报文的同时可能还会对报文原来的源地址进行修改。\n\n\n### 优缺点\n\n- 优点：不对数据进行完全解析，不跟客户端建立连接（握手），请求分发的效率快。\n- 缺点：无法灵活的进行转发，负载的服务器必须部署的相同服务器，否则同一个请求信息可能获取的结果是不同的。\n\n### 相关实现\n\n- F5：硬件负载均衡器，功能很好，但是成本很高\n- lvs：重量级的四层负载软件\n- nginx：轻量级的四层负载软件，带缓存功能，正则表达式较灵活\n- haproxy：模拟四层转发，较灵活\n\n## 七层负载均衡\n\n\n七层负载均衡就是基于 URL 等应用层信息的负载均衡，通过虚拟 URL 或主机名接收请求，然后再分配到真实的服务器。除了URL，也还可根据七层的URL、浏览器类别、语言来决定是否要进行负载均衡。\n\n\n以常见的TCP为例，负载均衡设备如果要根据真正的应用层内容再选择服务器，只能先代理最终的服务器和客户端建立连接(三次握手)后，才可能接受到客户端发送的真正应用层内容的报文，然后再根据该报文中的特定字段，再加上负载均衡设备设置的服务器选择方式，决定最终选择的内部服务器。负载均衡设备在这种情况下，更类似于一个代理服务器。负载均衡和前端的客户端以及后端的服务器会分别建立TCP连接。所以从这个技术原理上来看，七层负载均衡明显的对负载均衡设备的要求更高，处理七层的能力也必然会低于四层模式的部署方式。\n\n\n### 优缺点\n\n- 优点：可以将请求分发到不同的服务上，并且可以根据请求信息进行灵活的代理转发；由于请求会通过负载均衡服务器，负载均衡服务器会过滤一些请求（例如：DOS攻击）避免所有请求信息都打到服务器上，保障了服务器的稳定运行。\n- 缺点：处于网络分层的最上层，需要对数据进行解析，与客户端建立连接，效率比较低。\n\n### 相关实现\n\n- haproxy：天生负载均衡技能，全面支持七层代理，会话保持，标记，路径转移\n- nginx：只在http协议和mail协议上功能比较好，性能与haproxy差不多\n- apache：功能较差\n- Mysql proxy：功能尚可\n\n## 四层和七层负载均衡对比\n\n\n四层负载架构设计比较简单，无需解析具体的消息内容，在网络吞吐量及处理能力上会相对比较高，而七层负载均衡的优势则体现在功能多，控制灵活强大。\n\n\n|      | 四层负載均衡          | 七层负载均偷                                   |\n| ---- | --------------- | ---------------------------------------- |\n| 基于   | 基于IP+Port       | 基于URL或主机IP等等                             |\n| 类似于  | 路由器             | 代理服务器                                    |\n| 握手次数 | 1               | 2                                        |\n| 性能   | 高, 无需解析内容       | 中, 需要解析协议识别URL, Cookie 或 HTTP Header 等信息 |\n| 安全性  | 低, 无法识别 DDoS等攻击 | 高, 可以防御SVN cookie 及SYN flood等攻击          |\n| 额外功能 | 无               | 会话保持, 图片压缩, 防盗链等                         |\n\n\n四层和七层负载均衡亦可结合使用，特别是对于存在流量很大的互联网企业，一般是先通过四层负载均衡，再通过七层负载均衡，充分发挥各层负载均衡的优势，例如B站的公网架构便是如此。\n\n\n![bilibili architecture](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/e8c53770-6f81-4ab5-b14f-eabe01953646/221030.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230820%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230820T081143Z&X-Amz-Expires=3600&X-Amz-Signature=74367ab437d391ab36344aca0b73dcb47c884e5f6b9326508875807ae09071e5&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n## 云原生的负载均衡\n\n\n进入云原生时代，Web应用普遍会打包为容器并运行于 Kubernetes 之上，K8S 在设计之初就充分考虑了针对容器的服务发现与负载均衡机制，大致可以分为以下几种机制，每种机制都有其特定的应用场景：\n\n- Service：直接用 Service 提供 cluster 内部的负载均衡，并借助 cloud provider 提供的 LB 提供外部访问\n- Ingress Controller：还是用 Service 提供 cluster 内部的负载均衡，但是通过自定义 LB 提供外部访问\n- Service Load Balancer：把 load balancer 直接跑在容器中，实现 Bare Metal 的 Service Load Balancer\n- Custom Load Balancer：自定义负载均衡，并替代 kube-proxy，一般在物理部署 Kubernetes 时使用，方便接入公司已有的外部服务\n\n当一个部署于K8S中的应用需要对外暴露时，一般会先创建关联此Pod的Service和Ingress，外部的流量会通过Ingress 到 Service 再转发对应的Pod。这是一种先七层再四层负载均衡的架构。Ingress 原生仅支持七层负载均衡，不过部分的 Ingress Controller 也实现了四层的负载均衡，如ingress-nginx等等，根据需要安装这些 Controller，也可在 Ingress 这一层实现四层负载均衡。\n\n",
      "properties": {
        "date": "2022-10-30",
        "type": "Post",
        "category": "项目架构",
        "slug": "talk-about-load-blance-by-bilibili-crash-on-220713",
        "tags": [
          "Load Blance",
          "kubernetes"
        ],
        "summary": "前段时间看了B站发的20210713网站崩溃事件 的总结分析。小破站崩掉的具体原因已在文章做了详细的分析，就不在这里做详谈了，而是总结下文章多次提及了七层SLB、四层LB相关的 Load Balance 负载均衡知识点。",
        "title": "由B站210713崩溃事件聊聊负载均衡",
        "status": "Published",
        "urlname": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9",
        "updated": "2023-07-14 10:10:00"
      },
      "catalog": [
        {
          "title": "2022-10-30",
          "doc_id": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9"
        }
      ],
      "body": "",
      "realName": "由B站210713崩溃事件聊聊负载均衡",
      "relativePath": "/2022-10-30/由B站210713崩溃事件聊聊负载均衡.md"
    },
    {
      "id": "64eee45b-1c09-4042-99bb-97164e113a1d",
      "doc_id": "64eee45b-1c09-4042-99bb-97164e113a1d",
      "title": "64eee45b-1c09-4042-99bb-97164e113a1d",
      "updated": 1689229020000,
      "body_original": "\n### Git 工作流\n\n\n一个不错的工作流图示\n\n\n![](https://darkreunion-1256611153.file.myqcloud.com/img/gitworkflow.jpg)\n\n\n### 创建一个空分支\n\n\n```text\ngit checkout --orphan 分支名\n```\n\n\n### 删除远程分支和tag\n\n\n```text\ngit push origin :<branchName>\ngit push origin --delete <branchName>\ngit push origin --delete tag <tagname>\n```\n\n\n### 同步删除远程已被删除的分支\n\n\n```text\ngit fetch -p\n# 或者使用：\ngit remote prune origin\n```\n\n",
      "properties": {
        "date": "2018-08-23",
        "type": "Post",
        "category": "软件工具",
        "slug": "sometimes-useful-git-skill",
        "tags": [
          "Git"
        ],
        "title": "偶尔用得上的 Git 操作",
        "status": "Published",
        "urlname": "64eee45b-1c09-4042-99bb-97164e113a1d",
        "updated": "2023-07-13 14:17:00"
      },
      "catalog": [
        {
          "title": "2018-08-23",
          "doc_id": "64eee45b-1c09-4042-99bb-97164e113a1d"
        }
      ],
      "body": "",
      "realName": "偶尔用得上的 Git 操作",
      "relativePath": "/2018-08-23/偶尔用得上的 Git 操作.md"
    },
    {
      "id": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9",
      "doc_id": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9",
      "title": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9",
      "updated": 1689584880000,
      "body_original": "\n`hexo` 中有着丰富的主题可以选择, 大部分的使用示例或者教程都是将主题 clone 到 theme 文件夹中来使用. 但这样来使用主题会存在如下的问题:\n\n- theme 中的主题属于一个独立的 Git 项目, 有自己的 `.git` 项目文件夹, 提交 hexo 项目时默认不会提交 theme 的 `.git` 文件夹, 在其他电脑上 clone 后会失去 theme 原本的版本控制功能.\n- 使用自己修改的主题时, 每次更改完主题, 需要在主题文件夹中提交一次, 然后再在 hexo 项目根文件夹中提交一次, 会产生两次修改内容一样的提交, 不够优雅.\n\n还好万能的 Git 针对这种问题已经有了成熟的解决方案, 通过自带的 Git submodules 功能即可优雅的避免以上的问题.\n<!-- more -->\n\n\n## Git submodules 简介\n\n\nGit submodules 称之为 Git 子模块. 子模块允许你将一个 Git 仓库作为另一个 Git 仓库的子目录. 它可以让你将另一个仓库克隆到自己的项目中, 同时还保持提交的独立. 它非常适合我们程序员在项目管理时遇到的一种情况: 某个工作中的项目需要包含并使用另一个项目.  这些包含的项目也许是第三方库, 或者你独立开发的, 用于多个父项目的库. 你想要把它们当做两个独立的项目, 同时又想在一个项目中使用另一个.\n\n\n**在 hexo 中使用丰富的第三方主题的情况正非常符合这种情景**.\n\n\n## Git submodules 使用\n\n\n了解了 Git submodles 的使用场景后, 这么强力的工具如何在 hexo 中来使用呢. 在这里演示下我的用法.\n\n\n首先初始化一个用来演示的 hexo 项目:\n\n\n```text\nnpm install hexo-cli -g\nhexo init blog\ncd blog\nnpm install\nhexo server\n\n```\n\n\n执行以上操作后, 打开浏览器进入 [http://localhost:4000/](http://localhost:4000/) 便可以预览到初始化好的 hexo 页面. 在项目的 `theme` 文件夹中可以看到使用了默认的 `landscape` 主题. 在这个 hexo 项目中建立起 Git 版本管理.\n\n\n```text\ngit init\ngit commit -m 'initial project'\n\n```\n\n\n现在一个 hexo 本地仓库已经建立好了并将初始化的文件提交了进去.\n\n\n### 基础用法\n\n\n现在我们使用 Git submodules 的方式来选择一个第三方主题来替换原本的 `landscape` 主题. 这里选择我比较喜欢的的 [pure](https://github.com/cofess/hexo-theme-pure) 主题.\n\n\n```text\ngit submodule add <https://github.com/cofess/hexo-theme-pure> themes/pure\n\n```\n\n\ngit 便会将 `hexo-theme-pure` 主题作为一个项目子模块 clone 到 themes/pure 中. 同时 hexo 项目中会自动生成一个 `.gitmodules` 文件, 这个配置文件中保存了项目 URL 与已经拉取的本地目录之间的映射.\n\n\n**.gitmodules 文件内容**\n\n\n```text\n$ cat .gitmodules\n[submodule \"themes/pure\"]\n\tpath = themes/pure\n\turl = <https://github.com/cofess/hexo-theme-pure>\n\n```\n\n\n**git 目前状态**\n\n\n```text\n$ git status\nOn branch master\nChanges to be committed:\n  (use \"git reset HEAD <file>...\" to unstage)\n\n        new file:   .gitmodules\n        new file:   themes/pure\n\n```\n\n\n可以看到, 虽然 themes/pure 是工作目录中的一个子目录, 但 Git 还是会将它视作一个子模块. 当不在那个目录中时, Git 并不会跟踪它的内容, 而是将它看作该仓库中的一个特殊提交.\n\n\n主题 clone 好后, 按照主题的说明安装好需要的插件模块, 再执行 `hexo s`, 重新打开 [http://localhost:4000/](http://localhost:4000/) 便可以看到使用新主题的博客页面了.\n\n\n**提交新的 git 记录**\n\n\n```text\n$ rm -rf themes/landscape\n$ git commit -am 'added pure themes'\ncreate mode 100644 .gitmodules\ncreate mode 160000 themes/pure\n\n```\n\n\n删除旧的 `landscape` 主题, 使用 `git commit -am` 重新提交添加了 `pure` 主题的 hexo 项目, 可以看到 git 使用 160000 模式创建 themes/pure 记录. 这是 git 中的一种特殊模式, 它本质上意味着将一次提交记作一项目录记录, 而非将它记录成一个子目录或者一个文件.\n\n\n**拉取含子模块的修改**\n\n\n主题作为子模块添加到项目中后, 若主题作者有更新, 便可通过两种方法来拉取主题的更新内容.\n\n1. 进入`themes` 下主题目录, 执行 `git fetch` 和 `git merge origin/master` 来 merge 上游分支的修改\n2. 直接运行 `git submodule update --remote`, Git 将会自动进入子模块然后抓取并更新\n\n更新后重新提交一遍, 子模块新的跟踪信息便也会记录到仓库中.\n\n\n**拉取含子模块的项目**\n\n\n使用 `git clone` 命令默认不会拉取项目中的子模块, 在 clone 后的项目中可以通过运行两个命令:\n\n1. `git submodule init` 初始化本地配置文件\n2. `git submodule update` 从该项目中抓取所有数据并检出父项目中列出的合适的提交\n\n也可在 clone 使用 `git clone --recursive` 命令, git 就会自动初始化并更新仓库中的每一个子模块.\n\n\n### 高级使用\n\n\n通过子模块基础用法, 可以直接方便的跟踪管理一些的简单的主题. 但很多主题都存在一些自己的配置项目, 需要我们根据自己的需要来进行设置,  或者我们想要在主题的基础上自定义修改自己喜欢的主题,  这个时候就需要对主题进行修改并提交仓库以便在各处使用.\n\n\n不过对于主题仓库我们一般没有提交的权限, 不能提交到主题源仓库中. 此时可以通过 `fork` 功能, 在源主题上 fork 出自己项目, 从而在自己仓库中进行提交来跟踪修改.\n\n\n这里我在 pure 主题上 fork 出了一个自己的主题仓库 [my-hexo-theme-pure](https://github.com/wanghaoxi3000/my-hexo-theme-pure), 使用这个仓库按照之前的步骤替换原本的主题来作为子模块.\n\n\n**修改子模块**\n\n\n当运行 `git submodule update` 从子模块仓库中抓取修改时, Git 将会获得这些改动并更新子目录中的文件, 但是会将子仓库留在一个称作 `游离的 HEAD` 的状态. 这意味着没有本地工作分支(例如 \"master\")跟踪改动, 此时做的任何改动都不会被跟踪. 因此, 我们首先需要进入子模块目录然后检出一个分支.\n\n\n```text\n$ git checkout stable\nSwitched to branch 'stable'\n\n```\n\n\n若子分支仓库中有未同步的更新, 可通过 `git submodule update --remote --rebase` 来同步最新的内容. 之后便可以打开编辑器在子模块上工作修改代码了.\n\n\n**同步源主题的修改**\n\n\n主题作者发布了新的主题功能或者修复了Bug, 我们想同步到自己的自定义主题当中. 因为我们的自定义主题是从原主题中 fork 出来的, 可以通过 `git remote add source <https://github.com/cofess/hexo-theme-pure`> 命令将源主题仓库添加为子模块的 一个新的 `source` 仓库. 然后运行 `git fetch` 拉取修改后, 便可以通过 `git merge origin/master` 来同步源主题的更新了.\n\n\n**发布子模块的修改**\n\n\n子模块修改完成后, 我们便可以发布到仓库中, 以便在其他地方重新 clone 时可以使用最新的主题文件. 为了防止我们遗忘子模块的提交, 可以在 push 时通过 `git push --recurse-submodules=check` 命令,  如果任何提交的子模块改动没有推送那么 check 选项会直接使 push 操作失败.\n\n\n另外也可以使用 `git push --recurse-submodules=on-demand` git 会自动尝试推送变更的子项目.\n\n\n### 拓展用法\n\n\n以上介绍了使用子模块来管理 themes 的方法, 实际上在 hexo 中还可以使用 子模块来管理 hexo 的静态部署文件. 对于使用 github 托管静态页面等部署方式的用户而言, 通过 `hexo-deployer-git` 插件可以方便的自动化部署静态页面.\n\n\n**hexo-deployer-git 工作流程**\n\n\n`hexo-deployer-git` 部署的方式是在 hexo 项目根目录下创建了一个 `.deploy_git` 文件夹, 并在其中创建了一个独立的 git 分支, 将生成静态文件移入这个文件夹中并推送到指定的地址. 但 `.deploy_git` 文件夹默认也被写入 `.gitignore` 文件中, hexo 项目 git 库不会记录这个文件夹, 同时 `hexo-deployer-git` 在每次部署时也不会自动同步服务器上的提交历史, 而是强制覆盖旧的提交. 在新的电脑或路径上重新 clone 后也会出现旧的静态文件记录丢失的情况, 重新 deploy 后服务器上旧的部署历史也会丢失.\n\n\n如果想要保存每次的部署记录, 那么就可以将 `.deploy_git` 中的文件也看做一个子项目, 以子项目的形式提交到 hexo 主项目中保存, 就可以保持部署记录不丢失, 并且在任何地方重新 clone 时都可以恢复最新的记录.\n\n\n**添加 .deploy_git 中分支为子项目**\n\n\n`.deploy_git` 中是由部署插件在 hexo 项目上创建的一个独立分支, 只需通过传递 `-b` 选项将 hexo 项目的这个分支作为主项目的依赖即可, 例如部署在 `coding` 时, 使用的 `coding-pages` 分支:\n\n\n```text\ngit submodule add -b coding-pages <site>\n\n```\n\n\n## 参考资料\n\n\n> Pro Git book - 子模块 https://git-scm.com/book/zh/v2/Git-工具-子模块\n\n\n[FROM python:3.6-slim\nMAINTAINER whx3000 <wanghaoxi3000@163.com>\n\nRUN apt-get update && \\\n    apt-get install -y --no-install-recommends \\\n    cron && \\\n    rm -rf /var/lib/apt/lists/* && \\\n    apt-get clean\n\nRUN chmod +x ./docker-entrypoint.sh\n\nENV LC_ALL C.UTF-8\nENTRYPOINT [\"./docker-entrypoint.sh\"]\n](1730d212-9348-4c23-810f-78c8d6251503)\n\n",
      "properties": {
        "date": "2019-01-03",
        "type": "Post",
        "category": "软件工具",
        "slug": "manage-hexo-theme-with-git-submodules",
        "tags": [
          "Git"
        ],
        "summary": "hexo 中有着丰富的主题可以选择, 大部分的使用示例或者教程都是将主题 clone 到 theme 文件夹中来使用. 但这样来使用主题会存在如下的问题:\n- theme 中的主题属于一个独立的 Git 项目, 有自己的 .git 项目文件夹, 提交 hexo 项目时默认不会提交 theme 的 .git 文件夹, 在其他电脑上 clone 后会失去 theme 原本的版本控制功能.\n- 使用自己修改的主题时, 每次更改完主题, 需要在主题文件夹中提交一次, 然后再在 hexo 项目根文件夹中提交一次, 会产生两次修改内容一样的提交, 不够优雅.\n还好万能的 Git 针对这种问题已经有了成熟的解决方案, 通过自带的 Git submodules 功能即可优雅的避免以上的问题.",
        "title": "在 hexo 中使用 git submodules 管理主题",
        "status": "Published",
        "urlname": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9",
        "updated": "2023-07-17 17:08:00"
      },
      "catalog": [
        {
          "title": "2019-01-03",
          "doc_id": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9"
        }
      ],
      "body": "",
      "realName": "在 hexo 中使用 git submodules 管理主题",
      "relativePath": "/2019-01-03/在 hexo 中使用 git submodules 管理主题.md"
    },
    {
      "id": "88579025-d6b7-43ae-98bb-12b52f90bcd9",
      "doc_id": "88579025-d6b7-43ae-98bb-12b52f90bcd9",
      "title": "88579025-d6b7-43ae-98bb-12b52f90bcd9",
      "updated": 1689228840000,
      "body_original": "\n## 全能型 uWSGI 配置\n\n\n其实 uWSGI 也可以用来直接提供静态文件，虽然相比 nginx 效率要低一些，但部署时配置起来更为方便。只需在 uWSGI 的配置文件中添加 `static-map` 配置项。\n\n\n### uWSGI 配置静态文件挂载点\n\n\n通过 `--static-map mountpoint=path` 选项，uWSGI 即可将指定请求前缀映射到文件系统上的对应物理目录。\n\n\n```text\n--static-map /images=/var/www/img\n\n```\n\n\n通过以上配置，如接收到一个对 /images/logo.png 的请求，并且 /var/www/img/logo.png 存在，那么 uWSGI 将会提供它。否则，uWSGI 托管的应用会管理这个请求。\n\n\n### uWSGI 配置路由\n\n\nnginx 有时另外一个重要作用便是路由, uWSGI 在 1.9 版本后也提供了一个可编程的内部路由子系统，可以通过这个内部路由子系统来动态改变处理请求的方式。\n\n\n例如将所有的 `http` 链接转到 `https` 地址下：\n\n\n```text\nroute-uri = ^/$ redirect:<https://your.website.com>\n\n```\n\n\n### 完整配置\n\n\n通过以上的选项，一个小站便可仅通过 uWSGI 部署起来了，顺便也分享下我的站点配置。\n\n\n```text\n[uwsgi]\n; 特权端口只能通过 shared socket 来打开\nshared-socket = 0.0.0.0:80\nshared-socket = 0.0.0.0:443\n\n; 打开 https 强制转换, 安全协议设置为 HIGH\nhttp-to-https = =0\nhttps = =1,214391966620557.pem,214391966620557.key,HIGH\n\n; 在绑定端口后切换运行用户\nuid = ubuntu\ngid = ubuntu\n\n; 配置运行虚拟环境及程序路径\nvirtualenv = /home/ubuntu/.virtualenvs/web/\nchdir = /var/web/backend\nwsgi-file = backend/wsgi.py\nmaster = true\nprocesses = 2\nthreads = 4\ntouch-reload=/var/web/backend/mcenter.reload\n\n; 静态文件和路由配置\nstatic-map = /static=/var/web/backend/static\nroute-uri = ^/$ redirect:<https://your.website.com>\n\n; 开启状态监控\nstats = 127.0.0.1:9191\n\n\n```\n\n\n## 参考资料\n\n\n> 使用uWSGI提供静态文件 https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/StaticFiles.html  \n> uWSGI内部路由 https://uwsgi-docs-zh.readthedocs.io/zh_CN/latest/InternalRouting.html\n\n",
      "properties": {
        "date": "2019-01-13",
        "type": "Post",
        "category": "软件工具",
        "slug": "versatility-uwsgi-config",
        "tags": [
          "Python",
          "nginx"
        ],
        "summary": "在进行 Python web 开发时，使用 Django、Flask 等框架开发完毕后，部署时通常需要选择一个支持 wsgi 协议的 Web 服务器程序。目前比较通用的选择是 nginx + uWSGI，使用 nginx 来处理静态文件请求，其余动态内容再转发给 uWSGI 交给 web 后台处理，网上这样的配置教程也是最多的。作为两款大名鼎鼎的服务器程序 nginx 负责静态文件，uWSGI 负责动态内容，各种在自己擅长的领域各施其职，的确效率很高，是高性能的 Python web 系统部署时的首选。不过有时用 Python 写了个小站点，性能需求并不高时。部署服务还要安装 nginx 和 uWSGI 两个服务器程序就显得有点麻烦了。能否把这些工作都交给一个服务器程序呢。",
        "title": "全能型 uWSGI 配置",
        "status": "Published",
        "urlname": "88579025-d6b7-43ae-98bb-12b52f90bcd9",
        "updated": "2023-07-13 14:14:00"
      },
      "catalog": [
        {
          "title": "2019-01-13",
          "doc_id": "88579025-d6b7-43ae-98bb-12b52f90bcd9"
        }
      ],
      "body": "",
      "realName": "全能型 uWSGI 配置",
      "relativePath": "/2019-01-13/全能型 uWSGI 配置.md"
    },
    {
      "id": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230",
      "doc_id": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230",
      "title": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230",
      "updated": 1689228540000,
      "body_original": "\n程序猿除了希望写好代码，一定也想着自己的项目可以如何快速的迭代上线，从而可以专注的完成代码的编写，减少繁杂的运维等工作。例如完成一项功能的开发后，推送到 Git 等代码管理系统后，剩下的测试、部署、上线等工作可以交给一个系统来自动化完成，这时便可以靠持续集成系统了。这里记录下我使用老牌的 Jenkins 持续集成系统来帮助自己完成的工作。\n\n\n## 部署 Jenkins\n\n\n### 使用 docker 部署 Jenkins\n\n\nJenkins 已有官方的 docker 镜像，通过 docker 可以快速完成 jenkins 系统的部署。\n\n\n我使用的 Jenkins 部署命令:\n\n\n```text\ndocker run --name=jenkins -td -v jenkins_home:/var/jenkins_home -p 8080:8080 -p 50000:50000 -e JAVA_OPTS=-Duser.timezone=Asia/Shanghai jenkins/jenkins:lts\n\n```\n\n\n解释下各个运行选项\n\n- -name=jenkins 将容器命名为 jenkins\n- td 分配一个伪 tty 终端，在后台运行\n- v jenkins_home:/var/jenkins_home 将 jenkins_home 存储卷挂载到容器 /var/jenkins_home，这样在删除或升级容器后数据也可以存在\n- p 8080:8080 -p 50000:50000 将容器的 8080 和 50000 端口映射到主机对应端口上\n- e JAVA_OPTS=-Duser.timezone=Asia/Shanghai 配置环境变量 JAVA_OPTS=-Duser.timezone=Asia/Shanghai 这样在 Jenkins 中显示的时区才是中国地区的\n\n### nginx 反代设置\n\n\n由于我在自己的域名下使用了 nginx 反代 Jenkins 端口，这里再分享下我的 nginx 配置\n\n\n```text\nupstream jenkins {\n    server 127.0.0.1:8080 fail_timeout=0;\n}\n\nserver {\n    listen 80;\n    server_name your.site.com;\n    return 301 https://your.site.com$request_uri;\n}\n\nserver {\n    listen 443 ssl http2;\n    server_name your.site.com;\n\n    location / {\n      proxy_set_header        Host $host:$server_port;\n      proxy_set_header        X-Real-IP $remote_addr;\n      proxy_set_header        X-Forwarded-For $proxy_add_x_forwarded_for;\n      proxy_set_header        X-Forwarded-Proto $scheme;\n\n      # Fix the \"It appears that your reverse proxy set up is broken\" error.\n      proxy_pass          <http://jenkins>;\n      proxy_redirect      http:// https://;\n\n      # Required for new HTTP-based CLI\n      proxy_http_version 1.1;\n      proxy_request_buffering off;\n      # workaround for <https://issues.jenkins-ci.org/browse/JENKINS-45651>\n      add_header 'X-SSH-Endpoint' 'your.site.come:50022' always;\n    }\n}\n\n```\n\n\n### 初始化 Jenkins\n\n\n第一次安装 Jenkins 后，进入网页还需要配置下 Jenkins 的首次运行设置。基本上按默认的一直点下一步就可以了，网上教程也很多，有问题可以自行搜索。\n\n\n## 配置持续集成项目\n\n\nJenkins 搭建完毕后，这里就详细演示下的通过 Jenkins 来完成发布基于 hexo 的博客的一系列流程。\n\n\n### 为何需要 Jenkins\n\n\n我基于 hexo 搭建了一个博客，博客代码托管于 Github，生成的静态内容托管于 coding page，在没有 Jenkins 的情况下，常常为以下问题感觉不爽：\n\n1. 博客更新后推送到 Github 的速度总是很慢，没有使用国内代码托管平台那样的流程体验\n2. 每次想发布博客时，还需手动执行一下 `hexo deploy` 命令，我只想把最新的更新推送到 Git 上后就不再管了\n\n这时候 Jenkins 便派上用场了，以上这些都可以交给它来自动完成。整个发布流程如下：\n\n\n```text\ngraph TB;\n  start[准备发布] --> push[push 新提交到 coding];\n  push --> webhook[Jenkins 收到 coding 的更新通知];\n  webhook --> pull[Jenkins 拉取最新代码];\n  pull --> deploy[生成静态博客文件推送到 coding page];\n  deploy --> sync[将新的提交同步推送到 Github];\n  sync --> email[将发布结果发布到指定 email];\n\n```\n\n\n### 配置 Jenkins 持续集成任务\n\n\n### 安装插件\n\n\nJenkins 在安装时已附带了常用的插件，由于这需要接收 coding 的推送通知和生成 hexo 静态文件，因而需要 `Coding Webhook` 和 `NodeJS` 这两个插件。可以在 `Jenkins 首页 -> 系统管理 -> 插件管理` 中选择安装。\n\n\n### 配置 Jenkins\n\n\n为了让 Jenkins 有权限拉取和推送代码，需要为 Jenkins 生成一个拉取代码的 ssh 密钥，并添加到代码项目中。生成 ssh 密钥的方法很多，一般可以在 Liunx 系统通过\n\n\n```text\nssh-keygen -t rsa\n```\n\n\n来创建，创建好后添加到\n\n\n```text\n系统管理 -> 凭据 -> 系统 -> 全局凭据\n```\n\n\n中，使每个项目都可以使用。之后还需将公钥添加到对应的 Git 项目中。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317014543.png)\n\n\n为了可以编译 hexo 项目生成静态项目，还需要配置 NodeJS 插件生成 hexo 插件运行环境。可在\n\n\n```text\n系统管理 -> 全局工具配置\n```\n\n\nNodeJS 配置项中按如下配置添加 NodeJS 10.14.2 运行环境，并自动安装 hexo。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317014721.png)\n\n\n### 配置任务\n\n\n在完成一系列的准备工作后，可以创建执行具体流程的任务了。点击首页左侧的新任务，输入一个喜欢的任务名，选择构建一个自由风格的软件项目。在 General 选项页面，可以配置丢弃旧的构建节省空间。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317014941.png)\n\n\nSource Code Management 选项页面需要配置托管代码的 Git 地址，这里因为我们想配置 Jenkins 自动推送代码到 Github，因而需要配置两个地址。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317014758.png)\n\n\nBuild Triggers 选项页面需要配置何时触发这个项目，这里我们配置为通过 coding webhook 来触发。每次推送代码后，coding 便会通过一个 webhook 来通知 Jenkins 开始执行任务。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317122536.png)\n\n\n之后在 coding 项目的\n\n\n```text\n设置 -> webhook\n```\n\n\n页面配置好项目触发地址和条件。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317015050.png)\n\n\nBuild Environment 选项页面配置任务所需的环境，这里由于由于 hexo deploy 时需要 push 静态页面到 coding，也需要之前 git 仓库认证的密钥文件，可以勾选\n\n\n```text\nUse secret text(s) or file(s)\n```\n\n\n，将密钥文件提取出来以备接下来使用。同时在这里配置 nodeJS 运行环境，并且勾选了在控制台打印信息中添加时间戳以便调试。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317015119.png)\n\n\nBuild 选项页面配置任务需要执行的命令，这里配置好 hexo 生成静态页面和部署所需各项命令。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317015216.png)\n\n\nPost-build Actions 选项页面可配置任务执行前后需要执行的动作，这里我们便可以通过 Git Publisher 推送代码到 Github 中，并通过发送邮件告知任务执行结果。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317015240.png)\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20190317015309.png)\n\n\n## 后记\n\n\n活用好此类持续集成工具，可以帮助我们完成开发流程中的很多事，极大的提升我们的开发效率。除了老牌的 Jenkins，现在也有很多新型的工具或平台可以更方便的完成这些配置。比如 [DaoCloud](https://www.daocloud.io/)，[cds](https://github.com/ovh/cds)，[drone](https://drone.io/), [flowci](https://github.com/FlowCI/flow-platform) 等等，可以挑一个最顺手的好好研究。\n\n",
      "properties": {
        "date": "2019-03-17",
        "type": "Post",
        "category": "软件工具",
        "slug": "use-ci-system-to-free-time",
        "tags": [
          "CI",
          "Jenkins"
        ],
        "summary": "程序猿除了希望写好代码，一定也想着自己的项目可以如何快速的迭代上线，从而可以专注的完成代码的编写，减少繁杂的运维等工作。例如完成一项功能的开发后，推送到 Git 等代码管理系统后，剩下的测试、部署、上线等工作可以交给一个系统来自动化完成，这时便可以靠持续集成系统了。这里记录下我使用老牌的 Jenkins 持续集成系统来帮助自己完成的工作。",
        "title": "使用持续集成系统解放生产力",
        "status": "Published",
        "urlname": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230",
        "updated": "2023-07-13 14:09:00"
      },
      "catalog": [
        {
          "title": "2019-03-17",
          "doc_id": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230"
        }
      ],
      "body": "",
      "realName": "使用持续集成系统解放生产力",
      "relativePath": "/2019-03-17/使用持续集成系统解放生产力.md"
    },
    {
      "id": "adf14ce3-4a96-4009-b132-1786ae179cc0",
      "doc_id": "adf14ce3-4a96-4009-b132-1786ae179cc0",
      "title": "adf14ce3-4a96-4009-b132-1786ae179cc0",
      "updated": 1689072660000,
      "body_original": "\n为了有个k8s的测试环境，使用了三台ubuntu18的系统搭建了一套k8s测试环境，主要参考了[和我一步步部署 kubernetes 集群](https://github.com/opsnull/follow-me-install-kubernetes-cluster)这个项目，这个项目对于如何一步步搭建起k8s集群环境已经很详细了，不过对于ubuntu 18.04的环境还是有一些小坑，这里记录一下。\n\n\n### 主要环境版本\n\n- ubuntu 3节点：ubuntu18.04\n- kubernetes：v1.14.6\n- docker：18.09.9\n\n### 01.系统初始化和全局变量\n\n\n[安装依赖包](https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/01.%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.md#%E5%AE%89%E8%A3%85%E4%BE%9D%E8%B5%96%E5%8C%85)一节中，使用的安装命令会出现找不到`libseccomp`的错误，应该使用如下命令:\n\n\n```text\napt-get install -y conntrack ipvsadm ntp ipset jq iptables curl sysstat libseccomp2\n\n```\n\n\n[设置系统时区](https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/01.%E7%B3%BB%E7%BB%9F%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%85%A8%E5%B1%80%E5%8F%98%E9%87%8F.md#%E8%AE%BE%E7%BD%AE%E7%B3%BB%E7%BB%9F%E6%97%B6%E5%8C%BA)一节中，ubuntu18重启cron服务的命令为:\n\n\n```text\nsystemctl restart cron\n\n```\n\n\n### 09-1.部署 coredns 插件\n\n\n[部署 coredns 插件](https://github.com/opsnull/follow-me-install-kubernetes-cluster/blob/master/09-1.dns%E6%8F%92%E4%BB%B6.md)这一节在ubuntu18.04系统上部署coredns插件后，会出现coredns无法启动，报告CrashLoopBackOff的问题\n\n\n```text\nroot@ubuntu101:/opt/k8s/work/kubernetes/cluster/addons/dns/coredns# kubectl get all --all-namespaces\nNAMESPACE     NAME                          READY   STATUS             RESTARTS   AGE\nkube-system   pod/coredns-8b77fdfb9-76zj8   0/1     CrashLoopBackOff   7          15m\nzai\nNAMESPACE     NAME                 TYPE        CLUSTER-IP   EXTERNAL-IP   PORT(S)                  AGE\ndefault       service/\nkubernetes   ClusterIP   10.254.0.1   <none>        443/TCP                  7h14m\nkube-system   service/kube-dns     ClusterIP   10.254.0.2   <none>        53/UDP,53/TCP,9153/TCP   15m\n\nNAMESPACE     NAME                      READY   UP-TO-DATE   AVAILABLE   AGE\nkube-system   deployment.apps/coredns   0/1     1            0           15m\n\nNAMESPACE     NAME                                DESIRED   CURRENT   READY   AGE\nkube-system   replicaset.apps/coredns-8b77fdfb9   1         1         0       15m\n\n```\n\n\n通过查看日志，可以观察到coredns启动中出现了`Loop (127.0.0.1:51377 -> :53) detected for zone \".\"`的问题:\n\n\n```text\nroot@ubuntu101:/opt/k8s/work/kubernetes/cluster/addons/dns/coredns# kubectl logs coredns-8b77fdfb9-76zj8 -n kube-system\n.:53\n2019-09-06T14:02:03.164Z [INFO] CoreDNS-1.3.1\n2019-09-06T14:02:03.164Z [INFO] linux/amd64, go1.11.4, 6b56a9c\nCoreDNS-1.3.1\nlinux/amd64, go1.11.4, 6b56a9c\n2019-09-06T14:02:03.164Z [INFO] plugin/reload: Running configuration MD5 = 983e0715b6345402acc1b47b2543ece7\n2019-09-06T14:02:03.164Z [FAT\nAL] plugin/loop: Loop (127.0.0.1:51377 -> :53) detected for zone \".\", see <https://coredns.io/plugins/loop#troubleshooting>. Query: \"HINFO 9014994000123808639.4964161867797590684.\"\n\n```\n\n\n这应该是DNS服务检查到了一个循环查询的问题，解决方法是在`/etc/systemd/system/kubelet.service`中启动kubelet的命令后添加上`--resolv-conf=/run/systemd/resolve/resolv.conf`参数：\n\n\n```text\n[Unit]\nDescription=Kubernetes Kubelet\nDocumentation=https://github.com/GoogleCloudPlatform/kubernetes\nAfter=docker.service\nRequires=docker.service\n\n[Service]\nWorkingDirectory=/data/k8s/k8s/kubelet\nExecStart=/opt/k8s/bin/kubelet \\\\\n  --allow-privileged=true \\\\\n  --bootstrap-kubeconfig=/etc/kubernetes/kubelet-bootstrap.kubeconfig \\\\\n  --cert-dir=/etc/kubernetes/cert \\\\\n  --cni-conf-dir=/etc/cni/net.d \\\\\n  --container-runtime=docker \\\\\n  --container-runtime-endpoint=unix:///var/run/dockershim.sock \\\\\n  --root-dir=/data/k8s/k8s/kubelet \\\\\n  --kubeconfig=/etc/kubernetes/kubelet.kubeconfig \\\\\n  --config=/etc/kubernetes/kubelet-config.yaml \\\\\n  --hostname-override=ubuntu101 \\\\\n  --pod-infra-container-image=registry.cn-beijing.aliyuncs.com/images_k8s/pause-amd64:3.1 \\\\\n  --image-pull-progress-deadline=15m \\\\\n  --volume-plugin-dir=/data/k8s/k8s/kubelet/kubelet-plugins/volume/exec/ \\\\\n  --logtostderr=true \\\\\n  --resolv-conf=/run/systemd/resolve/resolv.conf \\\\\n  --v=2\n\nRestart=always\nRestartSec=5\nStartLimitInterval=0\n\n[Install]\nWantedBy=multi-user.target\n\n```\n\n\n**参考：**\n\n- [https://stackoverflow.com/questions/53075796/coredns-pods-have-crashloopbackoff-or-error-state/53414041#53414041](https://stackoverflow.com/questions/53075796/coredns-pods-have-crashloopbackoff-or-error-state/53414041#53414041)\n- [https://github.com/kubernetes/minikube/issues/3511](https://github.com/kubernetes/minikube/issues/3511)\n- [https://coredns.io/plugins/loop/#troubleshooting](https://coredns.io/plugins/loop/#troubleshooting)\n",
      "properties": {
        "date": "2019-09-09",
        "type": "Post",
        "category": "软件工具",
        "slug": "deploy-kubernetes-on-ubuntu18",
        "tags": [
          "kubernetes"
        ],
        "summary": "为了有个k8s的测试环境，使用了三台ubuntu18的系统搭建了一套k8s测试环境，主要参考了和我一步步部署 kubernetes 集群这个项目，这个项目对于如何一步步搭建起k8s集群环境已经很详细了，不过对于ubuntu 18.04的环境还是有一些小坑，这里记录一下。",
        "title": "在ubuntu18.04上部署kubernetes",
        "status": "Published",
        "urlname": "adf14ce3-4a96-4009-b132-1786ae179cc0",
        "updated": "2023-07-11 18:51:00"
      },
      "catalog": [
        {
          "title": "2019-09-09",
          "doc_id": "adf14ce3-4a96-4009-b132-1786ae179cc0"
        }
      ],
      "body": "",
      "realName": "在ubuntu18.04上部署kubernetes",
      "relativePath": "/2019-09-09/在ubuntu18.04上部署kubernetes.md"
    },
    {
      "id": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0",
      "doc_id": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0",
      "title": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0",
      "updated": 1689228600000,
      "body_original": "\n[coding](https://coding.net/) 提供了一套免费的静态页面服务，还可以自定义域名，本人的 airaNg 服务页面也是部署在coding的静态页面服务当中。不过 [ariaNg](https://ariang.mayswind.net/) 还会不断更新，如何在 ariaNg 原项目版本升级后自动更新自己部署的在 coding 的页面呢，这里利用 coding 自带的持续集成功能来完成这种自定义的操作。\n\n\n_目前coding的静态页面服务已进行了修改，使用腾讯云的 oss 和 cdn 来部署了，虽然速度和稳定性有了提升，但可能也会产生费用。_\n\n\n<!-- more -->\n\n\n## 工作流程\n\n\n主要的原理是通过在coding中创建一个项目，并为这个项目启动两个持续集成任务，一个是定时同步Github上原项目的更改，另外一个是接收到代码的更新后，触发持续集成下载代码代码包，部署到项目静态页面。\n\n\n## 持续集成任务配置\n\n\n因为涉及到在持续集成任务中推送代码，需要在coding的个人配置页面先申请一个token。部署完成后，使用了[server酱](http://sc.ftqq.com/3.version)来推送结果。\n\n\n### 定时同步任务\n\n\n需要配置的环境变量\n\n- GITHUB_REPO AriaNg代码库原地址：[https://github.com/mayswind/AriaNg.git](https://github.com/mayswind/AriaNg.git)\n- TOKEN_NAME Coding token name\n- TOKEN_VALUE Coding token value\n- PUSH_TOKEN Server 酱推送 token\n\nJenkins 流程定义\n\n\n```text\npipeline {\n  agent any\n  stages {\n    stage('clone github') {\n      steps {\n        sh 'git clone $GITHUB_REPO'\n      }\n    }\n    stage('update repo') {\n      steps {\n        sh '''cd AriaNg\n\ngit config --global user.name \"devOps\"\ngit config --global user.email \"devOps@coding.net\"\ngit remote add coding \"<https://${TOKEN_NAME}:${TOKEN_VALUE}@e.coding.net/username/ariaNg.git>\"\ngit push --tags coding master:main'''\n      }\n    }\n  }\n  post {\n    unsuccessful {\n      sh 'curl -s -d \"text=项目 ${PROJECT_NAME}: ${CCI_JOB_NAME} 构建失败\" <https://sc.ftqq.com/${PUSH_TOKEN}.send>'\n\n    }\n\n  }\n}\n\n```\n\n\n### 页面发布任务\n\n\n需要配置的环境变量\n\n- TOKEN_NAME Coding token name\n- TOKEN_VALUE Coding token value\n- PUSH_TOKEN Server 酱推送 token\n\nJenkins 流程定义\n\n\n```text\npipeline {\n  agent any\n  stages {\n    stage('检出') {\n      steps {\n        checkout([\n          $class: 'GitSCM',\n          branches: [[name: GIT_BUILD_REF]],\n          userRemoteConfigs: [[\n            url: GIT_REPO_URL,\n            credentialsId: CREDENTIALS_ID\n          ]]])\n        }\n      }\n      stage('发布') {\n        steps {\n          sh '''REC_TAG=$(git describe --tags `git rev-list --tags --max-count=1`)\nDIST_FILE=AriaNg-${REC_TAG}.zip\necho \"Current code tag: ${REC_TAG}\"\n\ngit checkout master\nrm -rf $(ls)\n\nwget <https://github.com/mayswind/AriaNg/releases/download/${REC_TAG}/${DIST_FILE}>\nunzip ${DIST_FILE}\nrm ${DIST_FILE}\n\ngit add -A\ngit commit --amend -m \"Updated By devOps With Build ${REC_TAG}\"\ngit push --force --quiet \"<https://${TOKEN_NAME}:${TOKEN_VALUE}@e.coding.net/username/ariaNg.git>\" master:master\n\ncurl -s -d \"text=项目 ${PROJECT_NAME}: ${CCI_JOB_NAME} ${REC_TAG} 构建成功\" <https://sc.ftqq.com/${PUSH_TOKEN}.send>'''\n        }\n      }\n    }\n    post {\n      unsuccessful {\n        sh 'curl -s -d \"text=项目 ${PROJECT_NAME}: ${CCI_JOB_NAME} 构建失败\" <https://sc.ftqq.com/${PUSH_TOKEN}.send>'\n\n      }\n\n    }\n  }\n\n```\n\n",
      "properties": {
        "date": "2020-12-08",
        "type": "Post",
        "category": "软件工具",
        "slug": "sync-github-project-and-publish-on-coding",
        "tags": [
          "github",
          "coding",
          "devOps"
        ],
        "summary": "coding 提供了一套免费的静态页面服务，还可以自定义域名，本人的 airaNg 服务页面也是部署在coding的静态页面服务当中。不过 ariaNg 还会不断更新，如何在 ariaNg 原项目版本升级后自动更新自己部署的在 coding 的页面呢，这里利用 coding 自带的持续集成功能来完成这种自定义的操作。\n目前coding的静态页面服务已进行了修改，使用腾讯云的 oss 和 cdn 来部署了，虽然速度和稳定性有了提升，但可能也会产生费用。",
        "title": "使用coding自动同步和部署Github项目",
        "status": "Published",
        "urlname": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0",
        "updated": "2023-07-13 14:10:00"
      },
      "catalog": [
        {
          "title": "2020-12-08",
          "doc_id": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0"
        }
      ],
      "body": "",
      "realName": "使用coding自动同步和部署Github项目",
      "relativePath": "/2020-12-08/使用coding自动同步和部署Github项目.md"
    },
    {
      "id": "854d17ad-00a6-4105-8292-ca67eea97d21",
      "doc_id": "854d17ad-00a6-4105-8292-ca67eea97d21",
      "title": "854d17ad-00a6-4105-8292-ca67eea97d21",
      "updated": 1689301260000,
      "body_original": "\n入手了一台 MacBook Air m2, 开始进入 MAC 的生态, 不过刚装好常用的开发环境, 在编译一个 golang 项目时就出现了一个问题:\n\n\n```text\nruntime/cgo\n_cgo_export.c:3:10: fatal error: 'stdlib.h' file not found\n```\n\n\n看起来是由于这个 golang 项目中使用到了 cgo 的库, 但是编译时没有找到对应的头文件导致了这个问题.\n\n\n## 尝试过的方法\n\n\n首先在网上搜索了一番, 大部分的解决方案是这些:\n\n1. `xcode-select install` 通过此命令安装开发者工具\n2. `ln -s /Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk/usr/include /usr/include/c++/v1` 添加软链接\n\n不过这些方案在我的环境上都不可行, 我已经安装过了 xcode, 并且执行过 xcode-select install, 修改软链接的方式由于 Mac 的限制, 调整起来会很麻烦. 直到了 stackoverflow 的这篇回答提供了一个方便的解决方法.\n\n\n## 解决方案\n\n\n原文地址: [https://stackoverflow.com/a/61526989/596599](https://stackoverflow.com/a/61526989/596599)\n\n\n简单的说, 出现这个问题的原因在于默认的编译器使用的是 XCode SDK 中的, 需要调整为 CommandLineTools SDK. 命令如下:\n\n\n```text\n#Check the current sdk\nxcrun --show-sdk-path\n\n#Change sdk\nsudo xcode-select -s /Library/Developer/CommandLineTools          #Using CommandLineTools SDK\nsudo xcode-select -s /Applications/Xcode.app/Contents/Developer   #Using XCode.app SDK\n\n```\n\n",
      "properties": {
        "date": "2022-09-13",
        "type": "Post",
        "category": "软件工具",
        "slug": "clang-header-file-not-fuound-under-mac",
        "tags": [
          "mac"
        ],
        "summary": "入手了一台 MacBook Air m2, 开始进入 MAC 的生态, 不过刚装好常用的开发环境, 在编译一个 golang 项目时就出现了一个找不到头文件的问题.",
        "title": "mac 系统找不到 clang 头文件",
        "status": "Published",
        "urlname": "854d17ad-00a6-4105-8292-ca67eea97d21",
        "updated": "2023-07-14 10:21:00"
      },
      "catalog": [
        {
          "title": "2022-09-13",
          "doc_id": "854d17ad-00a6-4105-8292-ca67eea97d21"
        }
      ],
      "body": "",
      "realName": "mac 系统找不到 clang 头文件",
      "relativePath": "/2022-09-13/mac 系统找不到 clang 头文件.md"
    },
    {
      "id": "c370350a-d366-45a1-b383-b5056de0e7b0",
      "doc_id": "c370350a-d366-45a1-b383-b5056de0e7b0",
      "title": "c370350a-d366-45a1-b383-b5056de0e7b0",
      "updated": 1689700260000,
      "body_original": "\n几年前刚搭建了黑群晖时，在群晖的 docker 中跑了一个网友改造的 aria2 下载器，包含了一个已经配置好的 aria2 内核和一个 AriaNG 控制页面。之后应该是一次也没更新过，如今这个 aria2 下载器下载BT种子的话已经基本没有任何速度。AriaNG 页面也落后了很多个版本了。想着更新一下，因此发现了这个项目：[Aria2-Pro-Docker](https://github.com/P3TERX/Aria2-Pro-Docker) 。\n\n\n## 简介\n\n\n简单摘录下 Aria2 Pro 的介绍\n\n\n> 很多人在初次使用 Aria2 时会遇到 BT 下载无速度、文件残留占用空间、任务丢失等问题，所以会觉得 Aria2 并不好用，但事实并非如此。[Aria2 完美配置](https://p3terx.com/go/aHR0cHM6Ly9naXRodWIuY29tL1AzVEVSWC9hcmlhMi5jb25m)是博主经过长时间使用和研究官方文档后总结出来的一套配置方案，其最初目的是为了解决这些问题，而且为 Aria2 添加了额外的一些功能，经过一年多时间的打磨已经积累了大量的使用者和良好的口碑，其中不乏一些知名开源项目开发者、影视字幕组、科技视频 UP 主。之前一直使用[一键脚本](https://p3terx.com/go/aHR0cHM6Ly9naXRodWIuY29tL1AzVEVSWC9hcmlhMi5zaA)作为部署方案，为了满足小伙伴们使用 Docker 部署的需求，博主特意制作了基于 Aria2 完美配置和特殊定制优化的 Aria2 Docker\n\n\n有关 Aria2 Pro 的详细介绍可以参看作者的说明页面： \n\n\n[bookmark](https://p3terx.com/archives/docker-aria2-pro.html)\n\n\n## 部署\n\n\n按照作者的文档，部署的步骤也是比较简单的，Docker 或者 Docker compose 的方式可以直接参考作者的文档，这次我是部署到了家中的 K8S 来统一管理。主要配置了这些参数:\n\n- 环境变量\n\t- RPC_SECRET: RPC连接秘钥\n\t- RPC_PORT: RPC 端口，默认为6800\n\t- LISTEN_PORT:  BT 监听端口（TCP）、DHT 监听端口（UDP），默认为6888\n\t- DISK_CACHE: 磁盘缓存设置，默认值64M。建议在有足够的内存空闲情况下设置为适当增加大小，以减少磁盘 I/O ，提升读写性能，延长硬盘寿命。我的环境中改为了256M。\n- 暴露端口\n\t- TCP\n\t\t- 6800 RPC 连接端口\n\t\t- 6888  BT 监听端口\n\t- UDP\n\t\t- 6888 DHT 监听端口\n\t- 存储\n\t\t- /config 配置路径\n\t\t- /downloads 下载路径\n\n存储挂载的数据卷使用了 NFS 来挂载群晖上的磁盘\n\n\n```yaml\nvolumeMounts:\n- mountPath: /config\n  name: volume-nfs\n  subPath: aria2/config\n- mountPath: /downloads\n  name: volume-nfs\n\tsubPath: aria2/downloads\n\nvolumes:\n  - name: volume-nfs\n    nfs:\n      path: /volume2/k8s\n      server: server ip\n```\n\n\n## 使用\n\n\nAria2 Pro 只包含了 aria2 内核，没有控制页面，我一般使用的是 [AriaNg](https://github.com/mayswind/AriaNg)，可以自行搭建，也可以使用作者的 Demo 页面：[http://ariang.mayswind.net/latest](http://ariang.mayswind.net/latest)\n\n\nAria2 Pro 也提供了两个可以直接使用的页面：\n\n\n| 链接                                                                        | 备注                                                                                                                                                                                                                              |\n| ------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |\n| [http://ariang.js.org](https://p3terx.com/go/aHR0cDovL2FyaWFuZy5qcy5vcmc) | [js.org](https://p3terx.com/go/aHR0cHM6Ly9qcy5vcmcv) 提供域名，[GitHub Pages](https://p3terx.com/go/aHR0cHM6Ly9wYWdlcy5naXRodWIuY29tLw) 提供网页服务                                                                                       |\n| [http://ariang.eu.org](https://p3terx.com/go/aHR0cDovL2FyaWFuZy5ldS5vcmc) | [eu.org](https://p3terx.com/go/aHR0cHM6Ly9uaWMuZXUub3JnLw) 提供域名，[GitHub Pages](https://p3terx.com/go/aHR0cHM6Ly9wYWdlcy5naXRodWIuY29tLw) 提供网页服务，[Cloudflare](https://p3terx.com/go/aHR0cHM6Ly93d3cuY2xvdWRmbGFyZS5jb20v) 提供 CDN |\n\n\n任选一个，启用了 https 的话可以方法以上两个链接的 https 页面，配置上服务器地址和密钥，即可正常使用了。试了下一些常用资源，速度都还不错，准备作为我新的日常下载工具啦。\n\n",
      "properties": {
        "date": "2023-07-11",
        "type": "Post",
        "category": "软件工具",
        "slug": "deploy-download-tool-aria2-pro",
        "tags": [
          "aria2"
        ],
        "summary": "几年前刚搭建了黑群晖时，在群晖的 docker 中跑了一个网友改造的 aria2 下载器，包含了一个已经配置好的 aria2 内核和一个 AriaNG 控制页面。之后应该是一次也没更新过，如今这个 aria2 下载器下载BT种子的话已经基本没有任何速度。AriaNG 页面也落后了很多个版本了。想着更新一下，因此发现了这个项目：Aria2-Pro-Docker 。",
        "title": "部署下载神器 Aria2 Pro",
        "status": "Published",
        "urlname": "c370350a-d366-45a1-b383-b5056de0e7b0",
        "updated": "2023-07-19 01:11:00"
      },
      "catalog": [
        {
          "title": "2023-07-11",
          "doc_id": "c370350a-d366-45a1-b383-b5056de0e7b0"
        }
      ],
      "body": "",
      "realName": "部署下载神器 Aria2 Pro",
      "relativePath": "/2023-07-11/部署下载神器 Aria2 Pro.md"
    },
    {
      "id": "e346dc18-cd99-4f15-8182-fc9ede484429",
      "doc_id": "e346dc18-cd99-4f15-8182-fc9ede484429",
      "title": "e346dc18-cd99-4f15-8182-fc9ede484429",
      "updated": 1688554920000,
      "body_original": "\n## 骑上心爱的小电驴\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/202304100031508.webp)\n\n\n有了小电驴后，这几周都有骑着出去兜兜风，发现了很多不知名的小角落，让自己对这座本以为很熟悉城市多了一些新鲜感。例如此图自于骑着电驴从公司回家的路程中，看到了路边的一座小游乐园，相比于单调的地铁，让这趟行程有趣了许多。\n\n\n## 本周见闻\n\n\n### 为chatGPT打工\n\n\n推上一哥们突发奇想，让chatGPT做老板，自己给它打工，100刀启动资金，目前已经收获将近10w粉丝，7000多刀打赏。\n\n\n这思路真是打开了，也想尝试下让chatGPT做我的老板，告诉他我们有1W的启动资金，让他给我给我指派任务来赚钱，看看他会有什么点子，最后能不能盈利。\n\n\n[https://t.me/https1024/11112](https://t.me/https1024/11112)\n\n\n### GPT 帮你写git commit\n\n\n一款基于GPT来帮忙写git commit的工具，可以自动生成本次提交的更新内容，又一款AI带来的懒人神器，不过貌似还只支持英文，生成的内容个人感觉也还比较呆板，需要进一步打磨。\n\n\n[https://github.com/zurawiki/gptcommit](https://github.com/zurawiki/gptcommit)\n\n\n### WakaTime：记录每天编程时间的插件\n\n\n一款记录每天编程时间的插件，支持自行私有部署，可以方便分析下自己的编码状态和效率。\n\n\n[https://wakatime.com/](https://wakatime.com/)\n\n\n来源：[第122期 - 赤道夜景](https://weekly.tw93.fun/posts/122-%E8%B5%A4%E9%81%93%E5%A4%9C%E6%99%AF/)\n\n\n### MidJourney 知识库\n\n\n最近MidJourney 生成了很多挺出圈的AI图像，比如川普被捕系列，火的一塌糊涂。作为一个不会画图的码农，偶尔有什么奇思妙想也想让AI来帮忙用图像表达一下。看到了这个介绍MidJourney 的知识库，从注册到使用教程还有高阶技巧应有尽有，值得收藏。\n\n\n[https://tob-design.yuque.com/kxcufk/mj](https://tob-design.yuque.com/kxcufk/mj)\n\n\n来源：[龙爪槐守望者](https://www.ftium4.com/ux-weekly-137.html)\n\n\n## 后续计划\n\n\n连续写了几期一周随笔，记录下这一周最想公开的图片和日常的科技见闻，感觉挺有意义。虽然偶尔也有各种琐事耽误没有来得及写，比如这周的随笔离上一篇隔了两周🤣，但还是想坚持下去，每个周末有时间就来回味下这周的各种碎片。AI时代来了，感觉除了专业技能，个人见解的表达也会越来越重要，这是AI所替代不了的。顺手注册了个个人公众号，准备后续把随笔同步发布到公众号上，世界很大，虽然是个人的自言自语，还是希望有更多人看到和交流吧。\n\n",
      "properties": {
        "date": "2023-04-09",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230409",
        "tags": [
          "chatGPT",
          "MidJourney",
          "WakaTime"
        ],
        "summary": "有了小电驴后，这几周都有骑着出去兜兜风，发现了很多不知名的小角落，让自己对这座本以为很熟悉城市多了一些新鲜感。例如此图自于骑着电驴从公司回家的路程中，看到了路边的一座小游乐园，相比于单调的地铁，让这趟行程有趣了许多。",
        "title": "一周随笔20230409",
        "status": "Published",
        "urlname": "e346dc18-cd99-4f15-8182-fc9ede484429",
        "updated": "2023-07-05 19:02:00"
      },
      "catalog": [
        {
          "title": "2023-04-09",
          "doc_id": "e346dc18-cd99-4f15-8182-fc9ede484429"
        }
      ],
      "body": "",
      "realName": "一周随笔20230409",
      "relativePath": "/2023-04-09/一周随笔20230409.md"
    },
    {
      "id": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694",
      "doc_id": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694",
      "title": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694",
      "updated": 1691748300000,
      "body_original": "\n## 文章迁移\n\n\n`hexo` 和 `hugo` 的文章目录布局还是有所区别的，为了快速迁移以往的文章，写了一个 Python 脚本来完成这个步骤，代码如下：\n\n\n```text\nfrom datetime import date, datetime\nimport os\nimport re\nimport yaml\n\n\nCONTENT_DIR = 'content'\n\nfiles = os.listdir(\"_posts\")\n\nm = re.compile(r'---(.*)---', re.S)\n\nfor i in files:\n    print(i)\n    with open(\"_posts/\" + i, \"r\") as f:\n        content = f.read()\n        f.seek(0)\n        new_content = f.readlines()\n\n    r = m.search(content)\n    info = r.group(1)\n    length = len(info.split('\\\\n'))\n\n    data = yaml.safe_load(info)\n    new_content.insert(length-1, 'slug: ' + i + '\\\\n')\n\n    file_path = os.path.join(CONTENT_DIR, data['categories'][0], data['date'].strftime('%y%m%d') + '-' + data['title'])\n    os.makedirs(file_path, exist_ok=True)\n\n    with open(os.path.join(file_path, 'index.md'), 'w') as f:\n        f.write(''.join(new_content))\n\n\n```\n\n\n## 建立新分支\n\n\n由于代码的变化很大，在原来的博客代码库[darklab-blog](https://github.com/wanghaoxi3000/darklab-blog)，使用 `git checkout --orphan main` 新建了一个 空白的 main 分支，这样可以从零开始提交，和原来的分支独立，顺便也把主分支切换为和 main，和新的 Github 规范保持一致。\n\n\n## 评论系统\n\n\n以前 Hexo 使用的是 [valine](https://github.com/xCss/Valine) 系统，这次换到了 [giscus](https://giscus.app/) 系统，基于 GitHub Discussions 系统，感觉可以更轻量，维护成本可以更低。由于使用的主题已经添加了对应的支持，在 giscus 的网站页面按照步骤配置一遍后，将生成的ID添加到 config.yaml 配置中即可。\n\n\n## 数据统计\n\n\n基于百度统计或谷歌统计，可以查看到网站的访问数据，对于持续的迭代和改进还是有一定帮助。\n\n\n### Google\n\n\n在 [https://search.google.com/search-console](https://search.google.com/search-console) 即可获取网站的分析数据，查看数据需要对网站的所有权进行验证。谷歌统计支持通过 DNS 对网站所有权进行验证，在域名提供商配置一个对应的 TXT 解析即可查看到数据。\n\n\n### Baidu\n\n\n百度统计的网站是 [https://tongji.baidu.com/，添加百度统计需要在网站的页面加入指定的代码，hugo](https://tongji.baidu.com/%EF%BC%8C%E6%B7%BB%E5%8A%A0%E7%99%BE%E5%BA%A6%E7%BB%9F%E8%AE%A1%E9%9C%80%E8%A6%81%E5%9C%A8%E7%BD%91%E7%AB%99%E7%9A%84%E9%A1%B5%E9%9D%A2%E5%8A%A0%E5%85%A5%E6%8C%87%E5%AE%9A%E7%9A%84%E4%BB%A3%E7%A0%81%EF%BC%8Chugo) stack 主题支持自定义页面头部和底部的内容，新增 layouts\\partials\\footer\\custom.html 文件，加入百度统计的代码即可。\n\n\n## Github Action\n\n\n通过 Github Action，可以在向博客代码仓库推送代码更新后，自动更新网站。本博客的 Github Action 主要做了这几件事：\n\n1. 拉取代码\n2. 安装 Hugo\n3. 生成静态页面\n4. 上传到 COS 对象存储\n5. 刷新 CDN\n\n代码如下：\n\n\n```text\nname: Deploy Blog\n\non:\n  push:\n    branches: [ \"main\" ]\n\njobs:\n  build:\n    runs-on: ubuntu-latest\n\n    steps:\n      - name: Checkout\n        uses: actions/checkout@v3\n        with:\n          submodules: true # Checkout private submodules(themes or something else).\n\n      - name: Hugo setup\n        uses: peaceiris/actions-hugo@v2.4.13\n        with:\n          hugo-version: latest\n          extended: true\n\n      - name: Run hugo build\n        run: hugo\n\n      - name: Upload website\n        uses: saltbo/uptoc@v1.4.3\n        with:\n          driver: cos\n          region: ap-hongkong\n          bucket: ${{ secrets.TCLOUD_BUCKET_ID }}\n          exclude: .cache,test\n          dist: public\n        env:\n          UPTOC_UPLOADER_AK: ${{ secrets.TCLOUD_SECRET_ID }}\n          UPTOC_UPLOADER_SK: ${{ secrets.TCLOUD_SECRET_KEY }}\n\n      - name: Refresh CDN\n        env:\n          TENCENTCLOUD_SECRET_ID: ${{ secrets.TCLOUD_SECRET_ID }}\n          TENCENTCLOUD_SECRET_KEY: ${{ secrets.TCLOUD_SECRET_KEY }}\n        run: |\n          pip install tccli\n          tccli cdn PurgePathCache --cli-unfold-argument --Paths <https://darkreunion.tech/> --FlushType flush\n\n```\n\n",
      "properties": {
        "date": "2022-07-23",
        "type": "Post",
        "category": "博客记录",
        "slug": "blog-decorate-record",
        "tags": [],
        "summary": "选定博客生成系统往往只是打造自己博客的第一步，这里记录了本博客从 hexo 迁移到 hugo 后，后续的功能集成步骤。",
        "title": "博客装修记",
        "status": "Published",
        "urlname": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694",
        "updated": "2023-08-11 18:05:00"
      },
      "catalog": [
        {
          "title": "2022-07-23",
          "doc_id": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694"
        }
      ],
      "body": "",
      "realName": "博客装修记",
      "relativePath": "/2022-07-23/博客装修记.md"
    },
    {
      "id": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee",
      "doc_id": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee",
      "title": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee",
      "updated": 1688980320000,
      "body_original": "\n## 理想的Blog系统\n\n\n又是很久一段时间没有来写博客了，虽说平常的工作繁忙是一个原因，不过我平时笔记这些还是记得不算少，为什么这些记录没有转化为博客内容呢。我总结了一些原因：\n\n- 笔记的内容较为碎片，要输出为博客的话，还需要进一步的整理，懒得整理就只能躺在笔记中了\n- 虽然已经折腾了好几次，但我还是对目前博客的主题不咋满意，激发不了我写博客的动力，想改造下又觉得太麻烦（主要还是前端技术栈不过关）\n- 近年来我开始使用notion这一类云笔记应用，目前使用了[wolai](https://www.wolai.com/)这一款国内的相似应用，想记点什么了只需要打开网页即可记录，所见即所得，非常方便，但我想发布一篇博客的话，以我目前使用的hugo为例，在一台新电脑上发布文章需要有这些步骤：\n\t- git clone 我的博客\n\t- 使用一款文本编辑器（我主要用vscode）编写文章\n\t- 编写完成后，若想本地预览，本地也需要安装hugo程序，这一步可选\n\t- 发布文章，等待GitHub Action执行完成，推送到服务器并刷新CDN，估计一刻钟左右后，可以在网站上看到新发布的文章\n\n总之，想发布一篇博文的流程还是太麻烦了，很消磨想表达的热情，我的博客基本就是平常笔记的记录，作为笔记那么就会有疏忽，错误，以及想要补充的点。 理想中的博客系统我希望可以有这些：\n\n- 方便的编辑器，所见即所得\n- 插件式的主题定制，可以通过拖拽来自定义主题\n- 支持Git存储，可以保存文章的历史记录\n- 支持生成静态博客，便于部署\n- 可以私有化部署，开源，生态良好\n\n在这里YY下，目前我还没发现这样的一套系统，功能点也是我个人的偏好，不过我会保持关注，持续探索如何优雅的的发布博客。\n\n\n另外对于懒的问题，其实我个人的还是喜欢随便写点什么的，最近也订阅了一些很不错的周刊，感觉这是个很不错形式，以后也勉励自己保持每周多少能写一篇小周刊吧，这一篇也算是个开始吧。\n\n\n## 本周动态\n\n\n### 苹果手机NFC卡解决方法\n\n\n自从转到Iphone阵营后，便失去了手机NFC模拟门卡这一实用功能，我的小区大门和公司门禁都是使用的IC卡，用安卓手机时通过模拟门卡这一功能可以很方便的用手机来开门。由于苹果手机不开放模拟门卡，之前购置了一个小米手环来专门模拟门卡，这一曲线救国方案也还算方便，带个手环偶尔看看时间也比较方便。不过手环毕竟还是没有手机带的那么随身，有时下楼吃饭或者手环放着充电啥的，回来才突然想起没有带，如果手机能刷下卡的话还是非常方便的。\n\n\n最近在PDD中购买了一个30+的PCR532的NFC刷卡器，加上几块钱的NFC卡贴，可以把门卡复制到卡贴中，然后把卡贴贴苹果手机背后到或者夹到手机壳中间，这样便让苹果手机也有了刷门卡的能力，成本也不算高，相比纯手环也更方便了一点。另外这种刷卡器还支持复制加密的门卡，虽说不是一定能成功，但是成功率也是挺高的了。\n\n\nPDD上卖这种机器的还挺多的，除了基本的复制门卡的功能，一般还会附加云备份，云解密等需要开VIP的附加功能，这也算是一种程序员挣外块的方式了吧。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/a1b49e6b8869a404cd1932522f4dd0a.jpg)\n\n\n### Chrome沉浸式翻译插件\n\n\n谷歌插件地址：[沉浸式翻译](https://chrome.google.com/webstore/detail/immersive-translate/bpoadfkcbjbfhfodiogcnhhhpibjhbnh)\n\n\n一款强大的Chrome翻译插件，可以在显示原文的同时显示翻译，支持多种翻译API，翻译速度快还便于对照着学习英语，真是良心插件，吐血推荐。作者的[Buzzing](https://www.buzzing.cc/)网站也是我常常逛的一个网站，可以快速的了解一些国外资讯，内容很丰富。\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/20230226232932.png)\n\n",
      "properties": {
        "date": "2023-03-26",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230226",
        "tags": [],
        "summary": "理想的Blog系统",
        "title": "一周随笔20230226",
        "status": "Published",
        "urlname": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee",
        "updated": "2023-07-10 17:12:00"
      },
      "catalog": [
        {
          "title": "2023-03-26",
          "doc_id": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee"
        }
      ],
      "body": "",
      "realName": "一周随笔20230226",
      "relativePath": "/2023-03-26/一周随笔20230226.md"
    },
    {
      "id": "d8a704d7-d453-48c7-b249-a5e7ec0150b6",
      "doc_id": "d8a704d7-d453-48c7-b249-a5e7ec0150b6",
      "title": "d8a704d7-d453-48c7-b249-a5e7ec0150b6",
      "updated": 1693159860000,
      "body_original": "\n## 小城的热闹\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/202305080014419.webp)\n\n\n五一没出去旅游，回了趟家乡，位于四川南门的小城攀枝花。去年通了高铁，相比于之前动辄12小时的普通火车，现在只需要4个多小时既能回家一趟了。非常喜欢这座位于亚热带的城市气候，目前月份已是天天晴朗的阳光，光亮亮的但不会闷热，相比于时长阴沉沉的成都，心情会好上不少，走在商业区，灯光跟人气都还不错，烟火气息很足，一种安心的回家感。\n\n\n## 技术见闻\n\n\n### nginx-proxy-manager\n\n\n> https://github.com/NginxProxyManager/nginx-proxy-manager FROM: https://www.cnblogs.com/xueweihan/p/17301666.html\n\n\nnginx 是后端开发常用的服务器，工作和个人的一些小项目都在使用，性能强大但是配置还是比较麻烦，需要手动编辑配置文件，此项目可以让用户通过 Web 界面在线配置、管理 Nginx 服务，方便了不少。\n\n\n### 加密货币入门指南\n\n\n> https://helpthisbook.com/sunny/the-newbies-guide-to-crypto/b881f28b-b86a-41d1-9d5e-98ef00a38b11\n\n\n一个英文版本的加密货币新手指南，相比目前最火的AI领域，感觉加密货币对于后端程序员更好上手一些，准备好好读读，顺便也提升下英文阅读能力。搭配B站的这个[区块链技术与应用](https://www.bilibili.com/video/BV1Vt411X7JF/)可以获得更好的效果。\n\n\n### 静态博客管理器\n\n\n> https://www.oplog.cn/qexo/\n\n\n一个快速、强大、漂亮的在线静态博客编辑器，目前我也在用Hugo来发布的我的个人博客，这个在线编辑器可以更方便的管理静态博客，准备试试。\n\n\n### PicList 图床管理和图片上传工具\n\n\n> https://github.com/Kuingsmile/PicList\n\n\n著名的图片上传工具PicGo加强版本，加入了云盘管理功能，配置也可以从PicGo中直接导入，更顺手更方便。\n\n\n### ChatGPT小红书运营速成指南\n\n\n> https://nw44dv3wqt.feishu.cn/docx/MoTWdukyToCjk9xqqLkcOZrEnxg\n\n\n虽然不是运营，但对于技术人员来说，不论AI工具的使用，还是运营推广的能力，都还是可以从这个系列中学习一下的\n\n\n### 裸辞后激情开发300天，不摸鱼的话能做出什么东西\n\n\n> https://www.bilibili.com/video/BV1ST411R7rK/\n\n\n一名IOS独立开发者的经历描述，也作为他这款独立APP《转山》的发布会，形式很新颖，一直想成为独立开发者的我看的还是很膜拜的。\n\n\n## 效率提升\n\n\n### 9个最可能影响你一生的因素\n\n\n> https://t.me/https1024/11856\n\n\n据哈佛大学的一项长期跟踪研究数据：列举出了9个最可能影响你一生的因素。\n\n\n挺像网文鸡汤的，不过很多条都还是感觉讲到自己短处了，可以对照着反思一下。\n\n\n### 英语学习参考\n\n\n英语的学习对于自己来说是个持续的过程，感觉自己处于某个初级水平很久了，收集了两篇资料，准备参考着突破一下\n\n- [让语言学习更简单的 WordFlow](https://sspai.com/post/79241)\n- [旋元佑进阶文法](https://grammar.codeyu.com/)\n",
      "properties": {
        "date": "2023-05-22",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2305-w1",
        "tags": [
          "技术见闻",
          "效率提升"
        ],
        "summary": "五一没出去旅游，回了趟家乡，位于四川南门的小城攀枝花。去年通了高铁，相比于之前动辄12小时的普通火车，现在只需要4个多小时既能回家一趟了。非常喜欢这座位于亚热带的城市气候，目前月份已是天天晴朗的阳光，光亮亮的但不会闷热，相比于时长阴沉沉的成都，心情会好上不少，走在商业区，灯光跟人气都还不错，烟火气息很足，一种安心的回家感。",
        "title": "数字溪流2305-W1",
        "status": "Published",
        "urlname": "d8a704d7-d453-48c7-b249-a5e7ec0150b6",
        "updated": "2023-08-28 02:11:00"
      },
      "catalog": [
        {
          "title": "2023-05-22",
          "doc_id": "d8a704d7-d453-48c7-b249-a5e7ec0150b6"
        }
      ],
      "body": "",
      "realName": "数字溪流2305-W1",
      "relativePath": "/2023-05-22/数字溪流2305-W1.md"
    },
    {
      "id": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e",
      "doc_id": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e",
      "title": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e",
      "updated": 1688979780000,
      "body_original": "\n## 人生第一台电摩\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/202303191448519.jpeg)\n\n\n成功增驾摩托D照后，入手了人生第一台电摩，台铃赤兔。本来想买台铃的萌苏，不过家附近的店没有网上的款式，就看了这款。造型说不上多好看，胜在比较有特点吧，前后都有眼睛一样的双灯，两侧还有一排蓝灯，很有氛围，前轮的大碟刹也挺霸气，白色款还挺有兔子的感觉，车架也比较大，有赤兔马的气势。\n\n\n其实我对电摩的需求不是很高，上班通勤的距离比较远，还是地铁比较合适，也就偶尔去近点的地方可以代代步或者闲暇时去兜兜风，就把它当做一个大玩具吧，想要买款比较智能点的，也有更多的趣味，一直听说九号和小牛的智能化不错，不过溢价太高，选购台铃这款时老板说可以连手机，用手机来解锁啥的，买下后连上手机试了试，槽点满满... 初始化就各种问题搞了半天，连接状态也是经常不稳定，出现了一次半路突然断电情况，感觉和这个连接问题有关，用了几天就卸载不消再用了，有一种传统企业强行转型互联网的味道... 瞬间感觉九号小牛有一些溢价也是有道理的。\n\n\n## 本周见闻\n\n\n### 苹果：为了安全让 M2 吃灰\n\n\nMac的SIP机制对性能存在影响，这个机制会请求苹果的服务器来做安全校验。但由于国内的网络问题，特别是开发时需要编译和运行各类第三方软件时存在较大影响，可以通过修改开发者策略来提升开发速度。\n\n\n[https://catcoding.me/p/apple-perf/](https://catcoding.me/p/apple-perf/)\n\n\n### 信息管理工具 huntly\n\n\n一款个人开源的信息管理工具，很有创意，我也收藏了很多RSS源，也有各种稍后读的需求，这款软件整合了这些需求，准备体验下试试。\n\n\n[https://coolc.substack.com/p/022-huntly](https://coolc.substack.com/p/022-huntly)\n\n\n### 代码提示工具 Codeium\n\n\nOut了，竟然才知道这款代码提示AI，迫于Github Copilot收费，转到了Tabnine，Tabnine的免费版本实在是聊胜于无，能提示的太少了，试了下这款免费的AI，不说比肩Github Copilot，比Tabnine的免费版实在是强大很多了，已全面替换。\n\n\n[https://codeium.com/](https://codeium.com/)\n\n\n## 追番\n\n\n### 虚构推理SE02\n\n\n会长杀妻案，千层饼一样的故事，感觉很精彩，挺期待最后虚构出来杀妻谜底。不过阿B停更了，可恶...\n\n",
      "properties": {
        "date": "2023-03-19",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230319",
        "tags": [],
        "summary": "成功增驾摩托D照后，入手了人生第一台电摩，台铃赤兔。本来想买台铃的萌苏，不过家附近的店没有网上的款式，就看了这款。造型说不上多好看，胜在比较有特点吧，前后都有眼睛一样的双灯，两侧还有一排蓝灯，很有氛围，前轮的大碟刹也挺霸气，白色款还挺有兔子的感觉，车架也比较大，有赤兔马的气势。",
        "title": "一周随笔20230319",
        "status": "Published",
        "urlname": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e",
        "updated": "2023-07-10 17:03:00"
      },
      "catalog": [
        {
          "title": "2023-03-19",
          "doc_id": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e"
        }
      ],
      "body": "",
      "realName": "一周随笔20230319",
      "relativePath": "/2023-03-19/一周随笔20230319.md"
    },
    {
      "id": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a",
      "doc_id": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a",
      "title": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a",
      "updated": 1691748300000,
      "body_original": "\n经过了一段时间的纠结，还是把博客从Hexo迁移到了Hugo，主要是考虑了这些点：\n\n1. 使用Hugo来构建博客真的太方便了，下载好Hugo的可执行文件即可，相比起来切换到一个新环境时搭建Hexo的一个开发环境还是要麻烦不少，有时还挺影响写作的动力的。\n2. Hugo的文章存放目录，theme配置功能可以更自由，当然也可能没找到Hexo的对应配置\n3. 从事Golang的开发几年了，也想支持下基于Golang开发的Hugo\n4. Hexo用腻了，手痒了想折腾😂\n\n嘛，原来使用的Hexo整体我还是比较满意的，特别是当初发现的[Pure](https://github.com/cofess/hexo-theme-pure/)主题挺合我的心意，也废了不少功夫去改造，还有一些待改善的小问题，可惜作者有段时间没有继续更新了，迁移到hugo使用了一个挺相似的主题[Stack](https://github.com/CaiJimmy/hugo-theme-stack)。\n\n\n当然，写博客最重要的还是要能持续的坚持吧，各种原因有好长一段时间没有更新了，这次迁移也是让自己有个新的开始，继续坚持更新下去吧。最近订阅了很多Newsletter，收获很多，也想能像这些作者一样持续更新下去，记录一些自己的笔记和感悟输出，也算是通过网络和世界对话的一个窗口吧。\n\n",
      "properties": {
        "date": "2022-07-08",
        "type": "Post",
        "category": "博客记录",
        "slug": "move-blog-to-hugo",
        "tags": [],
        "summary": "经过了一段时间的纠结，还是把博客从Hexo迁移到了Hugo",
        "title": "迁移博客至Hugo",
        "status": "Published",
        "urlname": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a",
        "updated": "2023-08-11 18:05:00"
      },
      "catalog": [
        {
          "title": "2022-07-08",
          "doc_id": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a"
        }
      ],
      "body": "",
      "realName": "迁移博客至Hugo",
      "relativePath": "/2022-07-08/迁移博客至Hugo.md"
    },
    {
      "id": "0433ceef-587e-4f62-bdce-5c25138bea96",
      "doc_id": "0433ceef-587e-4f62-bdce-5c25138bea96",
      "title": "0433ceef-587e-4f62-bdce-5c25138bea96",
      "updated": 1688979900000,
      "body_original": "\n## C1D 增驾\n\n\n![](https://static-1256611153.file.myqcloud.com/img/picgo/202303131828393.webp)\n\n\n最近准备去增驾一个D照, 一个是闲着没事学点技能以后说不定也用得着(~~入职美团外卖部啥的~~), 另外夏天快要来了, 想入手一辆电摩去兜兜风. 按新国标来看, 电摩也属于摩托车需要通过驾照考试才能上路的.\n\n\n顺便也吐槽下, 想正规考个驾照, 为电摩上符合标准的电摩车, 不过所在的城市禁摩, 这上路就有被罚的风险. 买可以上绿牌的电动自行车, 脚踏和速度上限25的规定实在是不实用, 上牌后再解速也属于是非法改装,何况天天满大街的电动车也没见过有真跑这么慢的电动车...\n\n\n## 本周动态\n\n\n### RSS 订阅工具 NetNewsWire\n\n\nRSS一直是我必不可少咨询获取工具, 目前主要是使用的Chrome插件 RSS Feed Reader, 每天打开浏览器就可以看看有没有新的消息. 这周看到的这款 NetNewsWire 软件, 颜值挺高, 不过只支持Apple平台, 可以作为Apple用户的备用.\n\n\n[https://netnewswire.com/](https://netnewswire.com/)\n\n\n来源: [潮流周刊-第118期 - 端庄的猫](https://weekly.tw93.fun/posts/118-%E7%AB%AF%E5%BA%84%E7%9A%84%E7%8C%AB/)\n\n\n### 终端剪贴板 Clipboard\n\n\n使用终端需要复制粘贴时我一般是使用鼠标选定自动复杂的功能, 感觉虽然也方便但是不可避免的要使用鼠标, 通过这款软件应该能就能脱离鼠标, 完全用键盘来完成这些操作了, 可以学习学习.\n\n\n[https://github.com/Slackadays/Clipboard](https://github.com/Slackadays/Clipboard)\n\n\n来源: [《HelloGitHub》第 83 期](https://www.cnblogs.com/xueweihan/p/17162624.html)\n\n\n### 全平台下载工具 Gospeed\n\n\n用惯了aria2, 体验了下这款国内开源的下载工具, 基于Flutter + Go自带了界面, 本地使用的话会方便一些, 下载了几个磁链链接, 速度还是可以的.\n\n\n[https://github.com/GopeedLab/gopeed](https://github.com/GopeedLab/gopeed)\n\n\n### 云原生物联网开发框架shifu\n\n\n以前做过一段时间的物联网开发, 基于MQTT协议, 自己定义各种通信消息, 很粗放, 看到这款基于云原生的物联网开发平台, 感觉值得关注一下\n\n\n[https://github.com/Edgenesis/shifu](https://github.com/Edgenesis/shifu)\n\n\n来源: [AI 能多强「GitHub 热点速览」](https://www.cnblogs.com/xueweihan/p/17170574.html)\n\n\n### 轻快图床\n\n\n一个 Web 的图床系统, 作者的项目简介也是我的一个痛点: 市面上最火的图床系统是picgo，但由于picgo是桌面应用程序，换了新电脑需要重新下载安装配置，十分麻烦，为了解决该问题，故诞生了这款系统。\n\n\n[https://github.com/ischenliang/quickly-picture-bed](https://github.com/ischenliang/quickly-picture-bed)\n\n",
      "properties": {
        "date": "2023-03-13",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230313",
        "tags": [],
        "summary": "最近准备去增驾一个D照, 一个是闲着没事学点技能以后说不定也用得着(~~入职美团外卖部啥的~~), 另外夏天快要来了, 想入手一辆电摩去兜兜风. 按新国标来看, 电摩也属于摩托车需要通过驾照考试才能上路的.",
        "title": "一周随笔20230313",
        "status": "Published",
        "urlname": "0433ceef-587e-4f62-bdce-5c25138bea96",
        "updated": "2023-07-10 17:05:00"
      },
      "catalog": [
        {
          "title": "2023-03-13",
          "doc_id": "0433ceef-587e-4f62-bdce-5c25138bea96"
        }
      ],
      "body": "",
      "realName": "一周随笔20230313",
      "relativePath": "/2023-03-13/一周随笔20230313.md"
    },
    {
      "id": "22562976-5d02-440f-bca6-042e5cb93a10",
      "doc_id": "22562976-5d02-440f-bca6-042e5cb93a10",
      "title": "22562976-5d02-440f-bca6-042e5cb93a10",
      "updated": 1693144620000,
      "body_original": "\n在开始使用 Notion 编写文档并通过 [NextNotion](https://github.com/tangly1024/NotionNext) 来发布博客后，整个博客的管理和书写体验感觉流畅了不少，不过整个博客的数据放在 Notion 中，心里多少还是有些担忧，假如以后想再迁移到其他的平台岂不是很麻烦，最好有一种方法可以批量导出 Notion 中的文档为 markdown，这样就可以把数据掌握在自己手里，随时可以迁移，再通过 Git 来管理，每个文档还可以有变更的历史记录，再也没有后顾之忧。\n\n\n抱着这样的想法，我开始寻找是否有解决方案，期望的需求：\n\n- 导出 Notion 中 Database 文档为 markdown\n- 可以同时备份图片，并且修改文档中的图片链接为备份链接\n- 能尽可能的自动化\n\n在 Github 上搜索了一下，还行，已经有了不少的 Notion 备份方案。一些较早方案是需要手动 Notion 网页版Cookie 中的 token_v2，调用 web 的导出接口来生成 Markdown。\n\n\n| 项目名            | 地址                                                                                         | star | 最后更新时间     |\n| -------------- | ------------------------------------------------------------------------------------------ | ---- | ---------- |\n| notion-down    | [https://github.com/kaedea/notion-down](https://github.com/kaedea/notion-down)             | 111  | 2021-11-17 |\n| notion-docsify | [https://github.com/qumuchegi/notion-docsify](https://github.com/qumuchegi/notion-docsify) | 32   | 2022-04-18 |\n| notion-up      | [https://github.com/kaedea/notion-up](https://github.com/kaedea/notion-up)                 | 108  | 2021-11-22 |\n| notion-backup  | [https://github.com/darobin/notion-backup](https://github.com/darobin/notion-backup)       | 312  | 2023-03-28 |\n|                | 数据记录时间：2023-08-26                                                                          |      |            |\n\n\n这一类方案好处是使用官方的 markdown 导出接口，文档转换出来的效果很好，不过 token_v2 存在一年的有效期，过期后需要手动重新获取，而且使用 web 接口毕竟是未公开的接口，随时有变动的可能，不是很推荐了。\n\n\nNotion 如今已经推出了官方的 API，能通过官方 API 来备份文档的话那是最好不过了，还好，找到了这两个方案：\n\n\n| 项目名           | 地址                                                                                       | star | 最后更新时间     |\n| ------------- | ---------------------------------------------------------------------------------------- | ---- | ---------- |\n| notion-md-gen | [https://github.com/bonaysoft/notion-md-gen](https://github.com/bonaysoft/notion-md-gen) | 79   | 2023-07-02 |\n| elog          | [https://github.com/LetTTGACO/elog](https://github.com/LetTTGACO/elog)                   | 114  | 2023-08-18 |\n|               | 数据记录时间：2023-08-26                                                                        |      |            |\n\n\n这两个方案中，elog 的生态更好，有专门的团队维护，并且支持更多的平台，完全可以使用这个工具在其支持的平台中写作，然后统一发布到各其他平台。用来备个份当然也是措措有余了，跟着文档进行了下配置：\n\n1. 为 Notion 建立一个 Integration Token，并连接到要备份的 Database，可以参见 elog 的[官网文档](https://elog.1874.cool/notion/gvnxobqogetukays#notion)\n2. 在 GitHub 中建立一个仓库，用于保存备份数据\n3. 新建一个 **elog.config.js，**用于配置导出数据所需的 token、ID，以及导出时是否过滤，保存方式、是否导出图片等选项\n4. 如有特殊需求，可以创建一个 **formatext.js** 来自定义处理数据，我使用这个文件来处理了下 front matter 信息\n5. 为了实现自动化，创建了 `.github/workflows/backup.yml` 方便此后通过 GitHub Action 来自动备份 Notion 数据\n\n具体可以参考我的仓库地址：[https://github.com/wanghaoxi3000/darklab-blog](https://github.com/wanghaoxi3000/darklab-blog)\n\n\n完成这些步骤后，我会在写完文章后，在终端调用下 GitHub Action 的触发接口：\n\n\n```bash\ncurl -L -X POST \\\n  -H \"Accept: application/vnd.github+json\" \\\n  -H \"Authorization: Bearer ${GITHUB_TOKEN}\" \\\n  -d '{\"event_type\": \"backup\"}' \\\n  https://api.github.com/repos/wanghaoxi3000/darklab-blog/dispatches\n```\n\n\nGitHub Action 便会开始下载 Notion 的数据，转换为 Markdown 格式，生成 front matter 信息，并按日期归档后推送到指定的仓库中了。\n\n",
      "properties": {
        "date": "2023-08-27",
        "type": "Post",
        "category": "博客记录",
        "slug": "backup-notion-to-github",
        "tags": [
          "notion"
        ],
        "summary": "在开始使用 Notion 编写文档并通过 NextNotion 来发布博客后，整个博客的管理和书写体验感觉流畅了不少，不过整个博客的数据放在 Notion 中，心里多少还是有些担忧，假如以后想再迁移到其他的平台岂不是很麻烦，最好有一种方法可以批量导出 Notion 中的文档为 markdown，这样就可以把数据掌握在自己手里，随时可以迁移，再通过 Git 来管理，每个文档还可以有变更的历史记录，再也没有后顾之忧。",
        "title": "备份 Notion 文档到 Github",
        "status": "Published",
        "urlname": "22562976-5d02-440f-bca6-042e5cb93a10",
        "updated": "2023-08-27 21:57:00"
      },
      "catalog": [
        {
          "title": "2023-08-27",
          "doc_id": "22562976-5d02-440f-bca6-042e5cb93a10"
        }
      ],
      "body": "",
      "realName": "备份 Notion 文档到 Github",
      "relativePath": "/2023-08-27/备份 Notion 文档到 Github.md"
    },
    {
      "id": "cf75d99b-267a-47b1-a9e6-170495b8a355",
      "doc_id": "cf75d99b-267a-47b1-a9e6-170495b8a355",
      "title": "cf75d99b-267a-47b1-a9e6-170495b8a355",
      "updated": 1693189380000,
      "body_original": "\n# 卡丁赛道\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2a3d1a02-b06d-47ac-8d8c-023a502da971/Untitled.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=74b9227f08e5b90f853ca4c6dac3499a342839596074ed0acaa8eba690855da2&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n周末去附近的一个场地开了下卡丁车，这家公司最近应该是在抖音上打了不少广告，刷到了好几次，不过我本身还挺有兴趣，价格也不算贵，几十块钱可以跑四圈，跑道一圈有一公里多的样子，就来体验了一下。总体还算不错，赛道挺大，就是人有点多，排了一个多小时。卡丁车极速有个四五十码，安全防护措施挺到位的，可以小小的发泄一下速度与激情。\n\n\n# 技术见闻\n\n\n## 阮一峰的 TypeScript 教程\n\n\n> [http://www.ruanyifeng.com/blog/2023/08/typescript-tutorial.html](http://www.ruanyifeng.com/blog/2023/08/typescript-tutorial.html)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/f4dff8a9-b78e-48be-babc-94426f8aac85/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=eee97b6e8c73e2266b47d0e0ee385642a6e2b4e45aa64f080a0a1935a14cf9cc&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\nJavaScript 是一门很万能的语言，特别是在 web 前端开发和各种跨平台客户端开发中都有广泛的应用，之前入门时看过阮一峰的《JavaScript 教程》，质量还不错，一直也想继续进阶下 TypeScript来体验下带类型的 JavaScript，这次看到阮一峰老师新出了 TypeScript 教程，准备跟着学习一下。\n\n\n## **简洁的 TypeScript 之书**\n\n\n> [https://github.com/gibbok/typescript-book](https://github.com/gibbok/typescript-book)\n\n\n虽然标题是简洁的 TypeScript，不过内容很丰富，涵盖了最新版本中的方方面面。完全可以单独当一本 ts 的参考手册来用，可以配合上面教程来一起使用，查漏补缺。\n\n\n## **Nologin 提供保密的电子邮箱**\n\n\n> [https://nlogin.me/](https://nlogin.me/)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0d93684d-ba0f-4299-be18-15e9b0bb8079/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=10835c35026e577cfcbb3e3456b72ddfe06ae1b6320b34b229085a7fe5f488cf&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\nNologin 使用专用中继电子邮件地址隐藏您的电子邮件地址。可以理解成是一个中继邮箱，当我们使用这个中继邮箱注册各种服务账号时，验证码会先发送到这个中继邮箱，中继邮箱再发给你，很好的避免了泄露我们的真实邮箱。\n\n\n来源：[产品鸭](https://produck.zhubai.love/posts/2302691740500840448)\n\n\n## 神器集 发现最酷的互联网神器和工具\n\n\n> [https://hao.logosc.cn/](https://hao.logosc.cn/)\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/4917ecd3-faba-4889-aad4-df6681af538c/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=40ecff575975fce099982d0b06ec01eea7f30e76751e2891e829a50e15faca1b&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n一个发现分享有趣在线工具的地方。我是一个挺喜欢关注各类互联网工具的人，在这个生产力大爆发的时代，一个好的互联网工具可以提升不少的效率。看了下这个网站的内容还是很对我的胃口，丰富了不少我的工具库，如果你和有我一样此类的关注点的话可以看看这个网站。\n\n\n[产品鸭](https://produck.zhubai.love/posts/2302691740500840448)中介绍此网站时，也分析了下此类网站的痛点和国内环境面对此类需求时真正需要的解决方案，很在理，也推荐去原文看看。\n\n\n来源：[产品鸭](https://produck.zhubai.love/posts/2302691740500840448)\n\n\n# 生活杂谈\n\n\n## 数字游民\n\n\n![](https://s3.us-west-2.amazonaws.com/secure.notion-static.com/0d0b38a1-f3cc-4809-808a-d7f1ec752d3a/Untitled.png?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=648628236ed2f15e5fc33f86fc42b3ade3ad6340b88cbd61c34839f5eca998ce&X-Amz-SignedHeaders=host&x-id=GetObject)\n\n\n这周看了自己关注的博主一篇有关他远程工作的体验：[https://catcoding.me/p/remote-work/](https://catcoding.me/p/remote-work/)，想起了数字游民这个概念。第一次听说到数字游民这个词，是在微信公众号中偶然看到了一个《[数字游民空间Dali Hub2.0 重新开业](https://mp.weixin.qq.com/s/I4CeWlWbsip_6RJViD8wWw)》的广告， 这个大理的办公空间聚集了一批可以一边远程工作赚钱一边周游旅行的人，在这个数字时代过着游牧搬的生活。可以一边旅行一边工作的生活真的是挺羡慕的，感觉这才是互联网工作者的理想形态，希望以后也能有这样的体验，姑且再给人生添加一个缥缈的小目标吧。\n\n\n有关数字游民的详细讲解，推荐看看这篇《[什么是数字游民? - DN终极扫盲贴](https://mp.weixin.qq.com/s?__biz=MzIyMjAwNzAzNg%3D%3D&mid=2650207755&idx=1&sn=2fc60aa69b13ae1b4d55fefbba72da75&chksm=f0364d98c741c48eff59cebdd9fcb1e416bea1369ca32191356413daf647e3ef39a0d8bcc670&scene=21#wechat_redirect)》文章，从概念到实现途径以及将要面临的困难都讲得很详细，感兴趣的小伙伴可以看看。\n\n",
      "properties": {
        "date": "2023-08-28",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2308-w4",
        "tags": [],
        "summary": "周末去附近的一个场地开了下卡丁车，这家公司最近应该是在抖音上打了不少广告，刷到了好几次，不过我本身还挺有兴趣，价格也不算贵，几十块钱可以跑四圈，跑道一圈有一公里多的样子，就来体验了一下。总体还算不错，赛道挺大，就是人有点多，排了一个多小时。卡丁车极速有个四五十码，安全防护措施挺到位的，可以小小的发泄一下速度与激情。",
        "title": "数字溪流2308-W4",
        "status": "Published",
        "urlname": "cf75d99b-267a-47b1-a9e6-170495b8a355",
        "updated": "2023-08-28 10:23:00"
      },
      "catalog": [
        {
          "title": "2023-08-28",
          "doc_id": "cf75d99b-267a-47b1-a9e6-170495b8a355"
        }
      ],
      "body": "",
      "realName": "数字溪流2308-W4",
      "relativePath": "/2023-08-28/数字溪流2308-W4.md"
    }
  ],
  "catalog": [
    {
      "object": "page",
      "id": "cf75d99b-267a-47b1-a9e6-170495b8a355",
      "created_time": "2023-08-27T15:11:00.000Z",
      "last_edited_time": "2023-08-28T02:23:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "file",
        "file": {
          "url": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/2a3d1a02-b06d-47ac-8d8c-023a502da971/Untitled.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=74b9227f08e5b90f853ca4c6dac3499a342839596074ed0acaa8eba690855da2&X-Amz-SignedHeaders=host&x-id=GetObject",
          "expiry_time": "2023-08-28T03:26:57.199Z"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "date": "2023-08-28",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2308-w4",
        "tags": [],
        "summary": "周末去附近的一个场地开了下卡丁车，这家公司最近应该是在抖音上打了不少广告，刷到了好几次，不过我本身还挺有兴趣，价格也不算贵，几十块钱可以跑四圈，跑道一圈有一公里多的样子，就来体验了一下。总体还算不错，赛道挺大，就是人有点多，排了一个多小时。卡丁车极速有个四五十码，安全防护措施挺到位的，可以小小的发泄一下速度与激情。",
        "title": "数字溪流2308-W4",
        "status": "Published",
        "urlname": "cf75d99b-267a-47b1-a9e6-170495b8a355",
        "updated": "2023-08-28 10:23:00"
      },
      "url": "https://www.notion.so/2308-W4-cf75d99b267a47b1a9e6170495b8a355",
      "public_url": "https://military-albatross-7a9.notion.site/2308-W4-cf75d99b267a47b1a9e6170495b8a355"
    },
    {
      "object": "page",
      "id": "b658d5ed-817b-44f3-9443-839161b38ad3",
      "created_time": "2023-08-13T13:14:00.000Z",
      "last_edited_time": "2023-08-27T18:11:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "file",
        "file": {
          "url": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/7912828d-2996-49e8-a0d1-d9d8110bc7bc/5dc29d8.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=db3a8ff4f5298280bbe71bf94afef1ced4d179e68aab47df3b8648f713e3ba20&X-Amz-SignedHeaders=host&x-id=GetObject",
          "expiry_time": "2023-08-28T03:26:57.189Z"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "date": "2023-08-13",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2308-w2",
        "tags": [],
        "summary": "周末和亲戚朋友们去了峨眉的七里坪禅道，也许正是成都最热的时候，普通的周末也有很多人，不过和亲近的人一起游玩下还是很愉悦的。这里离峨眉索道不远，不过知道的人应该还不多，想避开攀登峨眉的大部队在附近登山打卡一下的话可以在这里试试。",
        "title": "数字溪流2308-W2",
        "status": "Published",
        "urlname": "b658d5ed-817b-44f3-9443-839161b38ad3",
        "updated": "2023-08-28 02:11:00"
      },
      "url": "https://www.notion.so/2308-W2-b658d5ed817b44f39443839161b38ad3",
      "public_url": "https://military-albatross-7a9.notion.site/2308-W2-b658d5ed817b44f39443839161b38ad3"
    },
    {
      "object": "page",
      "id": "22562976-5d02-440f-bca6-042e5cb93a10",
      "created_time": "2023-08-03T15:24:00.000Z",
      "last_edited_time": "2023-08-27T13:57:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "date": "2023-08-27",
        "type": "Post",
        "category": "博客记录",
        "slug": "backup-notion-to-github",
        "tags": [
          "notion"
        ],
        "summary": "在开始使用 Notion 编写文档并通过 NextNotion 来发布博客后，整个博客的管理和书写体验感觉流畅了不少，不过整个博客的数据放在 Notion 中，心里多少还是有些担忧，假如以后想再迁移到其他的平台岂不是很麻烦，最好有一种方法可以批量导出 Notion 中的文档为 markdown，这样就可以把数据掌握在自己手里，随时可以迁移，再通过 Git 来管理，每个文档还可以有变更的历史记录，再也没有后顾之忧。",
        "title": "备份 Notion 文档到 Github",
        "status": "Published",
        "urlname": "22562976-5d02-440f-bca6-042e5cb93a10",
        "updated": "2023-08-27 21:57:00"
      },
      "url": "https://www.notion.so/Notion-Github-225629765d02440fbca6042e5cb93a10",
      "public_url": "https://military-albatross-7a9.notion.site/Notion-Github-225629765d02440fbca6042e5cb93a10"
    },
    {
      "object": "page",
      "id": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5",
      "created_time": "2023-07-30T11:19:00.000Z",
      "last_edited_time": "2023-07-30T16:16:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "file",
        "file": {
          "url": "https://s3.us-west-2.amazonaws.com/secure.notion-static.com/74718d04-0c1e-4e9f-abd0-eba81c5fd246/%E5%BE%AE%E4%BF%A1%E5%9B%BE%E7%89%87_20230730224558.webp?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Content-Sha256=UNSIGNED-PAYLOAD&X-Amz-Credential=AKIAT73L2G45EIPT3X45%2F20230828%2Fus-west-2%2Fs3%2Faws4_request&X-Amz-Date=20230828T022657Z&X-Amz-Expires=3600&X-Amz-Signature=1b415d86e1db6087537046a03b43b9f4867962b94eb1305ec017a0861e5e4152&X-Amz-SignedHeaders=host&x-id=GetObject",
          "expiry_time": "2023-08-28T03:26:57.196Z"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-07-30",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2307-w5",
        "tags": [],
        "summary": "拍摄于塔子山公园的鸟语林，原来塔子山公园上还隐藏着这么一个小小的鸟类主题动物园，之前逛过几次都没发现，还是在大众点评上看到才无意发现。这只海鸥呆呆的眼神立马让我想起了去码头整点薯条这个梗，真是很适合这呆头呆脑的形象，哈哈。动物园里除了鹦鹉，海鸥，天鹅这些常见的鸟类也有羊驼，梅花鹿，绵羊甚至猪，妥妥的大杂烩。",
        "title": "数字溪流2307-W5",
        "status": "Published",
        "urlname": "a239adaa-a272-4a0f-ab61-7fad7e79f0e5",
        "updated": "2023-07-31 00:16:00"
      },
      "url": "https://www.notion.so/2307-W5-a239adaaa2724a0fab617fad7e79f0e5",
      "public_url": "https://military-albatross-7a9.notion.site/2307-W5-a239adaaa2724a0fab617fad7e79f0e5"
    },
    {
      "object": "page",
      "id": "396270c6-a77e-4a97-992e-e273e0a24892",
      "created_time": "2023-07-25T09:12:00.000Z",
      "last_edited_time": "2023-08-11T10:30:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-08-11",
        "type": "Post",
        "category": "博客记录",
        "slug": " migrate-blog-to-notionnext-from-hugo",
        "tags": [
          "NotionNext",
          "hugo",
          "notion",
          "blog"
        ],
        "summary": "曾经在 一周随笔20230226 这篇博文中描述了下我心目中理想的 Blog 系统，吐槽了下写博文时的一些很不爽的地方，也一直在寻找更好的 Blog 系统。直到无意间发现了 NotionNext，一下就有了哎哟不错喔，这应该就是我想要的博客系统这种感觉。甚至马上就想开始动手迁移我的博客，没有当初从 Hexo 迁移到 Hugo 的时那种纠结。",
        "title": "从 Hugo 迁移到 NotionNext",
        "status": "Published",
        "urlname": "396270c6-a77e-4a97-992e-e273e0a24892",
        "updated": "2023-08-11 18:30:00"
      },
      "url": "https://www.notion.so/Hugo-NotionNext-396270c6a77e4a97992ee273e0a24892",
      "public_url": "https://military-albatross-7a9.notion.site/Hugo-NotionNext-396270c6a77e4a97992ee273e0a24892"
    },
    {
      "object": "page",
      "id": "0178db9b-0fd8-41ed-b27d-0015ae286e79",
      "created_time": "2023-07-23T15:16:00.000Z",
      "last_edited_time": "2023-07-25T15:14:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-07-23",
        "type": "Post",
        "category": "软件工具",
        "slug": "use-keel-auto-update-image-version-in-k8s",
        "tags": [
          "kubernetes",
          "Keel"
        ],
        "summary": "当我们在自己的服务器上使用 Docker 部署了一些有用的容器镜像时，一般可以使用 watchtower 来自动更新我们的镜像版本。但是如果使用的是 K8S，有没有工具可以像 watchtower 一样来自动更新 K8S 中的容器镜像版本呢，最近发现了 Keel 这款工具可以做同样的事。",
        "title": "使用 Keel 自动更新 K8S 中容器镜像",
        "status": "Published",
        "urlname": "0178db9b-0fd8-41ed-b27d-0015ae286e79",
        "updated": "2023-07-25 23:14:00"
      },
      "url": "https://www.notion.so/Keel-K8S-0178db9b0fd841edb27d0015ae286e79",
      "public_url": "https://military-albatross-7a9.notion.site/Keel-K8S-0178db9b0fd841edb27d0015ae286e79"
    },
    {
      "object": "page",
      "id": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868",
      "created_time": "2023-07-21T10:33:00.000Z",
      "last_edited_time": "2023-07-21T10:36:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2021-12-08",
        "type": "Post",
        "category": "Golang",
        "slug": "golang-gc-theory",
        "tags": [
          "Golang GC"
        ],
        "summary": "Go 1.5 以后（截止Golang v1.12）采用了非分代、非紧缩、写屏障、三色标记的原理进行垃圾回收。",
        "title": "Golang GC 原理",
        "status": "Published",
        "urlname": "5b1cf9e5-6248-4bb5-bd04-87cf89e4c868",
        "updated": "2023-07-21 18:36:00"
      },
      "url": "https://www.notion.so/Golang-GC-5b1cf9e562484bb5bd0487cf89e4c868",
      "public_url": "https://military-albatross-7a9.notion.site/Golang-GC-5b1cf9e562484bb5bd0487cf89e4c868"
    },
    {
      "object": "page",
      "id": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46",
      "created_time": "2023-07-13T09:59:00.000Z",
      "last_edited_time": "2023-07-17T07:12:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-10-20",
        "type": "Post",
        "category": "Linux管理",
        "slug": "vi-skills",
        "tags": [],
        "summary": "",
        "title": "Vi使用技巧",
        "status": "Published",
        "urlname": "d749a6fa-bee2-4c5a-a28d-33ba1c9e9d46",
        "updated": "2023-07-17 15:12:00"
      },
      "url": "https://www.notion.so/Vi-d749a6fabee24c5aa28d33ba1c9e9d46",
      "public_url": "https://military-albatross-7a9.notion.site/Vi-d749a6fabee24c5aa28d33ba1c9e9d46"
    },
    {
      "object": "page",
      "id": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee",
      "created_time": "2023-07-13T09:59:00.000Z",
      "last_edited_time": "2023-07-17T07:13:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-11-02",
        "type": "Post",
        "category": "Linux编程",
        "slug": "linux-driven-development-basic-knowledge",
        "tags": [],
        "summary": "",
        "title": "Linux驱动开发基础知识",
        "status": "Published",
        "urlname": "0bd4d76f-8ce3-4f7a-9795-ec84b0b7b8ee",
        "updated": "2023-07-17 15:13:00"
      },
      "url": "https://www.notion.so/Linux-0bd4d76f8ce34f7a9795ec84b0b7b8ee",
      "public_url": "https://military-albatross-7a9.notion.site/Linux-0bd4d76f8ce34f7a9795ec84b0b7b8ee"
    },
    {
      "object": "page",
      "id": "11f072de-5ee2-401b-946c-59daf3f6a1ad",
      "created_time": "2023-07-13T09:59:00.000Z",
      "last_edited_time": "2023-07-17T07:12:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-11-08",
        "type": "Post",
        "category": "Python",
        "slug": "py2exe-conversion-parameters",
        "tags": [],
        "summary": "",
        "title": "py2exe转换参数",
        "status": "Published",
        "urlname": "11f072de-5ee2-401b-946c-59daf3f6a1ad",
        "updated": "2023-07-17 15:12:00"
      },
      "url": "https://www.notion.so/py2exe-11f072de5ee2401b946c59daf3f6a1ad",
      "public_url": "https://military-albatross-7a9.notion.site/py2exe-11f072de5ee2401b946c59daf3f6a1ad"
    },
    {
      "object": "page",
      "id": "f772582b-f800-4295-b10e-8f87ffa32d63",
      "created_time": "2023-07-13T09:58:00.000Z",
      "last_edited_time": "2023-07-17T07:12:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-12-10",
        "type": "Post",
        "category": "Linux编程",
        "slug": "makefile-common-knowledge-points",
        "tags": [],
        "summary": "",
        "title": "Makefile常用知识点",
        "status": "Published",
        "urlname": "f772582b-f800-4295-b10e-8f87ffa32d63",
        "updated": "2023-07-17 15:12:00"
      },
      "url": "https://www.notion.so/Makefile-f772582bf8004295b10e8f87ffa32d63",
      "public_url": "https://military-albatross-7a9.notion.site/Makefile-f772582bf8004295b10e8f87ffa32d63"
    },
    {
      "object": "page",
      "id": "351382cf-57e4-4fd1-a59b-2e95dc07fd20",
      "created_time": "2023-07-13T09:58:00.000Z",
      "last_edited_time": "2023-07-17T07:11:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-12-10",
        "type": "Post",
        "category": "Python",
        "slug": "python-tarfile-module-unzip-invalid-mode-('wb')-or-filename",
        "tags": [],
        "summary": "",
        "title": "Python tarfile模块解压报错 invalid mode ('wb') or filename",
        "status": "Published",
        "urlname": "351382cf-57e4-4fd1-a59b-2e95dc07fd20",
        "updated": "2023-07-17 15:11:00"
      },
      "url": "https://www.notion.so/Python-tarfile-invalid-mode-wb-or-filename-351382cf57e44fd1a59b2e95dc07fd20",
      "public_url": "https://military-albatross-7a9.notion.site/Python-tarfile-invalid-mode-wb-or-filename-351382cf57e44fd1a59b2e95dc07fd20"
    },
    {
      "object": "page",
      "id": "276c3766-5a22-4f6f-8316-f8de676c3a3d",
      "created_time": "2023-07-13T09:58:00.000Z",
      "last_edited_time": "2023-07-17T07:11:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-12-10",
        "type": "Post",
        "category": "Python",
        "slug": "python-small-knowledge-point",
        "tags": [],
        "summary": "",
        "title": "python小知识点",
        "status": "Published",
        "urlname": "276c3766-5a22-4f6f-8316-f8de676c3a3d",
        "updated": "2023-07-17 15:11:00"
      },
      "url": "https://www.notion.so/python-276c37665a224f6f8316f8de676c3a3d",
      "public_url": "https://military-albatross-7a9.notion.site/python-276c37665a224f6f8316f8de676c3a3d"
    },
    {
      "object": "page",
      "id": "d6248408-342d-49c8-815f-69ff4076bb79",
      "created_time": "2023-07-13T09:57:00.000Z",
      "last_edited_time": "2023-07-17T07:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2016-12-16",
        "type": "Post",
        "category": "Android",
        "slug": "android-activity-lifecycle",
        "tags": [],
        "summary": "",
        "title": "Android活动生命周期",
        "status": "Published",
        "urlname": "d6248408-342d-49c8-815f-69ff4076bb79",
        "updated": "2023-07-17 15:10:00"
      },
      "url": "https://www.notion.so/Android-d6248408342d49c8815f69ff4076bb79",
      "public_url": "https://military-albatross-7a9.notion.site/Android-d6248408342d49c8815f69ff4076bb79"
    },
    {
      "object": "page",
      "id": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4",
      "created_time": "2023-07-13T09:55:00.000Z",
      "last_edited_time": "2023-07-17T07:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-01-22",
        "type": "Post",
        "category": "数据库",
        "slug": "mysql-will-surely-know-notes",
        "tags": [],
        "summary": "",
        "title": "MySQL必知必会笔记",
        "status": "Published",
        "urlname": "4fe27424-e1b9-4e3a-a456-3d9ce383e8b4",
        "updated": "2023-07-17 15:10:00"
      },
      "url": "https://www.notion.so/MySQL-4fe27424e1b94e3aa4563d9ce383e8b4",
      "public_url": "https://military-albatross-7a9.notion.site/MySQL-4fe27424e1b94e3aa4563d9ce383e8b4"
    },
    {
      "object": "page",
      "id": "85d0963c-d167-457f-9e97-19e6477c6d4e",
      "created_time": "2023-07-13T09:54:00.000Z",
      "last_edited_time": "2023-07-17T07:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-03-12",
        "type": "Post",
        "category": "Linux管理",
        "slug": "summary-of-shell-writing",
        "tags": [],
        "summary": "",
        "title": "shell编写总结",
        "status": "Published",
        "urlname": "85d0963c-d167-457f-9e97-19e6477c6d4e",
        "updated": "2023-07-17 15:10:00"
      },
      "url": "https://www.notion.so/shell-85d0963cd167457f9e9719e6477c6d4e",
      "public_url": "https://military-albatross-7a9.notion.site/shell-85d0963cd167457f9e9719e6477c6d4e"
    },
    {
      "object": "page",
      "id": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b",
      "created_time": "2023-07-13T09:54:00.000Z",
      "last_edited_time": "2023-07-17T07:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-04-09",
        "type": "Post",
        "category": "Django",
        "slug": "design-pattern-of-django",
        "tags": [],
        "summary": "",
        "title": "Django的设计模式",
        "status": "Published",
        "urlname": "047e10f5-4d9d-4b27-8eb9-8ad26242f40b",
        "updated": "2023-07-17 15:10:00"
      },
      "url": "https://www.notion.so/Django-047e10f54d9d4b278eb98ad26242f40b",
      "public_url": "https://military-albatross-7a9.notion.site/Django-047e10f54d9d4b278eb98ad26242f40b"
    },
    {
      "object": "page",
      "id": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b",
      "created_time": "2023-07-13T09:54:00.000Z",
      "last_edited_time": "2023-07-17T07:09:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-04-09",
        "type": "Post",
        "category": "Django",
        "slug": "django-modelform-modifies-the-default-control-properties",
        "tags": [],
        "summary": "",
        "title": "Django ModelForm修改默认的控件属性",
        "status": "Published",
        "urlname": "7ef338f3-3c3b-4254-9a9b-888ed9d87f4b",
        "updated": "2023-07-17 15:09:00"
      },
      "url": "https://www.notion.so/Django-ModelForm-7ef338f33c3b42549a9b888ed9d87f4b",
      "public_url": "https://military-albatross-7a9.notion.site/Django-ModelForm-7ef338f33c3b42549a9b888ed9d87f4b"
    },
    {
      "object": "page",
      "id": "4531936b-6f90-48a8-8d44-c663f3a660cd",
      "created_time": "2023-07-13T09:53:00.000Z",
      "last_edited_time": "2023-07-17T07:09:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-04-20",
        "type": "Post",
        "category": "Linux管理",
        "slug": "the-configuration-program-becomes-a-linux-service",
        "tags": [],
        "summary": "",
        "title": "配置程序成为Linux服务",
        "status": "Published",
        "urlname": "4531936b-6f90-48a8-8d44-c663f3a660cd",
        "updated": "2023-07-17 15:09:00"
      },
      "url": "https://www.notion.so/Linux-4531936b6f9048a88d44c663f3a660cd",
      "public_url": "https://military-albatross-7a9.notion.site/Linux-4531936b6f9048a88d44c663f3a660cd"
    },
    {
      "object": "page",
      "id": "3703f624-8045-4b58-9dda-216f30a79bcc",
      "created_time": "2023-07-13T09:52:00.000Z",
      "last_edited_time": "2023-07-17T07:08:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-04-27",
        "type": "Post",
        "category": "设计模式",
        "slug": "brief-explanation-of-event-driven-(python-implementation)",
        "tags": [],
        "summary": "",
        "title": "事件驱动的简明讲解(python实现)",
        "status": "Published",
        "urlname": "3703f624-8045-4b58-9dda-216f30a79bcc",
        "updated": "2023-07-17 15:08:00"
      },
      "url": "https://www.notion.so/python-3703f62480454b589dda216f30a79bcc",
      "public_url": "https://military-albatross-7a9.notion.site/python-3703f62480454b589dda216f30a79bcc"
    },
    {
      "object": "page",
      "id": "acdd1a45-2613-49f0-a576-7b6875fe99f8",
      "created_time": "2023-07-13T09:52:00.000Z",
      "last_edited_time": "2023-07-17T07:08:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-05-06",
        "type": "Post",
        "category": "Python",
        "slug": "python-advanced-iterator-and-generator",
        "tags": [],
        "summary": "",
        "title": "Python进阶之迭代器和生成器",
        "status": "Published",
        "urlname": "acdd1a45-2613-49f0-a576-7b6875fe99f8",
        "updated": "2023-07-17 15:08:00"
      },
      "url": "https://www.notion.so/Python-acdd1a45261349f0a5767b6875fe99f8",
      "public_url": "https://military-albatross-7a9.notion.site/Python-acdd1a45261349f0a5767b6875fe99f8"
    },
    {
      "object": "page",
      "id": "c4d4129f-e286-4dbd-a7af-8e824ae2924e",
      "created_time": "2023-07-13T09:51:00.000Z",
      "last_edited_time": "2023-07-17T07:07:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-05-10",
        "type": "Post",
        "category": "Python",
        "slug": "python-advanced-decorator",
        "tags": [],
        "summary": "",
        "title": "Python进阶之装饰器",
        "status": "Published",
        "urlname": "c4d4129f-e286-4dbd-a7af-8e824ae2924e",
        "updated": "2023-07-17 15:07:00"
      },
      "url": "https://www.notion.so/Python-c4d4129fe2864dbda7af8e824ae2924e",
      "public_url": "https://military-albatross-7a9.notion.site/Python-c4d4129fe2864dbda7af8e824ae2924e"
    },
    {
      "object": "page",
      "id": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882",
      "created_time": "2023-07-13T09:50:00.000Z",
      "last_edited_time": "2023-07-17T07:06:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-05-20",
        "type": "Post",
        "category": "Python",
        "slug": "collections-of-the-python-module",
        "tags": [],
        "summary": "",
        "title": "Python模块之Collections",
        "status": "Published",
        "urlname": "3cc8b889-069f-4f1c-bbe2-81f03a7ca882",
        "updated": "2023-07-17 15:06:00"
      },
      "url": "https://www.notion.so/Python-Collections-3cc8b889069f4f1cbbe281f03a7ca882",
      "public_url": "https://military-albatross-7a9.notion.site/Python-Collections-3cc8b889069f4f1cbbe281f03a7ca882"
    },
    {
      "object": "page",
      "id": "adf520da-d2ef-41b2-aa0a-de9c13c87721",
      "created_time": "2023-07-13T09:48:00.000Z",
      "last_edited_time": "2023-07-17T07:04:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-06-02",
        "type": "Post",
        "category": "JavaScript",
        "slug": "javascript-type-comparison",
        "tags": [],
        "summary": "",
        "title": "JavaScript类型比较",
        "status": "Published",
        "urlname": "adf520da-d2ef-41b2-aa0a-de9c13c87721",
        "updated": "2023-07-17 15:04:00"
      },
      "url": "https://www.notion.so/JavaScript-adf520dad2ef41b2aa0ade9c13c87721",
      "public_url": "https://military-albatross-7a9.notion.site/JavaScript-adf520dad2ef41b2aa0ade9c13c87721"
    },
    {
      "object": "page",
      "id": "8810277f-eb6e-41cc-9ff1-022d45838b09",
      "created_time": "2023-07-13T09:48:00.000Z",
      "last_edited_time": "2023-07-17T07:03:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-06-24",
        "type": "Post",
        "category": "JavaScript",
        "slug": "the-basic-concept-of-javascript-closure",
        "tags": [],
        "summary": "",
        "title": "JavaScript闭包基本概念",
        "status": "Published",
        "urlname": "8810277f-eb6e-41cc-9ff1-022d45838b09",
        "updated": "2023-07-17 15:03:00"
      },
      "url": "https://www.notion.so/JavaScript-8810277feb6e41cc9ff1022d45838b09",
      "public_url": "https://military-albatross-7a9.notion.site/JavaScript-8810277feb6e41cc9ff1022d45838b09"
    },
    {
      "object": "page",
      "id": "206a23f7-dc7b-42cb-bff8-fe5cae67b860",
      "created_time": "2023-07-13T09:46:00.000Z",
      "last_edited_time": "2023-07-17T07:01:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-06-24",
        "type": "Post",
        "category": "JavaScript",
        "slug": "javascript-function",
        "tags": [],
        "summary": "",
        "title": "JavaScript 函数",
        "status": "Published",
        "urlname": "206a23f7-dc7b-42cb-bff8-fe5cae67b860",
        "updated": "2023-07-17 15:01:00"
      },
      "url": "https://www.notion.so/JavaScript-206a23f7dc7b42cbbff8fe5cae67b860",
      "public_url": "https://military-albatross-7a9.notion.site/JavaScript-206a23f7dc7b42cbbff8fe5cae67b860"
    },
    {
      "object": "page",
      "id": "a829aa8b-4b63-4436-ad5c-d3d5b121b896",
      "created_time": "2023-07-13T09:46:00.000Z",
      "last_edited_time": "2023-07-17T06:48:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-06-24",
        "type": "Post",
        "category": "Java",
        "slug": "java-io-learning-point-guide",
        "tags": [],
        "summary": "",
        "title": "Java IO学习要点导图",
        "status": "Published",
        "urlname": "a829aa8b-4b63-4436-ad5c-d3d5b121b896",
        "updated": "2023-07-17 14:48:00"
      },
      "url": "https://www.notion.so/Java-IO-a829aa8b4b634436ad5cd3d5b121b896",
      "public_url": "https://military-albatross-7a9.notion.site/Java-IO-a829aa8b4b634436ad5cd3d5b121b896"
    },
    {
      "object": "page",
      "id": "78e26026-8b45-4f5a-8cbf-9426d45f4224",
      "created_time": "2023-07-13T09:45:00.000Z",
      "last_edited_time": "2023-07-17T06:47:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-06-24",
        "type": "Post",
        "category": "Java",
        "slug": "the-class-object-of-the-thinking-mapping-java",
        "tags": [],
        "summary": "",
        "title": "思维导图学Java之Class对象",
        "status": "Published",
        "urlname": "78e26026-8b45-4f5a-8cbf-9426d45f4224",
        "updated": "2023-07-17 14:47:00"
      },
      "url": "https://www.notion.so/Java-Class-78e260268b454f5a8cbf9426d45f4224",
      "public_url": "https://military-albatross-7a9.notion.site/Java-Class-78e260268b454f5a8cbf9426d45f4224"
    },
    {
      "object": "page",
      "id": "f591f5a7-df0d-4077-a51e-615be25c7d01",
      "created_time": "2023-07-13T09:45:00.000Z",
      "last_edited_time": "2023-07-17T06:47:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-07-12",
        "type": "Post",
        "category": "JavaScript",
        "slug": "es6-scope-and-deconstruction-assignment",
        "tags": [],
        "summary": "",
        "title": "ES6作用域和解构赋值",
        "status": "Published",
        "urlname": "f591f5a7-df0d-4077-a51e-615be25c7d01",
        "updated": "2023-07-17 14:47:00"
      },
      "url": "https://www.notion.so/ES6-f591f5a7df0d4077a51e615be25c7d01",
      "public_url": "https://military-albatross-7a9.notion.site/ES6-f591f5a7df0d4077a51e615be25c7d01"
    },
    {
      "object": "page",
      "id": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356",
      "created_time": "2023-07-13T09:42:00.000Z",
      "last_edited_time": "2023-07-17T06:45:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-09-24",
        "type": "Post",
        "category": "设计模式",
        "slug": "notes-on-the-design-pattern-of-big-talk",
        "tags": [],
        "summary": "",
        "title": "大话设计模式 笔记",
        "status": "Published",
        "urlname": "90c1b6ff-c63d-47e6-aa1d-38f0b8ae3356",
        "updated": "2023-07-17 14:45:00"
      },
      "url": "https://www.notion.so/90c1b6ffc63d47e6aa1d38f0b8ae3356",
      "public_url": "https://military-albatross-7a9.notion.site/90c1b6ffc63d47e6aa1d38f0b8ae3356"
    },
    {
      "object": "page",
      "id": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd",
      "created_time": "2023-07-13T09:41:00.000Z",
      "last_edited_time": "2023-07-17T06:45:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-09-25",
        "type": "Post",
        "category": "cpp",
        "slug": "cpp11-new-knowledge-point",
        "tags": [],
        "summary": "",
        "title": "C++11 新知识点",
        "status": "Published",
        "urlname": "b8f82bfa-8109-409c-bb6a-ad69dd5e25cd",
        "updated": "2023-07-17 14:45:00"
      },
      "url": "https://www.notion.so/C-11-b8f82bfa8109409cbb6aad69dd5e25cd",
      "public_url": "https://military-albatross-7a9.notion.site/C-11-b8f82bfa8109409cbb6aad69dd5e25cd"
    },
    {
      "object": "page",
      "id": "39808486-176b-44d2-9277-48a36682cc92",
      "created_time": "2023-07-13T09:41:00.000Z",
      "last_edited_time": "2023-07-17T06:43:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-12-29",
        "type": "Post",
        "category": "Linux管理",
        "slug": "shell-edit-the-crontab-task",
        "tags": [],
        "summary": "",
        "title": "shell编辑crontab任务",
        "status": "Published",
        "urlname": "39808486-176b-44d2-9277-48a36682cc92",
        "updated": "2023-07-17 14:43:00"
      },
      "url": "https://www.notion.so/shell-crontab-39808486176b44d2927748a36682cc92",
      "public_url": "https://military-albatross-7a9.notion.site/shell-crontab-39808486176b44d2927748a36682cc92"
    },
    {
      "object": "page",
      "id": "9b07d1c7-14d8-4348-a464-07e07e50bb64",
      "created_time": "2023-07-13T09:38:00.000Z",
      "last_edited_time": "2023-07-17T07:13:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2017-12-29",
        "type": "Post",
        "category": "Linux管理",
        "slug": "linux-common-commands",
        "tags": [
          "Linux命令"
        ],
        "summary": "",
        "title": "Linux常用命令",
        "status": "Published",
        "urlname": "9b07d1c7-14d8-4348-a464-07e07e50bb64",
        "updated": "2023-07-17 15:13:00"
      },
      "url": "https://www.notion.so/Linux-9b07d1c714d84348a46407e07e50bb64",
      "public_url": "https://military-albatross-7a9.notion.site/Linux-9b07d1c714d84348a46407e07e50bb64"
    },
    {
      "object": "page",
      "id": "961c038c-8f49-478d-8c61-68f679680da0",
      "created_time": "2023-07-13T09:38:00.000Z",
      "last_edited_time": "2023-07-17T06:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-01-04",
        "type": "Post",
        "category": "Python",
        "slug": "virtualenvwrapper-of-the-python-module",
        "tags": [],
        "summary": "",
        "title": "Python模块之virtualenvwrapper",
        "status": "Published",
        "urlname": "961c038c-8f49-478d-8c61-68f679680da0",
        "updated": "2023-07-17 14:42:00"
      },
      "url": "https://www.notion.so/Python-virtualenvwrapper-961c038c8f49478d8c6168f679680da0",
      "public_url": "https://military-albatross-7a9.notion.site/Python-virtualenvwrapper-961c038c8f49478d8c6168f679680da0"
    },
    {
      "object": "page",
      "id": "fe690171-3af8-4967-993b-825f5a1cd525",
      "created_time": "2023-07-13T09:37:00.000Z",
      "last_edited_time": "2023-07-17T06:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-01-23",
        "type": "Post",
        "category": "Django",
        "slug": "django-hides-the-primary-key-id-in-the-database-with-hash",
        "tags": [],
        "summary": "",
        "title": "Django 用散列隐藏数据库中主键ID",
        "status": "Published",
        "urlname": "fe690171-3af8-4967-993b-825f5a1cd525",
        "updated": "2023-07-17 14:42:00"
      },
      "url": "https://www.notion.so/Django-ID-fe6901713af84967993b825f5a1cd525",
      "public_url": "https://military-albatross-7a9.notion.site/Django-ID-fe6901713af84967993b825f5a1cd525"
    },
    {
      "object": "page",
      "id": "3718ed3c-f70f-43ac-8eb2-51487ab5922c",
      "created_time": "2023-07-13T09:37:00.000Z",
      "last_edited_time": "2023-07-17T06:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-03-17",
        "type": "Post",
        "category": "Docker",
        "slug": "running-crontab-in-docker",
        "tags": [],
        "summary": "",
        "title": "在Docker中运行crontab",
        "status": "Published",
        "urlname": "3718ed3c-f70f-43ac-8eb2-51487ab5922c",
        "updated": "2023-07-17 14:42:00"
      },
      "url": "https://www.notion.so/Docker-crontab-3718ed3cf70f43ac8eb251487ab5922c",
      "public_url": "https://military-albatross-7a9.notion.site/Docker-crontab-3718ed3cf70f43ac8eb251487ab5922c"
    },
    {
      "object": "page",
      "id": "f816711b-a712-4265-ade5-63fe1cc26c9f",
      "created_time": "2023-07-13T09:36:00.000Z",
      "last_edited_time": "2023-07-17T06:42:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-04-05",
        "type": "Post",
        "category": "数据库",
        "slug": "mysql-config-adjust",
        "tags": [
          "MySQL配置"
        ],
        "summary": "",
        "title": "MySQL 配置优化",
        "status": "Published",
        "urlname": "f816711b-a712-4265-ade5-63fe1cc26c9f",
        "updated": "2023-07-17 14:42:00"
      },
      "url": "https://www.notion.so/MySQL-f816711ba7124265ade563fe1cc26c9f",
      "public_url": "https://military-albatross-7a9.notion.site/MySQL-f816711ba7124265ade563fe1cc26c9f"
    },
    {
      "object": "page",
      "id": "84c953d6-d1f7-40c0-b9b0-116ff39f2132",
      "created_time": "2023-07-13T09:35:00.000Z",
      "last_edited_time": "2023-07-17T06:41:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-06-13",
        "type": "Post",
        "category": "Python",
        "slug": "numpy-basic-usage",
        "tags": [
          "Python模块包",
          "Numpy",
          "科学计算",
          "数据分析"
        ],
        "summary": "",
        "title": "NumPy 基础用法",
        "status": "Published",
        "urlname": "84c953d6-d1f7-40c0-b9b0-116ff39f2132",
        "updated": "2023-07-17 14:41:00"
      },
      "url": "https://www.notion.so/NumPy-84c953d6d1f740c0b9b0116ff39f2132",
      "public_url": "https://military-albatross-7a9.notion.site/NumPy-84c953d6d1f740c0b9b0116ff39f2132"
    },
    {
      "object": "page",
      "id": "3009bc34-4eb9-4513-a0a9-fba6db5329c9",
      "created_time": "2023-07-13T09:33:00.000Z",
      "last_edited_time": "2023-07-17T06:41:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-07-24",
        "type": "Post",
        "category": "Python",
        "slug": "pandas-basic-usage",
        "tags": [
          "Python模块包",
          "Pandas",
          "科学计算",
          "数据分析"
        ],
        "summary": "",
        "title": "Pandas 基础用法",
        "status": "Published",
        "urlname": "3009bc34-4eb9-4513-a0a9-fba6db5329c9",
        "updated": "2023-07-17 14:41:00"
      },
      "url": "https://www.notion.so/Pandas-3009bc344eb94513a0a9fba6db5329c9",
      "public_url": "https://military-albatross-7a9.notion.site/Pandas-3009bc344eb94513a0a9fba6db5329c9"
    },
    {
      "object": "page",
      "id": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5",
      "created_time": "2023-07-13T09:32:00.000Z",
      "last_edited_time": "2023-07-17T06:41:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-09-11",
        "type": "Post",
        "category": "数据库",
        "slug": "sometimes-useful-mysql-skill",
        "tags": [
          "MySQL技巧"
        ],
        "summary": "",
        "title": "偶尔用得上的MySQL操作",
        "status": "Published",
        "urlname": "a9ab7bf6-f568-4e0a-8f97-639be1acacf5",
        "updated": "2023-07-17 14:41:00"
      },
      "url": "https://www.notion.so/MySQL-a9ab7bf6f5684e0a8f97639be1acacf5",
      "public_url": "https://military-albatross-7a9.notion.site/MySQL-a9ab7bf6f5684e0a8f97639be1acacf5"
    },
    {
      "object": "page",
      "id": "bbe13887-7af7-4399-ba5e-d1b08398fa9a",
      "created_time": "2023-07-13T09:32:00.000Z",
      "last_edited_time": "2023-07-17T06:41:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-09-27",
        "type": "Post",
        "category": "Python",
        "slug": "python-build-in-function",
        "tags": [
          "Python基础知识"
        ],
        "summary": "",
        "title": "Python 内置方法",
        "status": "Published",
        "urlname": "bbe13887-7af7-4399-ba5e-d1b08398fa9a",
        "updated": "2023-07-17 14:41:00"
      },
      "url": "https://www.notion.so/Python-bbe138877af74399ba5ed1b08398fa9a",
      "public_url": "https://military-albatross-7a9.notion.site/Python-bbe138877af74399ba5ed1b08398fa9a"
    },
    {
      "object": "page",
      "id": "c0c57fa4-044c-4f50-8199-9f12724853ee",
      "created_time": "2023-07-13T09:30:00.000Z",
      "last_edited_time": "2023-07-17T06:40:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-11-30",
        "type": "Post",
        "category": "算法",
        "slug": "algorithm-with-leetcode",
        "tags": [
          "Python",
          "Go",
          "leetcode"
        ],
        "summary": "leetcode 算法刷题记录和总结, 主要使用Python和Go来作答.",
        "title": "leetcode 算法刷题记录",
        "status": "Published",
        "urlname": "c0c57fa4-044c-4f50-8199-9f12724853ee",
        "updated": "2023-07-17 14:40:00"
      },
      "url": "https://www.notion.so/leetcode-c0c57fa4044c4f5081999f12724853ee",
      "public_url": "https://military-albatross-7a9.notion.site/leetcode-c0c57fa4044c4f5081999f12724853ee"
    },
    {
      "object": "page",
      "id": "8a90fccd-b953-4c11-b81f-ef8fc113aa17",
      "created_time": "2023-07-13T09:30:00.000Z",
      "last_edited_time": "2023-07-17T06:38:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-01-31",
        "type": "Post",
        "category": "Golang",
        "slug": "go-base-knowledge",
        "tags": [
          "Golang 基础"
        ],
        "summary": "已经专职做了很久的 Python 开发，不过心中对当初带我入行 C 也一直有些留恋。Go 语言的设计和定位和 C 语言有很多共同之处，也融入了很多现代的设计理念，写起来很有当初写 C 的亲切感。准备好好学习下这门语言，这里记录下一些个人觉得重要的基础知识点，随着不断深入再补充。",
        "title": "Go 基础知识点",
        "status": "Published",
        "urlname": "8a90fccd-b953-4c11-b81f-ef8fc113aa17",
        "updated": "2023-07-17 14:38:00"
      },
      "url": "https://www.notion.so/Go-8a90fccdb9534c11b81fef8fc113aa17",
      "public_url": "https://military-albatross-7a9.notion.site/Go-8a90fccdb9534c11b81fef8fc113aa17"
    },
    {
      "object": "page",
      "id": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e",
      "created_time": "2023-07-13T09:29:00.000Z",
      "last_edited_time": "2023-07-17T06:33:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-06-19",
        "type": "Post",
        "category": "项目架构",
        "slug": "first-exploration-of-mirco-service",
        "tags": [
          "mircoservices",
          "Go",
          "go-mirco"
        ],
        "summary": "日常工作中一直在用 Django 这类 MVC 架构的框架来搭建后台。然而早已对微服务架构闻名已久，早想有机会实践一下，靠着搜索引擎找到这篇不错的教程：Golang 微服务教程，总结了微服务开发、测试到部署的完整过程。跟着初步实践了下微服务的构建过程，过了下微服务的瘾，在这里总结下。",
        "title": "初探微服务",
        "status": "Published",
        "urlname": "15201ca9-e4bc-47e1-9a7e-08bf84a85d4e",
        "updated": "2023-07-17 14:33:00"
      },
      "url": "https://www.notion.so/15201ca9e4bc47e19a7e08bf84a85d4e",
      "public_url": "https://military-albatross-7a9.notion.site/15201ca9e4bc47e19a7e08bf84a85d4e"
    },
    {
      "object": "page",
      "id": "aee256a0-e9d4-45bb-889d-1bca9f2c8251",
      "created_time": "2023-07-13T09:27:00.000Z",
      "last_edited_time": "2023-07-17T06:33:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-09-01",
        "type": "Post",
        "category": "项目架构",
        "slug": "seckill-backend-system-base-on-go-micro",
        "tags": [
          "mircoservices",
          "go-mirco",
          "秒杀系统"
        ],
        "summary": "前段时间了解到了Go-micro这一微服务开发框架，并基于此框架的教程搭建了一套码头货运管理微服务系统。这次使用Micro来设计和实现了一套更接地气的秒杀系统。\n\n对于秒杀，以及抽奖、抢红包这类系统的最大特点便是在某个时间点会瞬间涌入大量的用户，给系统造成瞬间高于平时千百倍的并发压力。针对这样的特点在设计微服务时就需要考虑一系列的措施来保障系统在高并发场景时可以稳定运行。\n\n完整代码地址",
        "title": "基于Go-micro微服务的秒杀系统",
        "status": "Published",
        "urlname": "aee256a0-e9d4-45bb-889d-1bca9f2c8251",
        "updated": "2023-07-17 14:33:00"
      },
      "url": "https://www.notion.so/Go-micro-aee256a0e9d445bb889d1bca9f2c8251",
      "public_url": "https://military-albatross-7a9.notion.site/Go-micro-aee256a0e9d445bb889d1bca9f2c8251"
    },
    {
      "object": "page",
      "id": "8456f952-9d1d-4ebd-8a23-542c69ba7d68",
      "created_time": "2023-07-13T09:26:00.000Z",
      "last_edited_time": "2023-07-17T06:32:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-12-18",
        "type": "Post",
        "category": "项目架构",
        "slug": "use-gin-and-websocket-to-play-rtsp-video",
        "tags": [
          "Gin",
          "WebSocket",
          "RTSP",
          "Go"
        ],
        "summary": "项目地址：gin-rtsp\n\n在后台的开发中遇到了对接显示摄像头视频流的需求。目前获取海康及大华等主流的摄像头的视频流使用的基本都是RTSP协议。不过HTML页面并不能直接播放RTSP协议的视频流，查询了一番各种网页播放RTSP的资料，有如下的一些方案：",
        "title": "使用Gin+WebSocket在HTML中无插件播放RTSP",
        "status": "Published",
        "urlname": "8456f952-9d1d-4ebd-8a23-542c69ba7d68",
        "updated": "2023-07-17 14:32:00"
      },
      "url": "https://www.notion.so/Gin-WebSocket-HTML-RTSP-8456f9529d1d4ebd8a23542c69ba7d68",
      "public_url": "https://military-albatross-7a9.notion.site/Gin-WebSocket-HTML-RTSP-8456f9529d1d4ebd8a23542c69ba7d68"
    },
    {
      "object": "page",
      "id": "0498bc63-4538-4d18-94f2-6edf9b92f43f",
      "created_time": "2023-07-13T09:22:00.000Z",
      "last_edited_time": "2023-07-18T16:05:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-01-01",
        "type": "Post",
        "category": "Golang",
        "slug": "golang-scheduler",
        "tags": [
          "Golang 底层",
          "Golang scheduler"
        ],
        "summary": "转载至 https://www.cnblogs.com/qcrao-2018/p/11442998.html, 一篇很不错讲解 Golang scheduler 的文章。\n\n在 Go 语言里，go func 是并发的单元，chan 是协调并发单元的机制，panic 和 recover 是出错处理的机制，而 defer 是神来之笔，大大简化了出错的管理。\n\nGoroutines 在同一个用户空间里同时独立执行 functions，channels 则用于 goroutines 间的通信和同步访问控制。",
        "title": "[转载]深度解密Go语言之 scheduler",
        "status": "Published",
        "urlname": "0498bc63-4538-4d18-94f2-6edf9b92f43f",
        "updated": "2023-07-19 00:05:00"
      },
      "url": "https://www.notion.so/Go-scheduler-0498bc6345384d1894f26edf9b92f43f",
      "public_url": "https://military-albatross-7a9.notion.site/Go-scheduler-0498bc6345384d1894f26edf9b92f43f"
    },
    {
      "object": "page",
      "id": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8",
      "created_time": "2023-07-13T09:20:00.000Z",
      "last_edited_time": "2023-07-17T03:31:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-02-10",
        "type": "Post",
        "category": "项目架构",
        "slug": "build-devops-project",
        "tags": [
          "devOps",
          "Jenkins",
          "kubernetes",
          "Gin"
        ],
        "summary": "在后端的开发领域，各类开发框架都已经很多，在开发项目时可以根据不同的需要和需求选择合适的开发框架。然而在需要开发一个完善的工程化项目时，仅仅一个后端开发框架是不够的，还面临着在对开发项目的快速迭代中进行测试，部署，监控等问题。为了解决这些问题，DevOps的开发模式应运而生。\n\n基于个人对DevOps的理解，搭建了一个基于Gin的开源后端项目来实践下DevOps的各个概念：https://github.com/wanghaoxi3000/advproject。\n\nDevOps是一个宽泛的概念，这个项目也只是抛砖引玉，在测试环境下串联起各个DevOps的基础工具，存在的不足欢迎指出，一起学习和交流。",
        "title": "搭建DevOps模式的项目",
        "status": "Published",
        "urlname": "0274ac91-4d69-4aa4-9fc2-4acdc6c306c8",
        "updated": "2023-07-17 11:31:00"
      },
      "url": "https://www.notion.so/DevOps-0274ac914d694aa49fc24acdc6c306c8",
      "public_url": "https://military-albatross-7a9.notion.site/DevOps-0274ac914d694aa49fc24acdc6c306c8"
    },
    {
      "object": "page",
      "id": "dbd2a274-4236-478d-9324-880043009ccd",
      "created_time": "2023-07-13T09:20:00.000Z",
      "last_edited_time": "2023-07-17T03:30:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-06-16",
        "type": "Post",
        "category": "Linux管理",
        "slug": "source-mirrors-change",
        "tags": [
          "mirror",
          "镜像源"
        ],
        "summary": "国内的网络问题，经常需要替换软件本身的更新源，加快软件的下载速度。这里记录下常用国内镜像源。",
        "title": "国内镜像源",
        "status": "Published",
        "urlname": "dbd2a274-4236-478d-9324-880043009ccd",
        "updated": "2023-07-17 11:30:00"
      },
      "url": "https://www.notion.so/dbd2a2744236478d9324880043009ccd",
      "public_url": "https://military-albatross-7a9.notion.site/dbd2a2744236478d9324880043009ccd"
    },
    {
      "object": "page",
      "id": "de496bfb-9b9d-4b57-8faa-d40e479c7d41",
      "created_time": "2023-07-13T09:20:00.000Z",
      "last_edited_time": "2023-07-17T03:29:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-06-23",
        "type": "Post",
        "category": "Golang",
        "slug": "the-value-type-struct-of-map-cannot-assign",
        "tags": [
          "Golang 基础"
        ],
        "summary": "在Golang中，当一个map的value为一个值类型的结构体时，是不能对其赋值的，修改结构体的数值的。",
        "title": "map中值类型结构体无法赋值",
        "status": "Published",
        "urlname": "de496bfb-9b9d-4b57-8faa-d40e479c7d41",
        "updated": "2023-07-17 11:29:00"
      },
      "url": "https://www.notion.so/map-de496bfb9b9d4b578faad40e479c7d41",
      "public_url": "https://military-albatross-7a9.notion.site/map-de496bfb9b9d4b578faad40e479c7d41"
    },
    {
      "object": "page",
      "id": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39",
      "created_time": "2023-07-13T09:20:00.000Z",
      "last_edited_time": "2023-07-17T03:28:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-09-16",
        "type": "Post",
        "category": "Golang",
        "slug": "type-declarations-and-type-aliases",
        "tags": [
          "Golang 基础"
        ],
        "summary": "Golang 语言中，我们可以用关键字type声明自定义的各种类型。在使用type时，声明的自定义类型有不同的区别。",
        "title": "别名和类型再定义",
        "status": "Published",
        "urlname": "edb82b59-31b5-4fd6-bcd6-7fe3b8050d39",
        "updated": "2023-07-17 11:28:00"
      },
      "url": "https://www.notion.so/edb82b5931b54fd6bcd67fe3b8050d39",
      "public_url": "https://military-albatross-7a9.notion.site/edb82b5931b54fd6bcd67fe3b8050d39"
    },
    {
      "object": "page",
      "id": "5254d509-659c-488c-9fc6-28b07901dd5d",
      "created_time": "2023-07-13T09:19:00.000Z",
      "last_edited_time": "2023-07-17T03:24:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-10-01",
        "type": "Post",
        "category": "Golang",
        "slug": "run-goroutine-by-ordered",
        "tags": [
          "Golang 基础"
        ],
        "summary": "Golang 中 goroutine 中的运行是无序的，如果要让多个 goroutine 顺序执行，例如每个 goroutine 在并行执行时顺序打印 0-9，这里记录一种通过 atomic 包的原子操作来实现的方法。",
        "title": "多个goroutine按既定顺序运行",
        "status": "Published",
        "urlname": "5254d509-659c-488c-9fc6-28b07901dd5d",
        "updated": "2023-07-17 11:24:00"
      },
      "url": "https://www.notion.so/goroutine-5254d509659c488c9fc628b07901dd5d",
      "public_url": "https://military-albatross-7a9.notion.site/goroutine-5254d509659c488c9fc628b07901dd5d"
    },
    {
      "object": "page",
      "id": "ba9c45bd-1568-4097-a5b4-e64168d3755d",
      "created_time": "2023-07-13T09:19:00.000Z",
      "last_edited_time": "2023-07-17T03:23:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-10-13",
        "type": "Post",
        "category": "Golang",
        "slug": "the-difference-of-range-array-and-slice",
        "tags": [
          "Golang 基础"
        ],
        "summary": "Go 语言的 range 表达式遵循如下两个规则：\nrange表达式只会在for语句开始执行时被求值一次，无论后边会有多少次迭代\nrange表达式的求值结果会被复制，也就是说，被迭代的对象是range表达式结果值的副本而不是原值",
        "title": "range 数组和切片的差异",
        "status": "Published",
        "urlname": "ba9c45bd-1568-4097-a5b4-e64168d3755d",
        "updated": "2023-07-17 11:23:00"
      },
      "url": "https://www.notion.so/range-ba9c45bd15684097a5b4e64168d3755d",
      "public_url": "https://military-albatross-7a9.notion.site/range-ba9c45bd15684097a5b4e64168d3755d"
    },
    {
      "object": "page",
      "id": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a",
      "created_time": "2023-07-13T09:18:00.000Z",
      "last_edited_time": "2023-07-17T03:20:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-11-25",
        "type": "Post",
        "category": "Golang",
        "slug": "go-advance-summary",
        "tags": [
          "Golang 基础"
        ],
        "summary": "看完了 go-advice, 记录下一些要点和自己值得注意的地方。",
        "title": "Go-Advance 总结",
        "status": "Published",
        "urlname": "8b9502d4-ae75-4a48-a9d4-081be28a8d4a",
        "updated": "2023-07-17 11:20:00"
      },
      "url": "https://www.notion.so/Go-Advance-8b9502d4ae754a48a9d4081be28a8d4a",
      "public_url": "https://military-albatross-7a9.notion.site/Go-Advance-8b9502d4ae754a48a9d4081be28a8d4a"
    },
    {
      "object": "page",
      "id": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc",
      "created_time": "2023-07-13T09:18:00.000Z",
      "last_edited_time": "2023-07-14T03:04:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2021-04-18",
        "type": "Post",
        "category": "kafka",
        "slug": "kafka-study-note--deploy-kafka-test-env-in-k8s",
        "tags": [
          "kafka",
          "k8s"
        ],
        "summary": "准备深入的学习下kafka，先从搭建一个开发环境，编写一个简单的测试程序开始吧。",
        "title": "kafka学习笔记-搭建基于k8s的kafka测试环境",
        "status": "Published",
        "urlname": "a13b76fb-7fff-4fb9-9cc6-f9ed602cf3fc",
        "updated": "2023-07-14 11:04:00"
      },
      "url": "https://www.notion.so/kafka-k8s-kafka-a13b76fb7fff4fb99cc6f9ed602cf3fc",
      "public_url": "https://military-albatross-7a9.notion.site/kafka-k8s-kafka-a13b76fb7fff4fb99cc6f9ed602cf3fc"
    },
    {
      "object": "page",
      "id": "c2c92a3e-f090-44de-a28e-12cb3fff3c20",
      "created_time": "2023-07-13T09:17:00.000Z",
      "last_edited_time": "2023-07-14T03:03:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2021-05-11",
        "type": "Post",
        "category": "kafka",
        "slug": "kafka--kafka-study-note--kafka-term",
        "tags": [
          "kafka"
        ],
        "summary": "",
        "title": "kafka学习笔记-kafka术语介绍",
        "status": "Published",
        "urlname": "c2c92a3e-f090-44de-a28e-12cb3fff3c20",
        "updated": "2023-07-14 11:03:00"
      },
      "url": "https://www.notion.so/kafka-kafka-c2c92a3ef09044dea28e12cb3fff3c20",
      "public_url": "https://military-albatross-7a9.notion.site/kafka-kafka-c2c92a3ef09044dea28e12cb3fff3c20"
    },
    {
      "object": "page",
      "id": "8fa8898a-3851-4346-8e67-8d17aa5430f5",
      "created_time": "2023-07-13T08:50:00.000Z",
      "last_edited_time": "2023-07-14T02:59:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2022-02-27",
        "type": "Post",
        "category": "Golang",
        "slug": "the-design-and-implement-of-golang-malloc",
        "tags": [
          "Golang 原理"
        ],
        "summary": "原文链接 https://mp.weixin.qq.com/s/TO_lmlFbVDgFmns9s_mMzw\n\n程序中的数据和变量都会被分配到程序所在的虚拟内存中，内存空间包含两个重要区域 — 栈区（Stack）和堆区（Heap）。函数调用的参数、返回值以及局部变量大都会被分配到栈上，这部分内存会由编译器进行管理；不同编程语言使用不同的方法管理堆区的内存，C++ 等编程语言会由工程师主动申请和释放内存，Go 以及 Java 等编程语言会由工程师和编译器共同管理，堆中的对象由内存分配器分配并由垃圾收集器回收。\n\n不同的编程语言会选择不同的方式管理内存，本节会介绍 Go 语言内存分配器，详细分析内存分配的过程以及其背后的设计与实现原理。",
        "title": "Go 内存分配器的设计与实现[转载]",
        "status": "Published",
        "urlname": "8fa8898a-3851-4346-8e67-8d17aa5430f5",
        "updated": "2023-07-14 10:59:00"
      },
      "url": "https://www.notion.so/Go-8fa8898a385143468e678d17aa5430f5",
      "public_url": "https://military-albatross-7a9.notion.site/Go-8fa8898a385143468e678d17aa5430f5"
    },
    {
      "object": "page",
      "id": "6962857b-5906-4f7e-825a-d671e2b403e7",
      "created_time": "2023-07-13T08:43:00.000Z",
      "last_edited_time": "2023-07-14T02:21:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2022-09-25",
        "type": "Post",
        "category": "Golang",
        "slug": "golang-memory-escape",
        "tags": [
          "Golang 原理"
        ],
        "summary": "什么是内存逃逸在一段程序中，每一个函数都会有自己的内存区域存放自己的局部变量、返回地址等，这些内存会由编译器在栈中进行分配，每一个函数都会分配一个栈桢，在函数运行结束后进行销毁，但是有些变量我们想在函数运行结束后仍然使用它，那么就需要把这个变量在堆上分配，这种从\"栈\"上逃逸到\"堆\"上的现象就成为内存逃逸。",
        "title": "Golang 内存逃逸",
        "status": "Published",
        "urlname": "6962857b-5906-4f7e-825a-d671e2b403e7",
        "updated": "2023-07-14 10:21:00"
      },
      "url": "https://www.notion.so/Golang-6962857b59064f7e825ad671e2b403e7",
      "public_url": "https://military-albatross-7a9.notion.site/Golang-6962857b59064f7e825ad671e2b403e7"
    },
    {
      "object": "page",
      "id": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9",
      "created_time": "2023-07-13T08:41:00.000Z",
      "last_edited_time": "2023-07-14T02:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2022-10-30",
        "type": "Post",
        "category": "项目架构",
        "slug": "talk-about-load-blance-by-bilibili-crash-on-220713",
        "tags": [
          "Load Blance",
          "kubernetes"
        ],
        "summary": "前段时间看了B站发的20210713网站崩溃事件 的总结分析。小破站崩掉的具体原因已在文章做了详细的分析，就不在这里做详谈了，而是总结下文章多次提及了七层SLB、四层LB相关的 Load Balance 负载均衡知识点。",
        "title": "由B站210713崩溃事件聊聊负载均衡",
        "status": "Published",
        "urlname": "8bdaf8a0-13cb-4050-9ba2-9775024c9cc9",
        "updated": "2023-07-14 10:10:00"
      },
      "url": "https://www.notion.so/B-210713-8bdaf8a013cb40509ba29775024c9cc9",
      "public_url": "https://military-albatross-7a9.notion.site/B-210713-8bdaf8a013cb40509ba29775024c9cc9"
    },
    {
      "object": "page",
      "id": "64eee45b-1c09-4042-99bb-97164e113a1d",
      "created_time": "2023-07-13T06:15:00.000Z",
      "last_edited_time": "2023-07-13T06:17:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2018-08-23",
        "type": "Post",
        "category": "软件工具",
        "slug": "sometimes-useful-git-skill",
        "tags": [
          "Git"
        ],
        "summary": "",
        "title": "偶尔用得上的 Git 操作",
        "status": "Published",
        "urlname": "64eee45b-1c09-4042-99bb-97164e113a1d",
        "updated": "2023-07-13 14:17:00"
      },
      "url": "https://www.notion.so/Git-64eee45b1c09404299bb97164e113a1d",
      "public_url": "https://military-albatross-7a9.notion.site/Git-64eee45b1c09404299bb97164e113a1d"
    },
    {
      "object": "page",
      "id": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9",
      "created_time": "2023-07-13T06:13:00.000Z",
      "last_edited_time": "2023-07-17T09:08:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-01-03",
        "type": "Post",
        "category": "软件工具",
        "slug": "manage-hexo-theme-with-git-submodules",
        "tags": [
          "Git"
        ],
        "summary": "hexo 中有着丰富的主题可以选择, 大部分的使用示例或者教程都是将主题 clone 到 theme 文件夹中来使用. 但这样来使用主题会存在如下的问题:\n- theme 中的主题属于一个独立的 Git 项目, 有自己的 .git 项目文件夹, 提交 hexo 项目时默认不会提交 theme 的 .git 文件夹, 在其他电脑上 clone 后会失去 theme 原本的版本控制功能.\n- 使用自己修改的主题时, 每次更改完主题, 需要在主题文件夹中提交一次, 然后再在 hexo 项目根文件夹中提交一次, 会产生两次修改内容一样的提交, 不够优雅.\n还好万能的 Git 针对这种问题已经有了成熟的解决方案, 通过自带的 Git submodules 功能即可优雅的避免以上的问题.",
        "title": "在 hexo 中使用 git submodules 管理主题",
        "status": "Published",
        "urlname": "aaf7e84f-1b4d-44f6-a833-8e1e158edae9",
        "updated": "2023-07-17 17:08:00"
      },
      "url": "https://www.notion.so/hexo-git-submodules-aaf7e84f1b4d44f6a8338e1e158edae9",
      "public_url": "https://military-albatross-7a9.notion.site/hexo-git-submodules-aaf7e84f1b4d44f6a8338e1e158edae9"
    },
    {
      "object": "page",
      "id": "88579025-d6b7-43ae-98bb-12b52f90bcd9",
      "created_time": "2023-07-13T06:10:00.000Z",
      "last_edited_time": "2023-07-13T06:14:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-01-13",
        "type": "Post",
        "category": "软件工具",
        "slug": "versatility-uwsgi-config",
        "tags": [
          "Python",
          "nginx"
        ],
        "summary": "在进行 Python web 开发时，使用 Django、Flask 等框架开发完毕后，部署时通常需要选择一个支持 wsgi 协议的 Web 服务器程序。目前比较通用的选择是 nginx + uWSGI，使用 nginx 来处理静态文件请求，其余动态内容再转发给 uWSGI 交给 web 后台处理，网上这样的配置教程也是最多的。作为两款大名鼎鼎的服务器程序 nginx 负责静态文件，uWSGI 负责动态内容，各种在自己擅长的领域各施其职，的确效率很高，是高性能的 Python web 系统部署时的首选。不过有时用 Python 写了个小站点，性能需求并不高时。部署服务还要安装 nginx 和 uWSGI 两个服务器程序就显得有点麻烦了。能否把这些工作都交给一个服务器程序呢。",
        "title": "全能型 uWSGI 配置",
        "status": "Published",
        "urlname": "88579025-d6b7-43ae-98bb-12b52f90bcd9",
        "updated": "2023-07-13 14:14:00"
      },
      "url": "https://www.notion.so/uWSGI-88579025d6b743ae98bb12b52f90bcd9",
      "public_url": "https://military-albatross-7a9.notion.site/uWSGI-88579025d6b743ae98bb12b52f90bcd9"
    },
    {
      "object": "page",
      "id": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230",
      "created_time": "2023-07-13T06:06:00.000Z",
      "last_edited_time": "2023-07-13T06:09:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-03-17",
        "type": "Post",
        "category": "软件工具",
        "slug": "use-ci-system-to-free-time",
        "tags": [
          "CI",
          "Jenkins"
        ],
        "summary": "程序猿除了希望写好代码，一定也想着自己的项目可以如何快速的迭代上线，从而可以专注的完成代码的编写，减少繁杂的运维等工作。例如完成一项功能的开发后，推送到 Git 等代码管理系统后，剩下的测试、部署、上线等工作可以交给一个系统来自动化完成，这时便可以靠持续集成系统了。这里记录下我使用老牌的 Jenkins 持续集成系统来帮助自己完成的工作。",
        "title": "使用持续集成系统解放生产力",
        "status": "Published",
        "urlname": "cc4cad06-98f6-48d5-bab8-3ecfb7fd8230",
        "updated": "2023-07-13 14:09:00"
      },
      "url": "https://www.notion.so/cc4cad0698f648d5bab83ecfb7fd8230",
      "public_url": "https://military-albatross-7a9.notion.site/cc4cad0698f648d5bab83ecfb7fd8230"
    },
    {
      "object": "page",
      "id": "adf14ce3-4a96-4009-b132-1786ae179cc0",
      "created_time": "2023-07-11T10:50:00.000Z",
      "last_edited_time": "2023-07-11T10:51:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2019-09-09",
        "type": "Post",
        "category": "软件工具",
        "slug": "deploy-kubernetes-on-ubuntu18",
        "tags": [
          "kubernetes"
        ],
        "summary": "为了有个k8s的测试环境，使用了三台ubuntu18的系统搭建了一套k8s测试环境，主要参考了和我一步步部署 kubernetes 集群这个项目，这个项目对于如何一步步搭建起k8s集群环境已经很详细了，不过对于ubuntu 18.04的环境还是有一些小坑，这里记录一下。",
        "title": "在ubuntu18.04上部署kubernetes",
        "status": "Published",
        "urlname": "adf14ce3-4a96-4009-b132-1786ae179cc0",
        "updated": "2023-07-11 18:51:00"
      },
      "url": "https://www.notion.so/ubuntu18-04-kubernetes-adf14ce34a964009b1321786ae179cc0",
      "public_url": "https://military-albatross-7a9.notion.site/ubuntu18-04-kubernetes-adf14ce34a964009b1321786ae179cc0"
    },
    {
      "object": "page",
      "id": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0",
      "created_time": "2023-07-11T07:54:00.000Z",
      "last_edited_time": "2023-07-13T06:10:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2020-12-08",
        "type": "Post",
        "category": "软件工具",
        "slug": "sync-github-project-and-publish-on-coding",
        "tags": [
          "github",
          "coding",
          "devOps"
        ],
        "summary": "coding 提供了一套免费的静态页面服务，还可以自定义域名，本人的 airaNg 服务页面也是部署在coding的静态页面服务当中。不过 ariaNg 还会不断更新，如何在 ariaNg 原项目版本升级后自动更新自己部署的在 coding 的页面呢，这里利用 coding 自带的持续集成功能来完成这种自定义的操作。\n目前coding的静态页面服务已进行了修改，使用腾讯云的 oss 和 cdn 来部署了，虽然速度和稳定性有了提升，但可能也会产生费用。",
        "title": "使用coding自动同步和部署Github项目",
        "status": "Published",
        "urlname": "c631f70a-8388-4ff0-bfb4-c3e41fc3ece0",
        "updated": "2023-07-13 14:10:00"
      },
      "url": "https://www.notion.so/coding-Github-c631f70a83884ff0bfb4c3e41fc3ece0",
      "public_url": "https://military-albatross-7a9.notion.site/coding-Github-c631f70a83884ff0bfb4c3e41fc3ece0"
    },
    {
      "object": "page",
      "id": "854d17ad-00a6-4105-8292-ca67eea97d21",
      "created_time": "2023-07-11T07:46:00.000Z",
      "last_edited_time": "2023-07-14T02:21:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2022-09-13",
        "type": "Post",
        "category": "软件工具",
        "slug": "clang-header-file-not-fuound-under-mac",
        "tags": [
          "mac"
        ],
        "summary": "入手了一台 MacBook Air m2, 开始进入 MAC 的生态, 不过刚装好常用的开发环境, 在编译一个 golang 项目时就出现了一个找不到头文件的问题.",
        "title": "mac 系统找不到 clang 头文件",
        "status": "Published",
        "urlname": "854d17ad-00a6-4105-8292-ca67eea97d21",
        "updated": "2023-07-14 10:21:00"
      },
      "url": "https://www.notion.so/mac-clang-854d17ad00a641058292ca67eea97d21",
      "public_url": "https://military-albatross-7a9.notion.site/mac-clang-854d17ad00a641058292ca67eea97d21"
    },
    {
      "object": "page",
      "id": "c370350a-d366-45a1-b383-b5056de0e7b0",
      "created_time": "2023-07-10T09:50:00.000Z",
      "last_edited_time": "2023-07-18T17:11:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-07-11",
        "type": "Post",
        "category": "软件工具",
        "slug": "deploy-download-tool-aria2-pro",
        "tags": [
          "aria2"
        ],
        "summary": "几年前刚搭建了黑群晖时，在群晖的 docker 中跑了一个网友改造的 aria2 下载器，包含了一个已经配置好的 aria2 内核和一个 AriaNG 控制页面。之后应该是一次也没更新过，如今这个 aria2 下载器下载BT种子的话已经基本没有任何速度。AriaNG 页面也落后了很多个版本了。想着更新一下，因此发现了这个项目：Aria2-Pro-Docker 。",
        "title": "部署下载神器 Aria2 Pro",
        "status": "Published",
        "urlname": "c370350a-d366-45a1-b383-b5056de0e7b0",
        "updated": "2023-07-19 01:11:00"
      },
      "url": "https://www.notion.so/Aria2-Pro-c370350ad36645a1b383b5056de0e7b0",
      "public_url": "https://military-albatross-7a9.notion.site/Aria2-Pro-c370350ad36645a1b383b5056de0e7b0"
    },
    {
      "object": "page",
      "id": "e346dc18-cd99-4f15-8182-fc9ede484429",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-07-05T11:02:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://static-1256611153.file.myqcloud.com/img/picgo/202304100031508.webp"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-04-09",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230409",
        "tags": [
          "chatGPT",
          "MidJourney",
          "WakaTime"
        ],
        "summary": "有了小电驴后，这几周都有骑着出去兜兜风，发现了很多不知名的小角落，让自己对这座本以为很熟悉城市多了一些新鲜感。例如此图自于骑着电驴从公司回家的路程中，看到了路边的一座小游乐园，相比于单调的地铁，让这趟行程有趣了许多。",
        "title": "一周随笔20230409",
        "status": "Published",
        "urlname": "e346dc18-cd99-4f15-8182-fc9ede484429",
        "updated": "2023-07-05 19:02:00"
      },
      "url": "https://www.notion.so/20230409-e346dc18cd994f158182fc9ede484429",
      "public_url": "https://military-albatross-7a9.notion.site/20230409-e346dc18cd994f158182fc9ede484429"
    },
    {
      "object": "page",
      "id": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-08-11T10:05:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2022-07-23",
        "type": "Post",
        "category": "博客记录",
        "slug": "blog-decorate-record",
        "tags": [],
        "summary": "选定博客生成系统往往只是打造自己博客的第一步，这里记录了本博客从 hexo 迁移到 hugo 后，后续的功能集成步骤。",
        "title": "博客装修记",
        "status": "Published",
        "urlname": "46b9ecad-c2f6-4f79-bd50-b778ef0a0694",
        "updated": "2023-08-11 18:05:00"
      },
      "url": "https://www.notion.so/46b9ecadc2f64f79bd50b778ef0a0694",
      "public_url": "https://military-albatross-7a9.notion.site/46b9ecadc2f64f79bd50b778ef0a0694"
    },
    {
      "object": "page",
      "id": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-07-10T09:12:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-03-26",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230226",
        "tags": [],
        "summary": "理想的Blog系统",
        "title": "一周随笔20230226",
        "status": "Published",
        "urlname": "8eb3eefd-7ff0-40ff-abfe-3e16320737ee",
        "updated": "2023-07-10 17:12:00"
      },
      "url": "https://www.notion.so/20230226-8eb3eefd7ff040ffabfe3e16320737ee",
      "public_url": "https://military-albatross-7a9.notion.site/20230226-8eb3eefd7ff040ffabfe3e16320737ee"
    },
    {
      "object": "page",
      "id": "d8a704d7-d453-48c7-b249-a5e7ec0150b6",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-08-27T18:11:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://static-1256611153.file.myqcloud.com/img/picgo/202305080014419.webp"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "date": "2023-05-22",
        "type": "Post",
        "category": "数字溪流",
        "slug": "life-stream-2305-w1",
        "tags": [
          "技术见闻",
          "效率提升"
        ],
        "summary": "五一没出去旅游，回了趟家乡，位于四川南门的小城攀枝花。去年通了高铁，相比于之前动辄12小时的普通火车，现在只需要4个多小时既能回家一趟了。非常喜欢这座位于亚热带的城市气候，目前月份已是天天晴朗的阳光，光亮亮的但不会闷热，相比于时长阴沉沉的成都，心情会好上不少，走在商业区，灯光跟人气都还不错，烟火气息很足，一种安心的回家感。",
        "title": "数字溪流2305-W1",
        "status": "Published",
        "urlname": "d8a704d7-d453-48c7-b249-a5e7ec0150b6",
        "updated": "2023-08-28 02:11:00"
      },
      "url": "https://www.notion.so/2305-W1-d8a704d7d45348c7b249a5e7ec0150b6",
      "public_url": "https://military-albatross-7a9.notion.site/2305-W1-d8a704d7d45348c7b249a5e7ec0150b6"
    },
    {
      "object": "page",
      "id": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-07-10T09:03:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://static-1256611153.file.myqcloud.com/img/picgo/202303191448519.jpeg"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-03-19",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230319",
        "tags": [],
        "summary": "成功增驾摩托D照后，入手了人生第一台电摩，台铃赤兔。本来想买台铃的萌苏，不过家附近的店没有网上的款式，就看了这款。造型说不上多好看，胜在比较有特点吧，前后都有眼睛一样的双灯，两侧还有一排蓝灯，很有氛围，前轮的大碟刹也挺霸气，白色款还挺有兔子的感觉，车架也比较大，有赤兔马的气势。",
        "title": "一周随笔20230319",
        "status": "Published",
        "urlname": "8a6872fc-1ca1-4f76-af70-f97d5c468b1e",
        "updated": "2023-07-10 17:03:00"
      },
      "url": "https://www.notion.so/20230319-8a6872fc1ca14f76af70f97d5c468b1e",
      "public_url": "https://military-albatross-7a9.notion.site/20230319-8a6872fc1ca14f76af70f97d5c468b1e"
    },
    {
      "object": "page",
      "id": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-08-11T10:05:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": null,
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2022-07-08",
        "type": "Post",
        "category": "博客记录",
        "slug": "move-blog-to-hugo",
        "tags": [],
        "summary": "经过了一段时间的纠结，还是把博客从Hexo迁移到了Hugo",
        "title": "迁移博客至Hugo",
        "status": "Published",
        "urlname": "c99dd1d6-9b94-4bd6-8e34-ab5ba0aa894a",
        "updated": "2023-08-11 18:05:00"
      },
      "url": "https://www.notion.so/Hugo-c99dd1d69b944bd68e34ab5ba0aa894a",
      "public_url": "https://military-albatross-7a9.notion.site/Hugo-c99dd1d69b944bd68e34ab5ba0aa894a"
    },
    {
      "object": "page",
      "id": "0433ceef-587e-4f62-bdce-5c25138bea96",
      "created_time": "2023-07-04T08:26:00.000Z",
      "last_edited_time": "2023-07-10T09:05:00.000Z",
      "created_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "last_edited_by": {
        "object": "user",
        "id": "770a3cb9-0a43-4c92-9eff-fd44faf5a915"
      },
      "cover": {
        "type": "external",
        "external": {
          "url": "https://static-1256611153.file.myqcloud.com/img/picgo/202303131828393.webp"
        }
      },
      "icon": null,
      "parent": {
        "type": "database_id",
        "database_id": "ae3c8c9f-d2e7-490c-b298-0f96e33fe57e"
      },
      "archived": false,
      "properties": {
        "password": "",
        "icon": "",
        "date": "2023-03-13",
        "type": "Post",
        "category": "数字溪流",
        "slug": "one-week-essay-20230313",
        "tags": [],
        "summary": "最近准备去增驾一个D照, 一个是闲着没事学点技能以后说不定也用得着(~~入职美团外卖部啥的~~), 另外夏天快要来了, 想入手一辆电摩去兜兜风. 按新国标来看, 电摩也属于摩托车需要通过驾照考试才能上路的.",
        "title": "一周随笔20230313",
        "status": "Published",
        "urlname": "0433ceef-587e-4f62-bdce-5c25138bea96",
        "updated": "2023-07-10 17:05:00"
      },
      "url": "https://www.notion.so/20230313-0433ceef587e4f62bdce5c25138bea96",
      "public_url": "https://military-albatross-7a9.notion.site/20230313-0433ceef587e4f62bdce5c25138bea96"
    }
  ]
}